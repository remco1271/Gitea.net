/*
 * Gitea API
 *
 * This documentation describes the Gitea API.
 *
 * The version of the OpenAPI document: 1.22.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using Org.OpenAPITools.Client;
using Org.OpenAPITools.Model;

namespace Org.OpenAPITools.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IRepositoryApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Accept a repo transfer
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to transfer</param>
        /// <param name="repo">name of the repo to transfer</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Repository</returns>
        Repository AcceptRepoTransfer(string owner, string repo, int operationIndex = 0);

        /// <summary>
        /// Accept a repo transfer
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to transfer</param>
        /// <param name="repo">name of the repo to transfer</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Repository</returns>
        ApiResponse<Repository> AcceptRepoTransferWithHttpInfo(string owner, string repo, int operationIndex = 0);
        /// <summary>
        /// Create a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Repository</returns>
        Repository CreateCurrentUserRepo(CreateRepoOption? body = default(CreateRepoOption?), int operationIndex = 0);

        /// <summary>
        /// Create a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Repository</returns>
        ApiResponse<Repository> CreateCurrentUserRepoWithHttpInfo(CreateRepoOption? body = default(CreateRepoOption?), int operationIndex = 0);
        /// <summary>
        /// Fork a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to fork</param>
        /// <param name="repo">name of the repo to fork</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Repository</returns>
        Repository CreateFork(string owner, string repo, CreateForkOption? body = default(CreateForkOption?), int operationIndex = 0);

        /// <summary>
        /// Fork a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to fork</param>
        /// <param name="repo">name of the repo to fork</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Repository</returns>
        ApiResponse<Repository> CreateForkWithHttpInfo(string owner, string repo, CreateForkOption? body = default(CreateForkOption?), int operationIndex = 0);
        /// <summary>
        /// Create a repo-level variable
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="variablename">name of the variable</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void CreateRepoVariable(string owner, string repo, string variablename, CreateVariableOption? body = default(CreateVariableOption?), int operationIndex = 0);

        /// <summary>
        /// Create a repo-level variable
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="variablename">name of the variable</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> CreateRepoVariableWithHttpInfo(string owner, string repo, string variablename, CreateVariableOption? body = default(CreateVariableOption?), int operationIndex = 0);
        /// <summary>
        /// Delete a secret in a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repository</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="secretname">name of the secret</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void DeleteRepoSecret(string owner, string repo, string secretname, int operationIndex = 0);

        /// <summary>
        /// Delete a secret in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repository</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="secretname">name of the secret</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteRepoSecretWithHttpInfo(string owner, string repo, string secretname, int operationIndex = 0);
        /// <summary>
        /// Delete a repo-level variable
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="variablename">name of the variable</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ActionVariable</returns>
        ActionVariable DeleteRepoVariable(string owner, string repo, string variablename, int operationIndex = 0);

        /// <summary>
        /// Delete a repo-level variable
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="variablename">name of the variable</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ActionVariable</returns>
        ApiResponse<ActionVariable> DeleteRepoVariableWithHttpInfo(string owner, string repo, string variablename, int operationIndex = 0);
        /// <summary>
        /// Create a repository using a template
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="templateOwner">name of the template repository owner</param>
        /// <param name="templateRepo">name of the template repository</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Repository</returns>
        Repository GenerateRepo(string templateOwner, string templateRepo, GenerateRepoOption? body = default(GenerateRepoOption?), int operationIndex = 0);

        /// <summary>
        /// Create a repository using a template
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="templateOwner">name of the template repository owner</param>
        /// <param name="templateRepo">name of the template repository</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Repository</returns>
        ApiResponse<Repository> GenerateRepoWithHttpInfo(string templateOwner, string templateRepo, GenerateRepoOption? body = default(GenerateRepoOption?), int operationIndex = 0);
        /// <summary>
        /// Gets the tag object of an annotated tag (not lightweight tags)
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>AnnotatedTag</returns>
        AnnotatedTag GetAnnotatedTag(string owner, string repo, string sha, int operationIndex = 0);

        /// <summary>
        /// Gets the tag object of an annotated tag (not lightweight tags)
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of AnnotatedTag</returns>
        ApiResponse<AnnotatedTag> GetAnnotatedTagWithHttpInfo(string owner, string repo, string sha, int operationIndex = 0);
        /// <summary>
        /// Gets the blob of a repository.
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the commit</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>GitBlobResponse</returns>
        GitBlobResponse GetBlob(string owner, string repo, string sha, int operationIndex = 0);

        /// <summary>
        /// Gets the blob of a repository.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the commit</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of GitBlobResponse</returns>
        ApiResponse<GitBlobResponse> GetBlobWithHttpInfo(string owner, string repo, string sha, int operationIndex = 0);
        /// <summary>
        /// Get a repo-level variable
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="variablename">name of the variable</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ActionVariable</returns>
        ActionVariable GetRepoVariable(string owner, string repo, string variablename, int operationIndex = 0);

        /// <summary>
        /// Get a repo-level variable
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="variablename">name of the variable</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ActionVariable</returns>
        ApiResponse<ActionVariable> GetRepoVariableWithHttpInfo(string owner, string repo, string variablename, int operationIndex = 0);
        /// <summary>
        /// Get repo-level variables list
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;ActionVariable&gt;</returns>
        List<ActionVariable> GetRepoVariablesList(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0);

        /// <summary>
        /// Get repo-level variables list
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;ActionVariable&gt;</returns>
        ApiResponse<List<ActionVariable>> GetRepoVariablesListWithHttpInfo(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0);
        /// <summary>
        /// Gets the tree of a repository.
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the commit</param>
        /// <param name="recursive">show all directories and files (optional)</param>
        /// <param name="page">page number; the &#39;truncated&#39; field in the response will be true if there are still more items after this page, false if the last page (optional)</param>
        /// <param name="perPage">number of items per page (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>GitTreeResponse</returns>
        GitTreeResponse GetTree(string owner, string repo, string sha, bool? recursive = default(bool?), int? page = default(int?), int? perPage = default(int?), int operationIndex = 0);

        /// <summary>
        /// Gets the tree of a repository.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the commit</param>
        /// <param name="recursive">show all directories and files (optional)</param>
        /// <param name="page">page number; the &#39;truncated&#39; field in the response will be true if there are still more items after this page, false if the last page (optional)</param>
        /// <param name="perPage">number of items per page (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of GitTreeResponse</returns>
        ApiResponse<GitTreeResponse> GetTreeWithHttpInfo(string owner, string repo, string sha, bool? recursive = default(bool?), int? page = default(int?), int? perPage = default(int?), int operationIndex = 0);
        /// <summary>
        /// List a repository&#39;s forks
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;Repository&gt;</returns>
        List<Repository> ListForks(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0);

        /// <summary>
        /// List a repository&#39;s forks
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;Repository&gt;</returns>
        ApiResponse<List<Repository>> ListForksWithHttpInfo(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0);
        /// <summary>
        /// Reject a repo transfer
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to transfer</param>
        /// <param name="repo">name of the repo to transfer</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Repository</returns>
        Repository RejectRepoTransfer(string owner, string repo, int operationIndex = 0);

        /// <summary>
        /// Reject a repo transfer
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to transfer</param>
        /// <param name="repo">name of the repo to transfer</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Repository</returns>
        ApiResponse<Repository> RejectRepoTransferWithHttpInfo(string owner, string repo, int operationIndex = 0);
        /// <summary>
        /// Add a collaborator to a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="collaborator">username of the collaborator to add</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RepoAddCollaborator(string owner, string repo, string collaborator, AddCollaboratorOption? body = default(AddCollaboratorOption?), int operationIndex = 0);

        /// <summary>
        /// Add a collaborator to a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="collaborator">username of the collaborator to add</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RepoAddCollaboratorWithHttpInfo(string owner, string repo, string collaborator, AddCollaboratorOption? body = default(AddCollaboratorOption?), int operationIndex = 0);
        /// <summary>
        /// add a push mirror to the repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PushMirror</returns>
        PushMirror RepoAddPushMirror(string owner, string repo, CreatePushMirrorOption? body = default(CreatePushMirrorOption?), int operationIndex = 0);

        /// <summary>
        /// add a push mirror to the repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PushMirror</returns>
        ApiResponse<PushMirror> RepoAddPushMirrorWithHttpInfo(string owner, string repo, CreatePushMirrorOption? body = default(CreatePushMirrorOption?), int operationIndex = 0);
        /// <summary>
        /// Add a team to a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="team">team name</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RepoAddTeam(string owner, string repo, string team, int operationIndex = 0);

        /// <summary>
        /// Add a team to a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="team">team name</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RepoAddTeamWithHttpInfo(string owner, string repo, string team, int operationIndex = 0);
        /// <summary>
        /// Add a topic to a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="topic">name of the topic to add</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RepoAddTopic(string owner, string repo, string topic, int operationIndex = 0);

        /// <summary>
        /// Add a topic to a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="topic">name of the topic to add</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RepoAddTopicWithHttpInfo(string owner, string repo, string topic, int operationIndex = 0);
        /// <summary>
        /// Apply diff patch to repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>FileResponse</returns>
        FileResponse RepoApplyDiffPatch(string owner, string repo, UpdateFileOptions body, int operationIndex = 0);

        /// <summary>
        /// Apply diff patch to repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of FileResponse</returns>
        ApiResponse<FileResponse> RepoApplyDiffPatchWithHttpInfo(string owner, string repo, UpdateFileOptions body, int operationIndex = 0);
        /// <summary>
        /// Cancel the scheduled auto merge for the given pull request
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to merge</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RepoCancelScheduledAutoMerge(string owner, string repo, long index, int operationIndex = 0);

        /// <summary>
        /// Cancel the scheduled auto merge for the given pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to merge</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RepoCancelScheduledAutoMergeWithHttpInfo(string owner, string repo, long index, int operationIndex = 0);
        /// <summary>
        /// Modify multiple files in a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>FilesResponse</returns>
        FilesResponse RepoChangeFiles(string owner, string repo, ChangeFilesOptions body, int operationIndex = 0);

        /// <summary>
        /// Modify multiple files in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of FilesResponse</returns>
        ApiResponse<FilesResponse> RepoChangeFilesWithHttpInfo(string owner, string repo, ChangeFilesOptions body, int operationIndex = 0);
        /// <summary>
        /// Check if a user is a collaborator of a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="collaborator">username of the collaborator</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RepoCheckCollaborator(string owner, string repo, string collaborator, int operationIndex = 0);

        /// <summary>
        /// Check if a user is a collaborator of a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="collaborator">username of the collaborator</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RepoCheckCollaboratorWithHttpInfo(string owner, string repo, string collaborator, int operationIndex = 0);
        /// <summary>
        /// Check if a team is assigned to a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="team">team name</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Team</returns>
        Team RepoCheckTeam(string owner, string repo, string team, int operationIndex = 0);

        /// <summary>
        /// Check if a team is assigned to a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="team">team name</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Team</returns>
        ApiResponse<Team> RepoCheckTeamWithHttpInfo(string owner, string repo, string team, int operationIndex = 0);
        /// <summary>
        /// Get commit comparison information
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="basehead">compare two branches or commits</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Compare</returns>
        Compare RepoCompareDiff(string owner, string repo, string basehead, int operationIndex = 0);

        /// <summary>
        /// Get commit comparison information
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="basehead">compare two branches or commits</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Compare</returns>
        ApiResponse<Compare> RepoCompareDiffWithHttpInfo(string owner, string repo, string basehead, int operationIndex = 0);
        /// <summary>
        /// Create a branch
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Branch</returns>
        Branch RepoCreateBranch(string owner, string repo, CreateBranchRepoOption? body = default(CreateBranchRepoOption?), int operationIndex = 0);

        /// <summary>
        /// Create a branch
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Branch</returns>
        ApiResponse<Branch> RepoCreateBranchWithHttpInfo(string owner, string repo, CreateBranchRepoOption? body = default(CreateBranchRepoOption?), int operationIndex = 0);
        /// <summary>
        /// Create a branch protections for a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>BranchProtection</returns>
        BranchProtection RepoCreateBranchProtection(string owner, string repo, CreateBranchProtectionOption? body = default(CreateBranchProtectionOption?), int operationIndex = 0);

        /// <summary>
        /// Create a branch protections for a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of BranchProtection</returns>
        ApiResponse<BranchProtection> RepoCreateBranchProtectionWithHttpInfo(string owner, string repo, CreateBranchProtectionOption? body = default(CreateBranchProtectionOption?), int operationIndex = 0);
        /// <summary>
        /// Create a file in a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">path of the file to create</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>FileResponse</returns>
        FileResponse RepoCreateFile(string owner, string repo, string filepath, CreateFileOptions body, int operationIndex = 0);

        /// <summary>
        /// Create a file in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">path of the file to create</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of FileResponse</returns>
        ApiResponse<FileResponse> RepoCreateFileWithHttpInfo(string owner, string repo, string filepath, CreateFileOptions body, int operationIndex = 0);
        /// <summary>
        /// Create a hook
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Hook</returns>
        Hook RepoCreateHook(string owner, string repo, CreateHookOption? body = default(CreateHookOption?), int operationIndex = 0);

        /// <summary>
        /// Create a hook
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Hook</returns>
        ApiResponse<Hook> RepoCreateHookWithHttpInfo(string owner, string repo, CreateHookOption? body = default(CreateHookOption?), int operationIndex = 0);
        /// <summary>
        /// Add a key to a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>DeployKey</returns>
        DeployKey RepoCreateKey(string owner, string repo, CreateKeyOption? body = default(CreateKeyOption?), int operationIndex = 0);

        /// <summary>
        /// Add a key to a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of DeployKey</returns>
        ApiResponse<DeployKey> RepoCreateKeyWithHttpInfo(string owner, string repo, CreateKeyOption? body = default(CreateKeyOption?), int operationIndex = 0);
        /// <summary>
        /// Create a pull request
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PullRequest</returns>
        PullRequest RepoCreatePullRequest(string owner, string repo, CreatePullRequestOption? body = default(CreatePullRequestOption?), int operationIndex = 0);

        /// <summary>
        /// Create a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PullRequest</returns>
        ApiResponse<PullRequest> RepoCreatePullRequestWithHttpInfo(string owner, string repo, CreatePullRequestOption? body = default(CreatePullRequestOption?), int operationIndex = 0);
        /// <summary>
        /// Create a review to an pull request
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PullReview</returns>
        PullReview RepoCreatePullReview(string owner, string repo, long index, CreatePullReviewOptions body, int operationIndex = 0);

        /// <summary>
        /// Create a review to an pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PullReview</returns>
        ApiResponse<PullReview> RepoCreatePullReviewWithHttpInfo(string owner, string repo, long index, CreatePullReviewOptions body, int operationIndex = 0);
        /// <summary>
        /// create review requests for a pull request
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;PullReview&gt;</returns>
        List<PullReview> RepoCreatePullReviewRequests(string owner, string repo, long index, PullReviewRequestOptions body, int operationIndex = 0);

        /// <summary>
        /// create review requests for a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;PullReview&gt;</returns>
        ApiResponse<List<PullReview>> RepoCreatePullReviewRequestsWithHttpInfo(string owner, string repo, long index, PullReviewRequestOptions body, int operationIndex = 0);
        /// <summary>
        /// Create a release
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Release</returns>
        Release RepoCreateRelease(string owner, string repo, CreateReleaseOption? body = default(CreateReleaseOption?), int operationIndex = 0);

        /// <summary>
        /// Create a release
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Release</returns>
        ApiResponse<Release> RepoCreateReleaseWithHttpInfo(string owner, string repo, CreateReleaseOption? body = default(CreateReleaseOption?), int operationIndex = 0);
        /// <summary>
        /// Create a release attachment
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="name">name of the attachment (optional)</param>
        /// <param name="attachment">attachment to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Attachment</returns>
        Attachment RepoCreateReleaseAttachment(string owner, string repo, long id, string? name = default(string?), System.IO.Stream? attachment = default(System.IO.Stream?), int operationIndex = 0);

        /// <summary>
        /// Create a release attachment
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="name">name of the attachment (optional)</param>
        /// <param name="attachment">attachment to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Attachment</returns>
        ApiResponse<Attachment> RepoCreateReleaseAttachmentWithHttpInfo(string owner, string repo, long id, string? name = default(string?), System.IO.Stream? attachment = default(System.IO.Stream?), int operationIndex = 0);
        /// <summary>
        /// Create a commit status
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the commit</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>CommitStatus</returns>
        CommitStatus RepoCreateStatus(string owner, string repo, string sha, CreateStatusOption? body = default(CreateStatusOption?), int operationIndex = 0);

        /// <summary>
        /// Create a commit status
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the commit</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of CommitStatus</returns>
        ApiResponse<CommitStatus> RepoCreateStatusWithHttpInfo(string owner, string repo, string sha, CreateStatusOption? body = default(CreateStatusOption?), int operationIndex = 0);
        /// <summary>
        /// Create a new git tag in a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Tag</returns>
        Tag RepoCreateTag(string owner, string repo, CreateTagOption? body = default(CreateTagOption?), int operationIndex = 0);

        /// <summary>
        /// Create a new git tag in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Tag</returns>
        ApiResponse<Tag> RepoCreateTagWithHttpInfo(string owner, string repo, CreateTagOption? body = default(CreateTagOption?), int operationIndex = 0);
        /// <summary>
        /// Create a wiki page
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>WikiPage</returns>
        WikiPage RepoCreateWikiPage(string owner, string repo, CreateWikiPageOptions? body = default(CreateWikiPageOptions?), int operationIndex = 0);

        /// <summary>
        /// Create a wiki page
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of WikiPage</returns>
        ApiResponse<WikiPage> RepoCreateWikiPageWithHttpInfo(string owner, string repo, CreateWikiPageOptions? body = default(CreateWikiPageOptions?), int operationIndex = 0);
        /// <summary>
        /// Delete a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to delete</param>
        /// <param name="repo">name of the repo to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RepoDelete(string owner, string repo, int operationIndex = 0);

        /// <summary>
        /// Delete a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to delete</param>
        /// <param name="repo">name of the repo to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RepoDeleteWithHttpInfo(string owner, string repo, int operationIndex = 0);
        /// <summary>
        /// Delete avatar
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RepoDeleteAvatar(string owner, string repo, int operationIndex = 0);

        /// <summary>
        /// Delete avatar
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RepoDeleteAvatarWithHttpInfo(string owner, string repo, int operationIndex = 0);
        /// <summary>
        /// Delete a specific branch from a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="branch">branch to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RepoDeleteBranch(string owner, string repo, string branch, int operationIndex = 0);

        /// <summary>
        /// Delete a specific branch from a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="branch">branch to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RepoDeleteBranchWithHttpInfo(string owner, string repo, string branch, int operationIndex = 0);
        /// <summary>
        /// Delete a specific branch protection for the repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">name of protected branch</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RepoDeleteBranchProtection(string owner, string repo, string name, int operationIndex = 0);

        /// <summary>
        /// Delete a specific branch protection for the repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">name of protected branch</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RepoDeleteBranchProtectionWithHttpInfo(string owner, string repo, string name, int operationIndex = 0);
        /// <summary>
        /// Delete a collaborator from a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="collaborator">username of the collaborator to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RepoDeleteCollaborator(string owner, string repo, string collaborator, int operationIndex = 0);

        /// <summary>
        /// Delete a collaborator from a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="collaborator">username of the collaborator to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RepoDeleteCollaboratorWithHttpInfo(string owner, string repo, string collaborator, int operationIndex = 0);
        /// <summary>
        /// Delete a file in a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">path of the file to delete</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>FileDeleteResponse</returns>
        FileDeleteResponse RepoDeleteFile(string owner, string repo, string filepath, DeleteFileOptions body, int operationIndex = 0);

        /// <summary>
        /// Delete a file in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">path of the file to delete</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of FileDeleteResponse</returns>
        ApiResponse<FileDeleteResponse> RepoDeleteFileWithHttpInfo(string owner, string repo, string filepath, DeleteFileOptions body, int operationIndex = 0);
        /// <summary>
        /// Delete a Git hook in a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RepoDeleteGitHook(string owner, string repo, string id, int operationIndex = 0);

        /// <summary>
        /// Delete a Git hook in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RepoDeleteGitHookWithHttpInfo(string owner, string repo, string id, int operationIndex = 0);
        /// <summary>
        /// Delete a hook in a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RepoDeleteHook(string owner, string repo, long id, int operationIndex = 0);

        /// <summary>
        /// Delete a hook in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RepoDeleteHookWithHttpInfo(string owner, string repo, long id, int operationIndex = 0);
        /// <summary>
        /// Delete a key from a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the key to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RepoDeleteKey(string owner, string repo, long id, int operationIndex = 0);

        /// <summary>
        /// Delete a key from a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the key to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RepoDeleteKeyWithHttpInfo(string owner, string repo, long id, int operationIndex = 0);
        /// <summary>
        /// Delete a specific review from a pull request
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RepoDeletePullReview(string owner, string repo, long index, long id, int operationIndex = 0);

        /// <summary>
        /// Delete a specific review from a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RepoDeletePullReviewWithHttpInfo(string owner, string repo, long index, long id, int operationIndex = 0);
        /// <summary>
        /// cancel review requests for a pull request
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RepoDeletePullReviewRequests(string owner, string repo, long index, PullReviewRequestOptions body, int operationIndex = 0);

        /// <summary>
        /// cancel review requests for a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RepoDeletePullReviewRequestsWithHttpInfo(string owner, string repo, long index, PullReviewRequestOptions body, int operationIndex = 0);
        /// <summary>
        /// deletes a push mirror from a repository by remoteName
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">remote name of the pushMirror</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RepoDeletePushMirror(string owner, string repo, string name, int operationIndex = 0);

        /// <summary>
        /// deletes a push mirror from a repository by remoteName
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">remote name of the pushMirror</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RepoDeletePushMirrorWithHttpInfo(string owner, string repo, string name, int operationIndex = 0);
        /// <summary>
        /// Delete a release
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RepoDeleteRelease(string owner, string repo, long id, int operationIndex = 0);

        /// <summary>
        /// Delete a release
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RepoDeleteReleaseWithHttpInfo(string owner, string repo, long id, int operationIndex = 0);
        /// <summary>
        /// Delete a release attachment
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="attachmentId">id of the attachment to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RepoDeleteReleaseAttachment(string owner, string repo, long id, long attachmentId, int operationIndex = 0);

        /// <summary>
        /// Delete a release attachment
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="attachmentId">id of the attachment to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RepoDeleteReleaseAttachmentWithHttpInfo(string owner, string repo, long id, long attachmentId, int operationIndex = 0);
        /// <summary>
        /// Delete a release by tag name
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="tag">tag name of the release to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RepoDeleteReleaseByTag(string owner, string repo, string tag, int operationIndex = 0);

        /// <summary>
        /// Delete a release by tag name
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="tag">tag name of the release to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RepoDeleteReleaseByTagWithHttpInfo(string owner, string repo, string tag, int operationIndex = 0);
        /// <summary>
        /// Delete a repository&#39;s tag by name
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="tag">name of tag to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RepoDeleteTag(string owner, string repo, string tag, int operationIndex = 0);

        /// <summary>
        /// Delete a repository&#39;s tag by name
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="tag">name of tag to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RepoDeleteTagWithHttpInfo(string owner, string repo, string tag, int operationIndex = 0);
        /// <summary>
        /// Delete a team from a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="team">team name</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RepoDeleteTeam(string owner, string repo, string team, int operationIndex = 0);

        /// <summary>
        /// Delete a team from a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="team">team name</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RepoDeleteTeamWithHttpInfo(string owner, string repo, string team, int operationIndex = 0);
        /// <summary>
        /// Delete a topic from a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="topic">name of the topic to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RepoDeleteTopic(string owner, string repo, string topic, int operationIndex = 0);

        /// <summary>
        /// Delete a topic from a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="topic">name of the topic to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RepoDeleteTopicWithHttpInfo(string owner, string repo, string topic, int operationIndex = 0);
        /// <summary>
        /// Delete a wiki page
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="pageName">name of the page</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RepoDeleteWikiPage(string owner, string repo, string pageName, int operationIndex = 0);

        /// <summary>
        /// Delete a wiki page
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="pageName">name of the page</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RepoDeleteWikiPageWithHttpInfo(string owner, string repo, string pageName, int operationIndex = 0);
        /// <summary>
        /// Dismiss a review for a pull request
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PullReview</returns>
        PullReview RepoDismissPullReview(string owner, string repo, long index, long id, DismissPullReviewOptions body, int operationIndex = 0);

        /// <summary>
        /// Dismiss a review for a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PullReview</returns>
        ApiResponse<PullReview> RepoDismissPullReviewWithHttpInfo(string owner, string repo, long index, long id, DismissPullReviewOptions body, int operationIndex = 0);
        /// <summary>
        /// Get a commit&#39;s diff or patch
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">SHA of the commit to get</param>
        /// <param name="diffType">whether the output is diff or patch</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>string</returns>
        string RepoDownloadCommitDiffOrPatch(string owner, string repo, string sha, string diffType, int operationIndex = 0);

        /// <summary>
        /// Get a commit&#39;s diff or patch
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">SHA of the commit to get</param>
        /// <param name="diffType">whether the output is diff or patch</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> RepoDownloadCommitDiffOrPatchWithHttpInfo(string owner, string repo, string sha, string diffType, int operationIndex = 0);
        /// <summary>
        /// Get a pull request diff or patch
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="diffType">whether the output is diff or patch</param>
        /// <param name="binary">whether to include binary file changes. if true, the diff is applicable with &#x60;git apply&#x60; (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>string</returns>
        string RepoDownloadPullDiffOrPatch(string owner, string repo, long index, string diffType, bool? binary = default(bool?), int operationIndex = 0);

        /// <summary>
        /// Get a pull request diff or patch
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="diffType">whether the output is diff or patch</param>
        /// <param name="binary">whether to include binary file changes. if true, the diff is applicable with &#x60;git apply&#x60; (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> RepoDownloadPullDiffOrPatchWithHttpInfo(string owner, string repo, long index, string diffType, bool? binary = default(bool?), int operationIndex = 0);
        /// <summary>
        /// Edit a repository&#39;s properties. Only fields that are set will be changed.
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to edit</param>
        /// <param name="repo">name of the repo to edit</param>
        /// <param name="body">Properties of a repo that you can edit (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Repository</returns>
        Repository RepoEdit(string owner, string repo, EditRepoOption? body = default(EditRepoOption?), int operationIndex = 0);

        /// <summary>
        /// Edit a repository&#39;s properties. Only fields that are set will be changed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to edit</param>
        /// <param name="repo">name of the repo to edit</param>
        /// <param name="body">Properties of a repo that you can edit (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Repository</returns>
        ApiResponse<Repository> RepoEditWithHttpInfo(string owner, string repo, EditRepoOption? body = default(EditRepoOption?), int operationIndex = 0);
        /// <summary>
        /// Edit a branch protections for a repository. Only fields that are set will be changed
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">name of protected branch</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>BranchProtection</returns>
        BranchProtection RepoEditBranchProtection(string owner, string repo, string name, EditBranchProtectionOption? body = default(EditBranchProtectionOption?), int operationIndex = 0);

        /// <summary>
        /// Edit a branch protections for a repository. Only fields that are set will be changed
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">name of protected branch</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of BranchProtection</returns>
        ApiResponse<BranchProtection> RepoEditBranchProtectionWithHttpInfo(string owner, string repo, string name, EditBranchProtectionOption? body = default(EditBranchProtectionOption?), int operationIndex = 0);
        /// <summary>
        /// Edit a Git hook in a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to get</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>GitHook</returns>
        GitHook RepoEditGitHook(string owner, string repo, string id, EditGitHookOption? body = default(EditGitHookOption?), int operationIndex = 0);

        /// <summary>
        /// Edit a Git hook in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to get</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of GitHook</returns>
        ApiResponse<GitHook> RepoEditGitHookWithHttpInfo(string owner, string repo, string id, EditGitHookOption? body = default(EditGitHookOption?), int operationIndex = 0);
        /// <summary>
        /// Edit a hook in a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">index of the hook</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Hook</returns>
        Hook RepoEditHook(string owner, string repo, long id, EditHookOption? body = default(EditHookOption?), int operationIndex = 0);

        /// <summary>
        /// Edit a hook in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">index of the hook</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Hook</returns>
        ApiResponse<Hook> RepoEditHookWithHttpInfo(string owner, string repo, long id, EditHookOption? body = default(EditHookOption?), int operationIndex = 0);
        /// <summary>
        /// Update a pull request. If using deadline only the date will be taken into account, and time of day ignored.
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to edit</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PullRequest</returns>
        PullRequest RepoEditPullRequest(string owner, string repo, long index, EditPullRequestOption? body = default(EditPullRequestOption?), int operationIndex = 0);

        /// <summary>
        /// Update a pull request. If using deadline only the date will be taken into account, and time of day ignored.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to edit</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PullRequest</returns>
        ApiResponse<PullRequest> RepoEditPullRequestWithHttpInfo(string owner, string repo, long index, EditPullRequestOption? body = default(EditPullRequestOption?), int operationIndex = 0);
        /// <summary>
        /// Update a release
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release to edit</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Release</returns>
        Release RepoEditRelease(string owner, string repo, long id, EditReleaseOption? body = default(EditReleaseOption?), int operationIndex = 0);

        /// <summary>
        /// Update a release
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release to edit</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Release</returns>
        ApiResponse<Release> RepoEditReleaseWithHttpInfo(string owner, string repo, long id, EditReleaseOption? body = default(EditReleaseOption?), int operationIndex = 0);
        /// <summary>
        /// Edit a release attachment
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="attachmentId">id of the attachment to edit</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Attachment</returns>
        Attachment RepoEditReleaseAttachment(string owner, string repo, long id, long attachmentId, EditAttachmentOptions? body = default(EditAttachmentOptions?), int operationIndex = 0);

        /// <summary>
        /// Edit a release attachment
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="attachmentId">id of the attachment to edit</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Attachment</returns>
        ApiResponse<Attachment> RepoEditReleaseAttachmentWithHttpInfo(string owner, string repo, long id, long attachmentId, EditAttachmentOptions? body = default(EditAttachmentOptions?), int operationIndex = 0);
        /// <summary>
        /// Edit a wiki page
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="pageName">name of the page</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>WikiPage</returns>
        WikiPage RepoEditWikiPage(string owner, string repo, string pageName, CreateWikiPageOptions? body = default(CreateWikiPageOptions?), int operationIndex = 0);

        /// <summary>
        /// Edit a wiki page
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="pageName">name of the page</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of WikiPage</returns>
        ApiResponse<WikiPage> RepoEditWikiPageWithHttpInfo(string owner, string repo, string pageName, CreateWikiPageOptions? body = default(CreateWikiPageOptions?), int operationIndex = 0);
        /// <summary>
        /// Get a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Repository</returns>
        Repository RepoGet(string owner, string repo, int operationIndex = 0);

        /// <summary>
        /// Get a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Repository</returns>
        ApiResponse<Repository> RepoGetWithHttpInfo(string owner, string repo, int operationIndex = 0);
        /// <summary>
        /// Get a list of all commits from a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">SHA or branch to start listing commits from (usually &#39;master&#39;) (optional)</param>
        /// <param name="path">filepath of a file/dir (optional)</param>
        /// <param name="stat">include diff stats for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="verification">include verification for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="files">include a list of affected files for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (ignored if used with &#39;path&#39;) (optional)</param>
        /// <param name="not">commits that match the given specifier will not be listed. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;Commit&gt;</returns>
        List<Commit> RepoGetAllCommits(string owner, string repo, string? sha = default(string?), string? path = default(string?), bool? stat = default(bool?), bool? verification = default(bool?), bool? files = default(bool?), int? page = default(int?), int? limit = default(int?), string? not = default(string?), int operationIndex = 0);

        /// <summary>
        /// Get a list of all commits from a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">SHA or branch to start listing commits from (usually &#39;master&#39;) (optional)</param>
        /// <param name="path">filepath of a file/dir (optional)</param>
        /// <param name="stat">include diff stats for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="verification">include verification for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="files">include a list of affected files for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (ignored if used with &#39;path&#39;) (optional)</param>
        /// <param name="not">commits that match the given specifier will not be listed. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;Commit&gt;</returns>
        ApiResponse<List<Commit>> RepoGetAllCommitsWithHttpInfo(string owner, string repo, string? sha = default(string?), string? path = default(string?), bool? stat = default(bool?), bool? verification = default(bool?), bool? files = default(bool?), int? page = default(int?), int? limit = default(int?), string? not = default(string?), int operationIndex = 0);
        /// <summary>
        /// Get an archive of a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="archive">the git reference for download with attached archive format (e.g. master.zip)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RepoGetArchive(string owner, string repo, string archive, int operationIndex = 0);

        /// <summary>
        /// Get an archive of a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="archive">the git reference for download with attached archive format (e.g. master.zip)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RepoGetArchiveWithHttpInfo(string owner, string repo, string archive, int operationIndex = 0);
        /// <summary>
        /// Return all users that have write access and can be assigned to issues
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;User&gt;</returns>
        List<User> RepoGetAssignees(string owner, string repo, int operationIndex = 0);

        /// <summary>
        /// Return all users that have write access and can be assigned to issues
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;User&gt;</returns>
        ApiResponse<List<User>> RepoGetAssigneesWithHttpInfo(string owner, string repo, int operationIndex = 0);
        /// <summary>
        /// Retrieve a specific branch from a repository, including its effective branch protection
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="branch">branch to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Branch</returns>
        Branch RepoGetBranch(string owner, string repo, string branch, int operationIndex = 0);

        /// <summary>
        /// Retrieve a specific branch from a repository, including its effective branch protection
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="branch">branch to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Branch</returns>
        ApiResponse<Branch> RepoGetBranchWithHttpInfo(string owner, string repo, string branch, int operationIndex = 0);
        /// <summary>
        /// Get a specific branch protection for the repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">name of protected branch</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>BranchProtection</returns>
        BranchProtection RepoGetBranchProtection(string owner, string repo, string name, int operationIndex = 0);

        /// <summary>
        /// Get a specific branch protection for the repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">name of protected branch</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of BranchProtection</returns>
        ApiResponse<BranchProtection> RepoGetBranchProtectionWithHttpInfo(string owner, string repo, string name, int operationIndex = 0);
        /// <summary>
        /// Get a repository by id
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">id of the repo to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Repository</returns>
        Repository RepoGetByID(long id, int operationIndex = 0);

        /// <summary>
        /// Get a repository by id
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">id of the repo to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Repository</returns>
        ApiResponse<Repository> RepoGetByIDWithHttpInfo(long id, int operationIndex = 0);
        /// <summary>
        /// Get a commit&#39;s combined status, by branch/tag/commit reference
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varRef">name of branch/tag/commit</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>CombinedStatus</returns>
        CombinedStatus RepoGetCombinedStatusByRef(string owner, string repo, string varRef, int? page = default(int?), int? limit = default(int?), int operationIndex = 0);

        /// <summary>
        /// Get a commit&#39;s combined status, by branch/tag/commit reference
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varRef">name of branch/tag/commit</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of CombinedStatus</returns>
        ApiResponse<CombinedStatus> RepoGetCombinedStatusByRefWithHttpInfo(string owner, string repo, string varRef, int? page = default(int?), int? limit = default(int?), int operationIndex = 0);
        /// <summary>
        /// Get the pull request of the commit
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">SHA of the commit to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PullRequest</returns>
        PullRequest RepoGetCommitPullRequest(string owner, string repo, string sha, int operationIndex = 0);

        /// <summary>
        /// Get the pull request of the commit
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">SHA of the commit to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PullRequest</returns>
        ApiResponse<PullRequest> RepoGetCommitPullRequestWithHttpInfo(string owner, string repo, string sha, int operationIndex = 0);
        /// <summary>
        /// Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">path of the dir, file, symlink or submodule in the repo</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ContentsResponse</returns>
        ContentsResponse RepoGetContents(string owner, string repo, string filepath, string? varRef = default(string?), int operationIndex = 0);

        /// <summary>
        /// Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">path of the dir, file, symlink or submodule in the repo</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ContentsResponse</returns>
        ApiResponse<ContentsResponse> RepoGetContentsWithHttpInfo(string owner, string repo, string filepath, string? varRef = default(string?), int operationIndex = 0);
        /// <summary>
        /// Gets the metadata of all the entries of the root dir
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;ContentsResponse&gt;</returns>
        List<ContentsResponse> RepoGetContentsList(string owner, string repo, string? varRef = default(string?), int operationIndex = 0);

        /// <summary>
        /// Gets the metadata of all the entries of the root dir
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;ContentsResponse&gt;</returns>
        ApiResponse<List<ContentsResponse>> RepoGetContentsListWithHttpInfo(string owner, string repo, string? varRef = default(string?), int operationIndex = 0);
        /// <summary>
        /// Get the EditorConfig definitions of a file in a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">filepath of file to get</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RepoGetEditorConfig(string owner, string repo, string filepath, string? varRef = default(string?), int operationIndex = 0);

        /// <summary>
        /// Get the EditorConfig definitions of a file in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">filepath of file to get</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RepoGetEditorConfigWithHttpInfo(string owner, string repo, string filepath, string? varRef = default(string?), int operationIndex = 0);
        /// <summary>
        /// Get a Git hook
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>GitHook</returns>
        GitHook RepoGetGitHook(string owner, string repo, string id, int operationIndex = 0);

        /// <summary>
        /// Get a Git hook
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of GitHook</returns>
        ApiResponse<GitHook> RepoGetGitHookWithHttpInfo(string owner, string repo, string id, int operationIndex = 0);
        /// <summary>
        /// Get a hook
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Hook</returns>
        Hook RepoGetHook(string owner, string repo, long id, int operationIndex = 0);

        /// <summary>
        /// Get a hook
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Hook</returns>
        ApiResponse<Hook> RepoGetHookWithHttpInfo(string owner, string repo, long id, int operationIndex = 0);
        /// <summary>
        /// Returns the issue config for a repo
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>IssueConfig</returns>
        IssueConfig RepoGetIssueConfig(string owner, string repo, int operationIndex = 0);

        /// <summary>
        /// Returns the issue config for a repo
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of IssueConfig</returns>
        ApiResponse<IssueConfig> RepoGetIssueConfigWithHttpInfo(string owner, string repo, int operationIndex = 0);
        /// <summary>
        /// Get available issue templates for a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;IssueTemplate&gt;</returns>
        List<IssueTemplate> RepoGetIssueTemplates(string owner, string repo, int operationIndex = 0);

        /// <summary>
        /// Get available issue templates for a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;IssueTemplate&gt;</returns>
        ApiResponse<List<IssueTemplate>> RepoGetIssueTemplatesWithHttpInfo(string owner, string repo, int operationIndex = 0);
        /// <summary>
        /// Get a repository&#39;s key by id
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the key to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>DeployKey</returns>
        DeployKey RepoGetKey(string owner, string repo, long id, int operationIndex = 0);

        /// <summary>
        /// Get a repository&#39;s key by id
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the key to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of DeployKey</returns>
        ApiResponse<DeployKey> RepoGetKeyWithHttpInfo(string owner, string repo, long id, int operationIndex = 0);
        /// <summary>
        /// Get languages and number of bytes of code written
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Dictionary&lt;string, long&gt;</returns>
        Dictionary<string, long> RepoGetLanguages(string owner, string repo, int operationIndex = 0);

        /// <summary>
        /// Get languages and number of bytes of code written
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Dictionary&lt;string, long&gt;</returns>
        ApiResponse<Dictionary<string, long>> RepoGetLanguagesWithHttpInfo(string owner, string repo, int operationIndex = 0);
        /// <summary>
        /// Gets the most recent non-prerelease, non-draft release of a repository, sorted by created_at
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Release</returns>
        Release RepoGetLatestRelease(string owner, string repo, int operationIndex = 0);

        /// <summary>
        /// Gets the most recent non-prerelease, non-draft release of a repository, sorted by created_at
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Release</returns>
        ApiResponse<Release> RepoGetLatestReleaseWithHttpInfo(string owner, string repo, int operationIndex = 0);
        /// <summary>
        /// Get a note corresponding to a single commit from a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">a git ref or commit sha</param>
        /// <param name="verification">include verification for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="files">include a list of affected files for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Note</returns>
        Note RepoGetNote(string owner, string repo, string sha, bool? verification = default(bool?), bool? files = default(bool?), int operationIndex = 0);

        /// <summary>
        /// Get a note corresponding to a single commit from a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">a git ref or commit sha</param>
        /// <param name="verification">include verification for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="files">include a list of affected files for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Note</returns>
        ApiResponse<Note> RepoGetNoteWithHttpInfo(string owner, string repo, string sha, bool? verification = default(bool?), bool? files = default(bool?), int operationIndex = 0);
        /// <summary>
        /// Get a pull request
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PullRequest</returns>
        PullRequest RepoGetPullRequest(string owner, string repo, long index, int operationIndex = 0);

        /// <summary>
        /// Get a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PullRequest</returns>
        ApiResponse<PullRequest> RepoGetPullRequestWithHttpInfo(string owner, string repo, long index, int operationIndex = 0);
        /// <summary>
        /// Get a pull request by base and head
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varBase">base of the pull request to get</param>
        /// <param name="head">head of the pull request to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PullRequest</returns>
        PullRequest RepoGetPullRequestByBaseHead(string owner, string repo, string varBase, string head, int operationIndex = 0);

        /// <summary>
        /// Get a pull request by base and head
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varBase">base of the pull request to get</param>
        /// <param name="head">head of the pull request to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PullRequest</returns>
        ApiResponse<PullRequest> RepoGetPullRequestByBaseHeadWithHttpInfo(string owner, string repo, string varBase, string head, int operationIndex = 0);
        /// <summary>
        /// Get commits for a pull request
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="verification">include verification for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="files">include a list of affected files for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;Commit&gt;</returns>
        List<Commit> RepoGetPullRequestCommits(string owner, string repo, long index, int? page = default(int?), int? limit = default(int?), bool? verification = default(bool?), bool? files = default(bool?), int operationIndex = 0);

        /// <summary>
        /// Get commits for a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="verification">include verification for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="files">include a list of affected files for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;Commit&gt;</returns>
        ApiResponse<List<Commit>> RepoGetPullRequestCommitsWithHttpInfo(string owner, string repo, long index, int? page = default(int?), int? limit = default(int?), bool? verification = default(bool?), bool? files = default(bool?), int operationIndex = 0);
        /// <summary>
        /// Get changed files for a pull request
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="skipTo">skip to given file (optional)</param>
        /// <param name="whitespace">whitespace behavior (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;ChangedFile&gt;</returns>
        List<ChangedFile> RepoGetPullRequestFiles(string owner, string repo, long index, string? skipTo = default(string?), string? whitespace = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0);

        /// <summary>
        /// Get changed files for a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="skipTo">skip to given file (optional)</param>
        /// <param name="whitespace">whitespace behavior (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;ChangedFile&gt;</returns>
        ApiResponse<List<ChangedFile>> RepoGetPullRequestFilesWithHttpInfo(string owner, string repo, long index, string? skipTo = default(string?), string? whitespace = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0);
        /// <summary>
        /// Get a specific review for a pull request
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PullReview</returns>
        PullReview RepoGetPullReview(string owner, string repo, long index, long id, int operationIndex = 0);

        /// <summary>
        /// Get a specific review for a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PullReview</returns>
        ApiResponse<PullReview> RepoGetPullReviewWithHttpInfo(string owner, string repo, long index, long id, int operationIndex = 0);
        /// <summary>
        /// Get a specific review for a pull request
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;PullReviewComment&gt;</returns>
        List<PullReviewComment> RepoGetPullReviewComments(string owner, string repo, long index, long id, int operationIndex = 0);

        /// <summary>
        /// Get a specific review for a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;PullReviewComment&gt;</returns>
        ApiResponse<List<PullReviewComment>> RepoGetPullReviewCommentsWithHttpInfo(string owner, string repo, long index, long id, int operationIndex = 0);
        /// <summary>
        /// Get push mirror of the repository by remoteName
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">remote name of push mirror</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PushMirror</returns>
        PushMirror RepoGetPushMirrorByRemoteName(string owner, string repo, string name, int operationIndex = 0);

        /// <summary>
        /// Get push mirror of the repository by remoteName
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">remote name of push mirror</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PushMirror</returns>
        ApiResponse<PushMirror> RepoGetPushMirrorByRemoteNameWithHttpInfo(string owner, string repo, string name, int operationIndex = 0);
        /// <summary>
        /// Get a file from a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">filepath of the file to get</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RepoGetRawFile(string owner, string repo, string filepath, string? varRef = default(string?), int operationIndex = 0);

        /// <summary>
        /// Get a file from a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">filepath of the file to get</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RepoGetRawFileWithHttpInfo(string owner, string repo, string filepath, string? varRef = default(string?), int operationIndex = 0);
        /// <summary>
        /// Get a file or it&#39;s LFS object from a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">filepath of the file to get</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RepoGetRawFileOrLFS(string owner, string repo, string filepath, string? varRef = default(string?), int operationIndex = 0);

        /// <summary>
        /// Get a file or it&#39;s LFS object from a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">filepath of the file to get</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RepoGetRawFileOrLFSWithHttpInfo(string owner, string repo, string filepath, string? varRef = default(string?), int operationIndex = 0);
        /// <summary>
        /// Get a release
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Release</returns>
        Release RepoGetRelease(string owner, string repo, long id, int operationIndex = 0);

        /// <summary>
        /// Get a release
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Release</returns>
        ApiResponse<Release> RepoGetReleaseWithHttpInfo(string owner, string repo, long id, int operationIndex = 0);
        /// <summary>
        /// Get a release attachment
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="attachmentId">id of the attachment to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Attachment</returns>
        Attachment RepoGetReleaseAttachment(string owner, string repo, long id, long attachmentId, int operationIndex = 0);

        /// <summary>
        /// Get a release attachment
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="attachmentId">id of the attachment to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Attachment</returns>
        ApiResponse<Attachment> RepoGetReleaseAttachmentWithHttpInfo(string owner, string repo, long id, long attachmentId, int operationIndex = 0);
        /// <summary>
        /// Get a release by tag name
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="tag">tag name of the release to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Release</returns>
        Release RepoGetReleaseByTag(string owner, string repo, string tag, int operationIndex = 0);

        /// <summary>
        /// Get a release by tag name
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="tag">tag name of the release to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Release</returns>
        ApiResponse<Release> RepoGetReleaseByTagWithHttpInfo(string owner, string repo, string tag, int operationIndex = 0);
        /// <summary>
        /// Get repository permissions for a user
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="collaborator">username of the collaborator</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>RepoCollaboratorPermission</returns>
        RepoCollaboratorPermission RepoGetRepoPermissions(string owner, string repo, string collaborator, int operationIndex = 0);

        /// <summary>
        /// Get repository permissions for a user
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="collaborator">username of the collaborator</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of RepoCollaboratorPermission</returns>
        ApiResponse<RepoCollaboratorPermission> RepoGetRepoPermissionsWithHttpInfo(string owner, string repo, string collaborator, int operationIndex = 0);
        /// <summary>
        /// Return all users that can be requested to review in this repo
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;User&gt;</returns>
        List<User> RepoGetReviewers(string owner, string repo, int operationIndex = 0);

        /// <summary>
        /// Return all users that can be requested to review in this repo
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;User&gt;</returns>
        ApiResponse<List<User>> RepoGetReviewersWithHttpInfo(string owner, string repo, int operationIndex = 0);
        /// <summary>
        /// Get a repository&#39;s actions runner registration token
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RepoGetRunnerRegistrationToken(string owner, string repo, int operationIndex = 0);

        /// <summary>
        /// Get a repository&#39;s actions runner registration token
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RepoGetRunnerRegistrationTokenWithHttpInfo(string owner, string repo, int operationIndex = 0);
        /// <summary>
        /// Get a single commit from a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">a git ref or commit sha</param>
        /// <param name="stat">include diff stats for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="verification">include verification for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="files">include a list of affected files for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Commit</returns>
        Commit RepoGetSingleCommit(string owner, string repo, string sha, bool? stat = default(bool?), bool? verification = default(bool?), bool? files = default(bool?), int operationIndex = 0);

        /// <summary>
        /// Get a single commit from a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">a git ref or commit sha</param>
        /// <param name="stat">include diff stats for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="verification">include verification for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="files">include a list of affected files for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Commit</returns>
        ApiResponse<Commit> RepoGetSingleCommitWithHttpInfo(string owner, string repo, string sha, bool? stat = default(bool?), bool? verification = default(bool?), bool? files = default(bool?), int operationIndex = 0);
        /// <summary>
        /// Get the tag of a repository by tag name
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="tag">name of tag</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Tag</returns>
        Tag RepoGetTag(string owner, string repo, string tag, int operationIndex = 0);

        /// <summary>
        /// Get the tag of a repository by tag name
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="tag">name of tag</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Tag</returns>
        ApiResponse<Tag> RepoGetTagWithHttpInfo(string owner, string repo, string tag, int operationIndex = 0);
        /// <summary>
        /// Get a wiki page
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="pageName">name of the page</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>WikiPage</returns>
        WikiPage RepoGetWikiPage(string owner, string repo, string pageName, int operationIndex = 0);

        /// <summary>
        /// Get a wiki page
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="pageName">name of the page</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of WikiPage</returns>
        ApiResponse<WikiPage> RepoGetWikiPageWithHttpInfo(string owner, string repo, string pageName, int operationIndex = 0);
        /// <summary>
        /// Get revisions of a wiki page
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="pageName">name of the page</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>WikiCommitList</returns>
        WikiCommitList RepoGetWikiPageRevisions(string owner, string repo, string pageName, int? page = default(int?), int operationIndex = 0);

        /// <summary>
        /// Get revisions of a wiki page
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="pageName">name of the page</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of WikiCommitList</returns>
        ApiResponse<WikiCommitList> RepoGetWikiPageRevisionsWithHttpInfo(string owner, string repo, string pageName, int? page = default(int?), int operationIndex = 0);
        /// <summary>
        /// Get all wiki pages
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;WikiPageMetaData&gt;</returns>
        List<WikiPageMetaData> RepoGetWikiPages(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0);

        /// <summary>
        /// Get all wiki pages
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;WikiPageMetaData&gt;</returns>
        ApiResponse<List<WikiPageMetaData>> RepoGetWikiPagesWithHttpInfo(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0);
        /// <summary>
        /// List an repo&#39;s actions secrets
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repository</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;Secret&gt;</returns>
        List<Secret> RepoListActionsSecrets(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0);

        /// <summary>
        /// List an repo&#39;s actions secrets
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repository</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;Secret&gt;</returns>
        ApiResponse<List<Secret>> RepoListActionsSecretsWithHttpInfo(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0);
        /// <summary>
        /// List a repository&#39;s activity feeds
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="date">the date of the activities to be found (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;Activity&gt;</returns>
        List<Activity> RepoListActivityFeeds(string owner, string repo, DateOnly? date = default(DateOnly?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0);

        /// <summary>
        /// List a repository&#39;s activity feeds
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="date">the date of the activities to be found (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;Activity&gt;</returns>
        ApiResponse<List<Activity>> RepoListActivityFeedsWithHttpInfo(string owner, string repo, DateOnly? date = default(DateOnly?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0);
        /// <summary>
        /// Get specified ref or filtered repository&#39;s refs
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;Reference&gt;</returns>
        List<Reference> RepoListAllGitRefs(string owner, string repo, int operationIndex = 0);

        /// <summary>
        /// Get specified ref or filtered repository&#39;s refs
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;Reference&gt;</returns>
        ApiResponse<List<Reference>> RepoListAllGitRefsWithHttpInfo(string owner, string repo, int operationIndex = 0);
        /// <summary>
        /// List branch protections for a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;BranchProtection&gt;</returns>
        List<BranchProtection> RepoListBranchProtection(string owner, string repo, int operationIndex = 0);

        /// <summary>
        /// List branch protections for a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;BranchProtection&gt;</returns>
        ApiResponse<List<BranchProtection>> RepoListBranchProtectionWithHttpInfo(string owner, string repo, int operationIndex = 0);
        /// <summary>
        /// List a repository&#39;s branches
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;Branch&gt;</returns>
        List<Branch> RepoListBranches(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0);

        /// <summary>
        /// List a repository&#39;s branches
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;Branch&gt;</returns>
        ApiResponse<List<Branch>> RepoListBranchesWithHttpInfo(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0);
        /// <summary>
        /// List a repository&#39;s collaborators
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;User&gt;</returns>
        List<User> RepoListCollaborators(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0);

        /// <summary>
        /// List a repository&#39;s collaborators
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;User&gt;</returns>
        ApiResponse<List<User>> RepoListCollaboratorsWithHttpInfo(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0);
        /// <summary>
        /// List the Git hooks in a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;GitHook&gt;</returns>
        List<GitHook> RepoListGitHooks(string owner, string repo, int operationIndex = 0);

        /// <summary>
        /// List the Git hooks in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;GitHook&gt;</returns>
        ApiResponse<List<GitHook>> RepoListGitHooksWithHttpInfo(string owner, string repo, int operationIndex = 0);
        /// <summary>
        /// Get specified ref or filtered repository&#39;s refs
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varRef">part or full name of the ref</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;Reference&gt;</returns>
        List<Reference> RepoListGitRefs(string owner, string repo, string varRef, int operationIndex = 0);

        /// <summary>
        /// Get specified ref or filtered repository&#39;s refs
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varRef">part or full name of the ref</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;Reference&gt;</returns>
        ApiResponse<List<Reference>> RepoListGitRefsWithHttpInfo(string owner, string repo, string varRef, int operationIndex = 0);
        /// <summary>
        /// List the hooks in a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;Hook&gt;</returns>
        List<Hook> RepoListHooks(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0);

        /// <summary>
        /// List the hooks in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;Hook&gt;</returns>
        ApiResponse<List<Hook>> RepoListHooksWithHttpInfo(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0);
        /// <summary>
        /// List a repository&#39;s keys
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="keyId">the key_id to search for (optional)</param>
        /// <param name="fingerprint">fingerprint of the key (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;DeployKey&gt;</returns>
        List<DeployKey> RepoListKeys(string owner, string repo, int? keyId = default(int?), string? fingerprint = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0);

        /// <summary>
        /// List a repository&#39;s keys
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="keyId">the key_id to search for (optional)</param>
        /// <param name="fingerprint">fingerprint of the key (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;DeployKey&gt;</returns>
        ApiResponse<List<DeployKey>> RepoListKeysWithHttpInfo(string owner, string repo, int? keyId = default(int?), string? fingerprint = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0);
        /// <summary>
        /// List a repo&#39;s pinned issues
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;Issue&gt;</returns>
        List<Issue> RepoListPinnedIssues(string owner, string repo, int operationIndex = 0);

        /// <summary>
        /// List a repo&#39;s pinned issues
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;Issue&gt;</returns>
        ApiResponse<List<Issue>> RepoListPinnedIssuesWithHttpInfo(string owner, string repo, int operationIndex = 0);
        /// <summary>
        /// List a repo&#39;s pinned pull requests
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;PullRequest&gt;</returns>
        List<PullRequest> RepoListPinnedPullRequests(string owner, string repo, int operationIndex = 0);

        /// <summary>
        /// List a repo&#39;s pinned pull requests
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;PullRequest&gt;</returns>
        ApiResponse<List<PullRequest>> RepoListPinnedPullRequestsWithHttpInfo(string owner, string repo, int operationIndex = 0);
        /// <summary>
        /// List a repo&#39;s pull requests
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="state">State of pull request: open or closed (optional) (optional)</param>
        /// <param name="sort">Type of sort (optional)</param>
        /// <param name="milestone">ID of the milestone (optional)</param>
        /// <param name="labels">Label IDs (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;PullRequest&gt;</returns>
        List<PullRequest> RepoListPullRequests(string owner, string repo, string? state = default(string?), string? sort = default(string?), long? milestone = default(long?), List<long>? labels = default(List<long>?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0);

        /// <summary>
        /// List a repo&#39;s pull requests
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="state">State of pull request: open or closed (optional) (optional)</param>
        /// <param name="sort">Type of sort (optional)</param>
        /// <param name="milestone">ID of the milestone (optional)</param>
        /// <param name="labels">Label IDs (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;PullRequest&gt;</returns>
        ApiResponse<List<PullRequest>> RepoListPullRequestsWithHttpInfo(string owner, string repo, string? state = default(string?), string? sort = default(string?), long? milestone = default(long?), List<long>? labels = default(List<long>?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0);
        /// <summary>
        /// List all reviews for a pull request
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;PullReview&gt;</returns>
        List<PullReview> RepoListPullReviews(string owner, string repo, long index, int? page = default(int?), int? limit = default(int?), int operationIndex = 0);

        /// <summary>
        /// List all reviews for a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;PullReview&gt;</returns>
        ApiResponse<List<PullReview>> RepoListPullReviewsWithHttpInfo(string owner, string repo, long index, int? page = default(int?), int? limit = default(int?), int operationIndex = 0);
        /// <summary>
        /// Get all push mirrors of the repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;PushMirror&gt;</returns>
        List<PushMirror> RepoListPushMirrors(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0);

        /// <summary>
        /// Get all push mirrors of the repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;PushMirror&gt;</returns>
        ApiResponse<List<PushMirror>> RepoListPushMirrorsWithHttpInfo(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0);
        /// <summary>
        /// List release&#39;s attachments
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;Attachment&gt;</returns>
        List<Attachment> RepoListReleaseAttachments(string owner, string repo, long id, int operationIndex = 0);

        /// <summary>
        /// List release&#39;s attachments
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;Attachment&gt;</returns>
        ApiResponse<List<Attachment>> RepoListReleaseAttachmentsWithHttpInfo(string owner, string repo, long id, int operationIndex = 0);
        /// <summary>
        /// List a repo&#39;s releases
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="draft">filter (exclude / include) drafts, if you dont have repo write access none will show (optional)</param>
        /// <param name="preRelease">filter (exclude / include) pre-releases (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;Release&gt;</returns>
        List<Release> RepoListReleases(string owner, string repo, bool? draft = default(bool?), bool? preRelease = default(bool?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0);

        /// <summary>
        /// List a repo&#39;s releases
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="draft">filter (exclude / include) drafts, if you dont have repo write access none will show (optional)</param>
        /// <param name="preRelease">filter (exclude / include) pre-releases (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;Release&gt;</returns>
        ApiResponse<List<Release>> RepoListReleasesWithHttpInfo(string owner, string repo, bool? draft = default(bool?), bool? preRelease = default(bool?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0);
        /// <summary>
        /// List a repo&#39;s stargazers
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;User&gt;</returns>
        List<User> RepoListStargazers(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0);

        /// <summary>
        /// List a repo&#39;s stargazers
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;User&gt;</returns>
        ApiResponse<List<User>> RepoListStargazersWithHttpInfo(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0);
        /// <summary>
        /// Get a commit&#39;s statuses
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the commit</param>
        /// <param name="sort">type of sort (optional)</param>
        /// <param name="state">type of state (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;CommitStatus&gt;</returns>
        List<CommitStatus> RepoListStatuses(string owner, string repo, string sha, string? sort = default(string?), string? state = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0);

        /// <summary>
        /// Get a commit&#39;s statuses
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the commit</param>
        /// <param name="sort">type of sort (optional)</param>
        /// <param name="state">type of state (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;CommitStatus&gt;</returns>
        ApiResponse<List<CommitStatus>> RepoListStatusesWithHttpInfo(string owner, string repo, string sha, string? sort = default(string?), string? state = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0);
        /// <summary>
        /// Get a commit&#39;s statuses, by branch/tag/commit reference
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varRef">name of branch/tag/commit</param>
        /// <param name="sort">type of sort (optional)</param>
        /// <param name="state">type of state (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;CommitStatus&gt;</returns>
        List<CommitStatus> RepoListStatusesByRef(string owner, string repo, string varRef, string? sort = default(string?), string? state = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0);

        /// <summary>
        /// Get a commit&#39;s statuses, by branch/tag/commit reference
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varRef">name of branch/tag/commit</param>
        /// <param name="sort">type of sort (optional)</param>
        /// <param name="state">type of state (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;CommitStatus&gt;</returns>
        ApiResponse<List<CommitStatus>> RepoListStatusesByRefWithHttpInfo(string owner, string repo, string varRef, string? sort = default(string?), string? state = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0);
        /// <summary>
        /// List a repo&#39;s watchers
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;User&gt;</returns>
        List<User> RepoListSubscribers(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0);

        /// <summary>
        /// List a repo&#39;s watchers
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;User&gt;</returns>
        ApiResponse<List<User>> RepoListSubscribersWithHttpInfo(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0);
        /// <summary>
        /// List a repository&#39;s tags
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results, default maximum page size is 50 (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;Tag&gt;</returns>
        List<Tag> RepoListTags(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0);

        /// <summary>
        /// List a repository&#39;s tags
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results, default maximum page size is 50 (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;Tag&gt;</returns>
        ApiResponse<List<Tag>> RepoListTagsWithHttpInfo(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0);
        /// <summary>
        /// List a repository&#39;s teams
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;Team&gt;</returns>
        List<Team> RepoListTeams(string owner, string repo, int operationIndex = 0);

        /// <summary>
        /// List a repository&#39;s teams
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;Team&gt;</returns>
        ApiResponse<List<Team>> RepoListTeamsWithHttpInfo(string owner, string repo, int operationIndex = 0);
        /// <summary>
        /// Get list of topics that a repository has
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>TopicName</returns>
        TopicName RepoListTopics(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0);

        /// <summary>
        /// Get list of topics that a repository has
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of TopicName</returns>
        ApiResponse<TopicName> RepoListTopicsWithHttpInfo(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0);
        /// <summary>
        /// Merge a pull request
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to merge</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RepoMergePullRequest(string owner, string repo, long index, MergePullRequestOption? body = default(MergePullRequestOption?), int operationIndex = 0);

        /// <summary>
        /// Merge a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to merge</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RepoMergePullRequestWithHttpInfo(string owner, string repo, long index, MergePullRequestOption? body = default(MergePullRequestOption?), int operationIndex = 0);
        /// <summary>
        /// Migrate a remote git repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Repository</returns>
        Repository RepoMigrate(MigrateRepoOptions? body = default(MigrateRepoOptions?), int operationIndex = 0);

        /// <summary>
        /// Migrate a remote git repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Repository</returns>
        ApiResponse<Repository> RepoMigrateWithHttpInfo(MigrateRepoOptions? body = default(MigrateRepoOptions?), int operationIndex = 0);
        /// <summary>
        /// Sync a mirrored repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to sync</param>
        /// <param name="repo">name of the repo to sync</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RepoMirrorSync(string owner, string repo, int operationIndex = 0);

        /// <summary>
        /// Sync a mirrored repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to sync</param>
        /// <param name="repo">name of the repo to sync</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RepoMirrorSyncWithHttpInfo(string owner, string repo, int operationIndex = 0);
        /// <summary>
        /// Returns if new Issue Pins are allowed
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>NewIssuePinsAllowed</returns>
        NewIssuePinsAllowed RepoNewPinAllowed(string owner, string repo, int operationIndex = 0);

        /// <summary>
        /// Returns if new Issue Pins are allowed
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of NewIssuePinsAllowed</returns>
        ApiResponse<NewIssuePinsAllowed> RepoNewPinAllowedWithHttpInfo(string owner, string repo, int operationIndex = 0);
        /// <summary>
        /// Check if a pull request has been merged
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RepoPullRequestIsMerged(string owner, string repo, long index, int operationIndex = 0);

        /// <summary>
        /// Check if a pull request has been merged
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RepoPullRequestIsMergedWithHttpInfo(string owner, string repo, long index, int operationIndex = 0);
        /// <summary>
        /// Sync all push mirrored repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to sync</param>
        /// <param name="repo">name of the repo to sync</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RepoPushMirrorSync(string owner, string repo, int operationIndex = 0);

        /// <summary>
        /// Sync all push mirrored repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to sync</param>
        /// <param name="repo">name of the repo to sync</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RepoPushMirrorSyncWithHttpInfo(string owner, string repo, int operationIndex = 0);
        /// <summary>
        /// Search for repositories
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">keyword (optional)</param>
        /// <param name="topic">Limit search to repositories with keyword as topic (optional)</param>
        /// <param name="includeDesc">include search of keyword within repository description (optional)</param>
        /// <param name="uid">search only for repos that the user with the given id owns or contributes to (optional)</param>
        /// <param name="priorityOwnerId">repo owner to prioritize in the results (optional)</param>
        /// <param name="teamId">search only for repos that belong to the given team id (optional)</param>
        /// <param name="starredBy">search only for repos that the user with the given id has starred (optional)</param>
        /// <param name="varPrivate">include private repositories this user has access to (defaults to true) (optional)</param>
        /// <param name="isPrivate">show only pubic, private or all repositories (defaults to all) (optional)</param>
        /// <param name="template">include template repositories this user has access to (defaults to true) (optional)</param>
        /// <param name="archived">show only archived, non-archived or all repositories (defaults to all) (optional)</param>
        /// <param name="mode">type of repository to search for. Supported values are \&quot;fork\&quot;, \&quot;source\&quot;, \&quot;mirror\&quot; and \&quot;collaborative\&quot; (optional)</param>
        /// <param name="exclusive">if &#x60;uid&#x60; is given, search only for repos that the user owns (optional)</param>
        /// <param name="sort">sort repos by attribute. Supported values are \&quot;alpha\&quot;, \&quot;created\&quot;, \&quot;updated\&quot;, \&quot;size\&quot;, and \&quot;id\&quot;. Default is \&quot;alpha\&quot; (optional)</param>
        /// <param name="order">sort order, either \&quot;asc\&quot; (ascending) or \&quot;desc\&quot; (descending). Default is \&quot;asc\&quot;, ignored if \&quot;sort\&quot; is not specified. (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SearchResults</returns>
        SearchResults RepoSearch(string? q = default(string?), bool? topic = default(bool?), bool? includeDesc = default(bool?), long? uid = default(long?), long? priorityOwnerId = default(long?), long? teamId = default(long?), long? starredBy = default(long?), bool? varPrivate = default(bool?), bool? isPrivate = default(bool?), bool? template = default(bool?), bool? archived = default(bool?), string? mode = default(string?), bool? exclusive = default(bool?), string? sort = default(string?), string? order = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0);

        /// <summary>
        /// Search for repositories
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">keyword (optional)</param>
        /// <param name="topic">Limit search to repositories with keyword as topic (optional)</param>
        /// <param name="includeDesc">include search of keyword within repository description (optional)</param>
        /// <param name="uid">search only for repos that the user with the given id owns or contributes to (optional)</param>
        /// <param name="priorityOwnerId">repo owner to prioritize in the results (optional)</param>
        /// <param name="teamId">search only for repos that belong to the given team id (optional)</param>
        /// <param name="starredBy">search only for repos that the user with the given id has starred (optional)</param>
        /// <param name="varPrivate">include private repositories this user has access to (defaults to true) (optional)</param>
        /// <param name="isPrivate">show only pubic, private or all repositories (defaults to all) (optional)</param>
        /// <param name="template">include template repositories this user has access to (defaults to true) (optional)</param>
        /// <param name="archived">show only archived, non-archived or all repositories (defaults to all) (optional)</param>
        /// <param name="mode">type of repository to search for. Supported values are \&quot;fork\&quot;, \&quot;source\&quot;, \&quot;mirror\&quot; and \&quot;collaborative\&quot; (optional)</param>
        /// <param name="exclusive">if &#x60;uid&#x60; is given, search only for repos that the user owns (optional)</param>
        /// <param name="sort">sort repos by attribute. Supported values are \&quot;alpha\&quot;, \&quot;created\&quot;, \&quot;updated\&quot;, \&quot;size\&quot;, and \&quot;id\&quot;. Default is \&quot;alpha\&quot; (optional)</param>
        /// <param name="order">sort order, either \&quot;asc\&quot; (ascending) or \&quot;desc\&quot; (descending). Default is \&quot;asc\&quot;, ignored if \&quot;sort\&quot; is not specified. (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SearchResults</returns>
        ApiResponse<SearchResults> RepoSearchWithHttpInfo(string? q = default(string?), bool? topic = default(bool?), bool? includeDesc = default(bool?), long? uid = default(long?), long? priorityOwnerId = default(long?), long? teamId = default(long?), long? starredBy = default(long?), bool? varPrivate = default(bool?), bool? isPrivate = default(bool?), bool? template = default(bool?), bool? archived = default(bool?), string? mode = default(string?), bool? exclusive = default(bool?), string? sort = default(string?), string? order = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0);
        /// <summary>
        /// Get signing-key.gpg for given repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>string</returns>
        string RepoSigningKey(string owner, string repo, int operationIndex = 0);

        /// <summary>
        /// Get signing-key.gpg for given repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> RepoSigningKeyWithHttpInfo(string owner, string repo, int operationIndex = 0);
        /// <summary>
        /// Submit a pending review to an pull request
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PullReview</returns>
        PullReview RepoSubmitPullReview(string owner, string repo, long index, long id, SubmitPullReviewOptions body, int operationIndex = 0);

        /// <summary>
        /// Submit a pending review to an pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PullReview</returns>
        ApiResponse<PullReview> RepoSubmitPullReviewWithHttpInfo(string owner, string repo, long index, long id, SubmitPullReviewOptions body, int operationIndex = 0);
        /// <summary>
        /// Test a push webhook
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to test</param>
        /// <param name="varRef">The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RepoTestHook(string owner, string repo, long id, string? varRef = default(string?), int operationIndex = 0);

        /// <summary>
        /// Test a push webhook
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to test</param>
        /// <param name="varRef">The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RepoTestHookWithHttpInfo(string owner, string repo, long id, string? varRef = default(string?), int operationIndex = 0);
        /// <summary>
        /// List a repo&#39;s tracked times
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="user">optional filter by user (available for issue managers) (optional)</param>
        /// <param name="since">Only show times updated after the given time. This is a timestamp in RFC 3339 format (optional)</param>
        /// <param name="before">Only show times updated before the given time. This is a timestamp in RFC 3339 format (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;TrackedTime&gt;</returns>
        List<TrackedTime> RepoTrackedTimes(string owner, string repo, string? user = default(string?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0);

        /// <summary>
        /// List a repo&#39;s tracked times
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="user">optional filter by user (available for issue managers) (optional)</param>
        /// <param name="since">Only show times updated after the given time. This is a timestamp in RFC 3339 format (optional)</param>
        /// <param name="before">Only show times updated before the given time. This is a timestamp in RFC 3339 format (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;TrackedTime&gt;</returns>
        ApiResponse<List<TrackedTime>> RepoTrackedTimesWithHttpInfo(string owner, string repo, string? user = default(string?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0);
        /// <summary>
        /// Transfer a repo ownership
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to transfer</param>
        /// <param name="repo">name of the repo to transfer</param>
        /// <param name="body">Transfer Options</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Repository</returns>
        Repository RepoTransfer(string owner, string repo, TransferRepoOption body, int operationIndex = 0);

        /// <summary>
        /// Transfer a repo ownership
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to transfer</param>
        /// <param name="repo">name of the repo to transfer</param>
        /// <param name="body">Transfer Options</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Repository</returns>
        ApiResponse<Repository> RepoTransferWithHttpInfo(string owner, string repo, TransferRepoOption body, int operationIndex = 0);
        /// <summary>
        /// Cancel to dismiss a review for a pull request
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PullReview</returns>
        PullReview RepoUnDismissPullReview(string owner, string repo, long index, long id, int operationIndex = 0);

        /// <summary>
        /// Cancel to dismiss a review for a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PullReview</returns>
        ApiResponse<PullReview> RepoUnDismissPullReviewWithHttpInfo(string owner, string repo, long index, long id, int operationIndex = 0);
        /// <summary>
        /// Update avatar
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RepoUpdateAvatar(string owner, string repo, UpdateRepoAvatarOption? body = default(UpdateRepoAvatarOption?), int operationIndex = 0);

        /// <summary>
        /// Update avatar
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RepoUpdateAvatarWithHttpInfo(string owner, string repo, UpdateRepoAvatarOption? body = default(UpdateRepoAvatarOption?), int operationIndex = 0);
        /// <summary>
        /// Update a file in a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">path of the file to update</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>FileResponse</returns>
        FileResponse RepoUpdateFile(string owner, string repo, string filepath, UpdateFileOptions body, int operationIndex = 0);

        /// <summary>
        /// Update a file in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">path of the file to update</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of FileResponse</returns>
        ApiResponse<FileResponse> RepoUpdateFileWithHttpInfo(string owner, string repo, string filepath, UpdateFileOptions body, int operationIndex = 0);
        /// <summary>
        /// Merge PR&#39;s baseBranch into headBranch
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="style">how to update pull request (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RepoUpdatePullRequest(string owner, string repo, long index, string? style = default(string?), int operationIndex = 0);

        /// <summary>
        /// Merge PR&#39;s baseBranch into headBranch
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="style">how to update pull request (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RepoUpdatePullRequestWithHttpInfo(string owner, string repo, long index, string? style = default(string?), int operationIndex = 0);
        /// <summary>
        /// Replace list of topics for a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RepoUpdateTopics(string owner, string repo, RepoTopicOptions? body = default(RepoTopicOptions?), int operationIndex = 0);

        /// <summary>
        /// Replace list of topics for a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RepoUpdateTopicsWithHttpInfo(string owner, string repo, RepoTopicOptions? body = default(RepoTopicOptions?), int operationIndex = 0);
        /// <summary>
        /// Returns the validation information for a issue config
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>IssueConfigValidation</returns>
        IssueConfigValidation RepoValidateIssueConfig(string owner, string repo, int operationIndex = 0);

        /// <summary>
        /// Returns the validation information for a issue config
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of IssueConfigValidation</returns>
        ApiResponse<IssueConfigValidation> RepoValidateIssueConfigWithHttpInfo(string owner, string repo, int operationIndex = 0);
        /// <summary>
        /// search topics via keyword
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">keywords to search</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;TopicResponse&gt;</returns>
        List<TopicResponse> TopicSearch(string q, int? page = default(int?), int? limit = default(int?), int operationIndex = 0);

        /// <summary>
        /// search topics via keyword
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">keywords to search</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;TopicResponse&gt;</returns>
        ApiResponse<List<TopicResponse>> TopicSearchWithHttpInfo(string q, int? page = default(int?), int? limit = default(int?), int operationIndex = 0);
        /// <summary>
        /// Create or Update a secret value in a repository
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repository</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="secretname">name of the secret</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void UpdateRepoSecret(string owner, string repo, string secretname, CreateOrUpdateSecretOption? body = default(CreateOrUpdateSecretOption?), int operationIndex = 0);

        /// <summary>
        /// Create or Update a secret value in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repository</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="secretname">name of the secret</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateRepoSecretWithHttpInfo(string owner, string repo, string secretname, CreateOrUpdateSecretOption? body = default(CreateOrUpdateSecretOption?), int operationIndex = 0);
        /// <summary>
        /// Update a repo-level variable
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="variablename">name of the variable</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void UpdateRepoVariable(string owner, string repo, string variablename, UpdateVariableOption? body = default(UpdateVariableOption?), int operationIndex = 0);

        /// <summary>
        /// Update a repo-level variable
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="variablename">name of the variable</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateRepoVariableWithHttpInfo(string owner, string repo, string variablename, UpdateVariableOption? body = default(UpdateVariableOption?), int operationIndex = 0);
        /// <summary>
        /// Check if the current user is watching a repo
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>WatchInfo</returns>
        WatchInfo UserCurrentCheckSubscription(string owner, string repo, int operationIndex = 0);

        /// <summary>
        /// Check if the current user is watching a repo
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of WatchInfo</returns>
        ApiResponse<WatchInfo> UserCurrentCheckSubscriptionWithHttpInfo(string owner, string repo, int operationIndex = 0);
        /// <summary>
        /// Unwatch a repo
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void UserCurrentDeleteSubscription(string owner, string repo, int operationIndex = 0);

        /// <summary>
        /// Unwatch a repo
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UserCurrentDeleteSubscriptionWithHttpInfo(string owner, string repo, int operationIndex = 0);
        /// <summary>
        /// Watch a repo
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>WatchInfo</returns>
        WatchInfo UserCurrentPutSubscription(string owner, string repo, int operationIndex = 0);

        /// <summary>
        /// Watch a repo
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of WatchInfo</returns>
        ApiResponse<WatchInfo> UserCurrentPutSubscriptionWithHttpInfo(string owner, string repo, int operationIndex = 0);
        /// <summary>
        /// List a user&#39;s tracked times in a repo
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="user">username of user</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;TrackedTime&gt;</returns>
        [Obsolete]
        List<TrackedTime> UserTrackedTimes(string owner, string repo, string user, int operationIndex = 0);

        /// <summary>
        /// List a user&#39;s tracked times in a repo
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="user">username of user</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;TrackedTime&gt;</returns>
        [Obsolete]
        ApiResponse<List<TrackedTime>> UserTrackedTimesWithHttpInfo(string owner, string repo, string user, int operationIndex = 0);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IRepositoryApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Accept a repo transfer
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to transfer</param>
        /// <param name="repo">name of the repo to transfer</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Repository</returns>
        System.Threading.Tasks.Task<Repository> AcceptRepoTransferAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Accept a repo transfer
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to transfer</param>
        /// <param name="repo">name of the repo to transfer</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Repository)</returns>
        System.Threading.Tasks.Task<ApiResponse<Repository>> AcceptRepoTransferWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Create a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Repository</returns>
        System.Threading.Tasks.Task<Repository> CreateCurrentUserRepoAsync(CreateRepoOption? body = default(CreateRepoOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Create a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Repository)</returns>
        System.Threading.Tasks.Task<ApiResponse<Repository>> CreateCurrentUserRepoWithHttpInfoAsync(CreateRepoOption? body = default(CreateRepoOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Fork a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to fork</param>
        /// <param name="repo">name of the repo to fork</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Repository</returns>
        System.Threading.Tasks.Task<Repository> CreateForkAsync(string owner, string repo, CreateForkOption? body = default(CreateForkOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Fork a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to fork</param>
        /// <param name="repo">name of the repo to fork</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Repository)</returns>
        System.Threading.Tasks.Task<ApiResponse<Repository>> CreateForkWithHttpInfoAsync(string owner, string repo, CreateForkOption? body = default(CreateForkOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Create a repo-level variable
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="variablename">name of the variable</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task CreateRepoVariableAsync(string owner, string repo, string variablename, CreateVariableOption? body = default(CreateVariableOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Create a repo-level variable
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="variablename">name of the variable</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> CreateRepoVariableWithHttpInfoAsync(string owner, string repo, string variablename, CreateVariableOption? body = default(CreateVariableOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Delete a secret in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repository</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="secretname">name of the secret</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteRepoSecretAsync(string owner, string repo, string secretname, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Delete a secret in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repository</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="secretname">name of the secret</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteRepoSecretWithHttpInfoAsync(string owner, string repo, string secretname, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Delete a repo-level variable
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="variablename">name of the variable</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ActionVariable</returns>
        System.Threading.Tasks.Task<ActionVariable> DeleteRepoVariableAsync(string owner, string repo, string variablename, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Delete a repo-level variable
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="variablename">name of the variable</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ActionVariable)</returns>
        System.Threading.Tasks.Task<ApiResponse<ActionVariable>> DeleteRepoVariableWithHttpInfoAsync(string owner, string repo, string variablename, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Create a repository using a template
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="templateOwner">name of the template repository owner</param>
        /// <param name="templateRepo">name of the template repository</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Repository</returns>
        System.Threading.Tasks.Task<Repository> GenerateRepoAsync(string templateOwner, string templateRepo, GenerateRepoOption? body = default(GenerateRepoOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Create a repository using a template
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="templateOwner">name of the template repository owner</param>
        /// <param name="templateRepo">name of the template repository</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Repository)</returns>
        System.Threading.Tasks.Task<ApiResponse<Repository>> GenerateRepoWithHttpInfoAsync(string templateOwner, string templateRepo, GenerateRepoOption? body = default(GenerateRepoOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Gets the tag object of an annotated tag (not lightweight tags)
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of AnnotatedTag</returns>
        System.Threading.Tasks.Task<AnnotatedTag> GetAnnotatedTagAsync(string owner, string repo, string sha, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Gets the tag object of an annotated tag (not lightweight tags)
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (AnnotatedTag)</returns>
        System.Threading.Tasks.Task<ApiResponse<AnnotatedTag>> GetAnnotatedTagWithHttpInfoAsync(string owner, string repo, string sha, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Gets the blob of a repository.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the commit</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GitBlobResponse</returns>
        System.Threading.Tasks.Task<GitBlobResponse> GetBlobAsync(string owner, string repo, string sha, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Gets the blob of a repository.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the commit</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GitBlobResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<GitBlobResponse>> GetBlobWithHttpInfoAsync(string owner, string repo, string sha, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get a repo-level variable
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="variablename">name of the variable</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ActionVariable</returns>
        System.Threading.Tasks.Task<ActionVariable> GetRepoVariableAsync(string owner, string repo, string variablename, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get a repo-level variable
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="variablename">name of the variable</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ActionVariable)</returns>
        System.Threading.Tasks.Task<ApiResponse<ActionVariable>> GetRepoVariableWithHttpInfoAsync(string owner, string repo, string variablename, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get repo-level variables list
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;ActionVariable&gt;</returns>
        System.Threading.Tasks.Task<List<ActionVariable>> GetRepoVariablesListAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get repo-level variables list
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;ActionVariable&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<ActionVariable>>> GetRepoVariablesListWithHttpInfoAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Gets the tree of a repository.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the commit</param>
        /// <param name="recursive">show all directories and files (optional)</param>
        /// <param name="page">page number; the &#39;truncated&#39; field in the response will be true if there are still more items after this page, false if the last page (optional)</param>
        /// <param name="perPage">number of items per page (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GitTreeResponse</returns>
        System.Threading.Tasks.Task<GitTreeResponse> GetTreeAsync(string owner, string repo, string sha, bool? recursive = default(bool?), int? page = default(int?), int? perPage = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Gets the tree of a repository.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the commit</param>
        /// <param name="recursive">show all directories and files (optional)</param>
        /// <param name="page">page number; the &#39;truncated&#39; field in the response will be true if there are still more items after this page, false if the last page (optional)</param>
        /// <param name="perPage">number of items per page (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GitTreeResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<GitTreeResponse>> GetTreeWithHttpInfoAsync(string owner, string repo, string sha, bool? recursive = default(bool?), int? page = default(int?), int? perPage = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// List a repository&#39;s forks
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Repository&gt;</returns>
        System.Threading.Tasks.Task<List<Repository>> ListForksAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// List a repository&#39;s forks
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Repository&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<Repository>>> ListForksWithHttpInfoAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Reject a repo transfer
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to transfer</param>
        /// <param name="repo">name of the repo to transfer</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Repository</returns>
        System.Threading.Tasks.Task<Repository> RejectRepoTransferAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Reject a repo transfer
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to transfer</param>
        /// <param name="repo">name of the repo to transfer</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Repository)</returns>
        System.Threading.Tasks.Task<ApiResponse<Repository>> RejectRepoTransferWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Add a collaborator to a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="collaborator">username of the collaborator to add</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RepoAddCollaboratorAsync(string owner, string repo, string collaborator, AddCollaboratorOption? body = default(AddCollaboratorOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Add a collaborator to a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="collaborator">username of the collaborator to add</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RepoAddCollaboratorWithHttpInfoAsync(string owner, string repo, string collaborator, AddCollaboratorOption? body = default(AddCollaboratorOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// add a push mirror to the repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PushMirror</returns>
        System.Threading.Tasks.Task<PushMirror> RepoAddPushMirrorAsync(string owner, string repo, CreatePushMirrorOption? body = default(CreatePushMirrorOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// add a push mirror to the repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PushMirror)</returns>
        System.Threading.Tasks.Task<ApiResponse<PushMirror>> RepoAddPushMirrorWithHttpInfoAsync(string owner, string repo, CreatePushMirrorOption? body = default(CreatePushMirrorOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Add a team to a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="team">team name</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RepoAddTeamAsync(string owner, string repo, string team, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Add a team to a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="team">team name</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RepoAddTeamWithHttpInfoAsync(string owner, string repo, string team, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Add a topic to a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="topic">name of the topic to add</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RepoAddTopicAsync(string owner, string repo, string topic, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Add a topic to a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="topic">name of the topic to add</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RepoAddTopicWithHttpInfoAsync(string owner, string repo, string topic, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Apply diff patch to repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of FileResponse</returns>
        System.Threading.Tasks.Task<FileResponse> RepoApplyDiffPatchAsync(string owner, string repo, UpdateFileOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Apply diff patch to repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (FileResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<FileResponse>> RepoApplyDiffPatchWithHttpInfoAsync(string owner, string repo, UpdateFileOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Cancel the scheduled auto merge for the given pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to merge</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RepoCancelScheduledAutoMergeAsync(string owner, string repo, long index, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Cancel the scheduled auto merge for the given pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to merge</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RepoCancelScheduledAutoMergeWithHttpInfoAsync(string owner, string repo, long index, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Modify multiple files in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of FilesResponse</returns>
        System.Threading.Tasks.Task<FilesResponse> RepoChangeFilesAsync(string owner, string repo, ChangeFilesOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Modify multiple files in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (FilesResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<FilesResponse>> RepoChangeFilesWithHttpInfoAsync(string owner, string repo, ChangeFilesOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Check if a user is a collaborator of a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="collaborator">username of the collaborator</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RepoCheckCollaboratorAsync(string owner, string repo, string collaborator, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Check if a user is a collaborator of a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="collaborator">username of the collaborator</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RepoCheckCollaboratorWithHttpInfoAsync(string owner, string repo, string collaborator, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Check if a team is assigned to a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="team">team name</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Team</returns>
        System.Threading.Tasks.Task<Team> RepoCheckTeamAsync(string owner, string repo, string team, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Check if a team is assigned to a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="team">team name</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Team)</returns>
        System.Threading.Tasks.Task<ApiResponse<Team>> RepoCheckTeamWithHttpInfoAsync(string owner, string repo, string team, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get commit comparison information
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="basehead">compare two branches or commits</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Compare</returns>
        System.Threading.Tasks.Task<Compare> RepoCompareDiffAsync(string owner, string repo, string basehead, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get commit comparison information
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="basehead">compare two branches or commits</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Compare)</returns>
        System.Threading.Tasks.Task<ApiResponse<Compare>> RepoCompareDiffWithHttpInfoAsync(string owner, string repo, string basehead, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Create a branch
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Branch</returns>
        System.Threading.Tasks.Task<Branch> RepoCreateBranchAsync(string owner, string repo, CreateBranchRepoOption? body = default(CreateBranchRepoOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Create a branch
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Branch)</returns>
        System.Threading.Tasks.Task<ApiResponse<Branch>> RepoCreateBranchWithHttpInfoAsync(string owner, string repo, CreateBranchRepoOption? body = default(CreateBranchRepoOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Create a branch protections for a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BranchProtection</returns>
        System.Threading.Tasks.Task<BranchProtection> RepoCreateBranchProtectionAsync(string owner, string repo, CreateBranchProtectionOption? body = default(CreateBranchProtectionOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Create a branch protections for a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BranchProtection)</returns>
        System.Threading.Tasks.Task<ApiResponse<BranchProtection>> RepoCreateBranchProtectionWithHttpInfoAsync(string owner, string repo, CreateBranchProtectionOption? body = default(CreateBranchProtectionOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Create a file in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">path of the file to create</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of FileResponse</returns>
        System.Threading.Tasks.Task<FileResponse> RepoCreateFileAsync(string owner, string repo, string filepath, CreateFileOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Create a file in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">path of the file to create</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (FileResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<FileResponse>> RepoCreateFileWithHttpInfoAsync(string owner, string repo, string filepath, CreateFileOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Create a hook
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Hook</returns>
        System.Threading.Tasks.Task<Hook> RepoCreateHookAsync(string owner, string repo, CreateHookOption? body = default(CreateHookOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Create a hook
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Hook)</returns>
        System.Threading.Tasks.Task<ApiResponse<Hook>> RepoCreateHookWithHttpInfoAsync(string owner, string repo, CreateHookOption? body = default(CreateHookOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Add a key to a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of DeployKey</returns>
        System.Threading.Tasks.Task<DeployKey> RepoCreateKeyAsync(string owner, string repo, CreateKeyOption? body = default(CreateKeyOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Add a key to a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (DeployKey)</returns>
        System.Threading.Tasks.Task<ApiResponse<DeployKey>> RepoCreateKeyWithHttpInfoAsync(string owner, string repo, CreateKeyOption? body = default(CreateKeyOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Create a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PullRequest</returns>
        System.Threading.Tasks.Task<PullRequest> RepoCreatePullRequestAsync(string owner, string repo, CreatePullRequestOption? body = default(CreatePullRequestOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Create a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PullRequest)</returns>
        System.Threading.Tasks.Task<ApiResponse<PullRequest>> RepoCreatePullRequestWithHttpInfoAsync(string owner, string repo, CreatePullRequestOption? body = default(CreatePullRequestOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Create a review to an pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PullReview</returns>
        System.Threading.Tasks.Task<PullReview> RepoCreatePullReviewAsync(string owner, string repo, long index, CreatePullReviewOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Create a review to an pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PullReview)</returns>
        System.Threading.Tasks.Task<ApiResponse<PullReview>> RepoCreatePullReviewWithHttpInfoAsync(string owner, string repo, long index, CreatePullReviewOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// create review requests for a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;PullReview&gt;</returns>
        System.Threading.Tasks.Task<List<PullReview>> RepoCreatePullReviewRequestsAsync(string owner, string repo, long index, PullReviewRequestOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// create review requests for a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;PullReview&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<PullReview>>> RepoCreatePullReviewRequestsWithHttpInfoAsync(string owner, string repo, long index, PullReviewRequestOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Create a release
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Release</returns>
        System.Threading.Tasks.Task<Release> RepoCreateReleaseAsync(string owner, string repo, CreateReleaseOption? body = default(CreateReleaseOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Create a release
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Release)</returns>
        System.Threading.Tasks.Task<ApiResponse<Release>> RepoCreateReleaseWithHttpInfoAsync(string owner, string repo, CreateReleaseOption? body = default(CreateReleaseOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Create a release attachment
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="name">name of the attachment (optional)</param>
        /// <param name="attachment">attachment to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Attachment</returns>
        System.Threading.Tasks.Task<Attachment> RepoCreateReleaseAttachmentAsync(string owner, string repo, long id, string? name = default(string?), System.IO.Stream? attachment = default(System.IO.Stream?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Create a release attachment
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="name">name of the attachment (optional)</param>
        /// <param name="attachment">attachment to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Attachment)</returns>
        System.Threading.Tasks.Task<ApiResponse<Attachment>> RepoCreateReleaseAttachmentWithHttpInfoAsync(string owner, string repo, long id, string? name = default(string?), System.IO.Stream? attachment = default(System.IO.Stream?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Create a commit status
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the commit</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CommitStatus</returns>
        System.Threading.Tasks.Task<CommitStatus> RepoCreateStatusAsync(string owner, string repo, string sha, CreateStatusOption? body = default(CreateStatusOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Create a commit status
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the commit</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CommitStatus)</returns>
        System.Threading.Tasks.Task<ApiResponse<CommitStatus>> RepoCreateStatusWithHttpInfoAsync(string owner, string repo, string sha, CreateStatusOption? body = default(CreateStatusOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Create a new git tag in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Tag</returns>
        System.Threading.Tasks.Task<Tag> RepoCreateTagAsync(string owner, string repo, CreateTagOption? body = default(CreateTagOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Create a new git tag in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Tag)</returns>
        System.Threading.Tasks.Task<ApiResponse<Tag>> RepoCreateTagWithHttpInfoAsync(string owner, string repo, CreateTagOption? body = default(CreateTagOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Create a wiki page
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of WikiPage</returns>
        System.Threading.Tasks.Task<WikiPage> RepoCreateWikiPageAsync(string owner, string repo, CreateWikiPageOptions? body = default(CreateWikiPageOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Create a wiki page
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (WikiPage)</returns>
        System.Threading.Tasks.Task<ApiResponse<WikiPage>> RepoCreateWikiPageWithHttpInfoAsync(string owner, string repo, CreateWikiPageOptions? body = default(CreateWikiPageOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Delete a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to delete</param>
        /// <param name="repo">name of the repo to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RepoDeleteAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Delete a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to delete</param>
        /// <param name="repo">name of the repo to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RepoDeleteWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Delete avatar
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RepoDeleteAvatarAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Delete avatar
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RepoDeleteAvatarWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Delete a specific branch from a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="branch">branch to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RepoDeleteBranchAsync(string owner, string repo, string branch, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Delete a specific branch from a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="branch">branch to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RepoDeleteBranchWithHttpInfoAsync(string owner, string repo, string branch, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Delete a specific branch protection for the repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">name of protected branch</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RepoDeleteBranchProtectionAsync(string owner, string repo, string name, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Delete a specific branch protection for the repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">name of protected branch</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RepoDeleteBranchProtectionWithHttpInfoAsync(string owner, string repo, string name, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Delete a collaborator from a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="collaborator">username of the collaborator to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RepoDeleteCollaboratorAsync(string owner, string repo, string collaborator, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Delete a collaborator from a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="collaborator">username of the collaborator to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RepoDeleteCollaboratorWithHttpInfoAsync(string owner, string repo, string collaborator, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Delete a file in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">path of the file to delete</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of FileDeleteResponse</returns>
        System.Threading.Tasks.Task<FileDeleteResponse> RepoDeleteFileAsync(string owner, string repo, string filepath, DeleteFileOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Delete a file in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">path of the file to delete</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (FileDeleteResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<FileDeleteResponse>> RepoDeleteFileWithHttpInfoAsync(string owner, string repo, string filepath, DeleteFileOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Delete a Git hook in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RepoDeleteGitHookAsync(string owner, string repo, string id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Delete a Git hook in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RepoDeleteGitHookWithHttpInfoAsync(string owner, string repo, string id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Delete a hook in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RepoDeleteHookAsync(string owner, string repo, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Delete a hook in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RepoDeleteHookWithHttpInfoAsync(string owner, string repo, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Delete a key from a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the key to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RepoDeleteKeyAsync(string owner, string repo, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Delete a key from a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the key to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RepoDeleteKeyWithHttpInfoAsync(string owner, string repo, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Delete a specific review from a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RepoDeletePullReviewAsync(string owner, string repo, long index, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Delete a specific review from a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RepoDeletePullReviewWithHttpInfoAsync(string owner, string repo, long index, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// cancel review requests for a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RepoDeletePullReviewRequestsAsync(string owner, string repo, long index, PullReviewRequestOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// cancel review requests for a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RepoDeletePullReviewRequestsWithHttpInfoAsync(string owner, string repo, long index, PullReviewRequestOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// deletes a push mirror from a repository by remoteName
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">remote name of the pushMirror</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RepoDeletePushMirrorAsync(string owner, string repo, string name, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// deletes a push mirror from a repository by remoteName
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">remote name of the pushMirror</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RepoDeletePushMirrorWithHttpInfoAsync(string owner, string repo, string name, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Delete a release
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RepoDeleteReleaseAsync(string owner, string repo, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Delete a release
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RepoDeleteReleaseWithHttpInfoAsync(string owner, string repo, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Delete a release attachment
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="attachmentId">id of the attachment to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RepoDeleteReleaseAttachmentAsync(string owner, string repo, long id, long attachmentId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Delete a release attachment
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="attachmentId">id of the attachment to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RepoDeleteReleaseAttachmentWithHttpInfoAsync(string owner, string repo, long id, long attachmentId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Delete a release by tag name
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="tag">tag name of the release to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RepoDeleteReleaseByTagAsync(string owner, string repo, string tag, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Delete a release by tag name
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="tag">tag name of the release to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RepoDeleteReleaseByTagWithHttpInfoAsync(string owner, string repo, string tag, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Delete a repository&#39;s tag by name
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="tag">name of tag to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RepoDeleteTagAsync(string owner, string repo, string tag, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Delete a repository&#39;s tag by name
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="tag">name of tag to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RepoDeleteTagWithHttpInfoAsync(string owner, string repo, string tag, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Delete a team from a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="team">team name</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RepoDeleteTeamAsync(string owner, string repo, string team, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Delete a team from a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="team">team name</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RepoDeleteTeamWithHttpInfoAsync(string owner, string repo, string team, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Delete a topic from a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="topic">name of the topic to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RepoDeleteTopicAsync(string owner, string repo, string topic, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Delete a topic from a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="topic">name of the topic to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RepoDeleteTopicWithHttpInfoAsync(string owner, string repo, string topic, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Delete a wiki page
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="pageName">name of the page</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RepoDeleteWikiPageAsync(string owner, string repo, string pageName, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Delete a wiki page
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="pageName">name of the page</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RepoDeleteWikiPageWithHttpInfoAsync(string owner, string repo, string pageName, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Dismiss a review for a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PullReview</returns>
        System.Threading.Tasks.Task<PullReview> RepoDismissPullReviewAsync(string owner, string repo, long index, long id, DismissPullReviewOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Dismiss a review for a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PullReview)</returns>
        System.Threading.Tasks.Task<ApiResponse<PullReview>> RepoDismissPullReviewWithHttpInfoAsync(string owner, string repo, long index, long id, DismissPullReviewOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get a commit&#39;s diff or patch
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">SHA of the commit to get</param>
        /// <param name="diffType">whether the output is diff or patch</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> RepoDownloadCommitDiffOrPatchAsync(string owner, string repo, string sha, string diffType, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get a commit&#39;s diff or patch
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">SHA of the commit to get</param>
        /// <param name="diffType">whether the output is diff or patch</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> RepoDownloadCommitDiffOrPatchWithHttpInfoAsync(string owner, string repo, string sha, string diffType, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get a pull request diff or patch
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="diffType">whether the output is diff or patch</param>
        /// <param name="binary">whether to include binary file changes. if true, the diff is applicable with &#x60;git apply&#x60; (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> RepoDownloadPullDiffOrPatchAsync(string owner, string repo, long index, string diffType, bool? binary = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get a pull request diff or patch
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="diffType">whether the output is diff or patch</param>
        /// <param name="binary">whether to include binary file changes. if true, the diff is applicable with &#x60;git apply&#x60; (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> RepoDownloadPullDiffOrPatchWithHttpInfoAsync(string owner, string repo, long index, string diffType, bool? binary = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Edit a repository&#39;s properties. Only fields that are set will be changed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to edit</param>
        /// <param name="repo">name of the repo to edit</param>
        /// <param name="body">Properties of a repo that you can edit (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Repository</returns>
        System.Threading.Tasks.Task<Repository> RepoEditAsync(string owner, string repo, EditRepoOption? body = default(EditRepoOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Edit a repository&#39;s properties. Only fields that are set will be changed.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to edit</param>
        /// <param name="repo">name of the repo to edit</param>
        /// <param name="body">Properties of a repo that you can edit (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Repository)</returns>
        System.Threading.Tasks.Task<ApiResponse<Repository>> RepoEditWithHttpInfoAsync(string owner, string repo, EditRepoOption? body = default(EditRepoOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Edit a branch protections for a repository. Only fields that are set will be changed
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">name of protected branch</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BranchProtection</returns>
        System.Threading.Tasks.Task<BranchProtection> RepoEditBranchProtectionAsync(string owner, string repo, string name, EditBranchProtectionOption? body = default(EditBranchProtectionOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Edit a branch protections for a repository. Only fields that are set will be changed
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">name of protected branch</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BranchProtection)</returns>
        System.Threading.Tasks.Task<ApiResponse<BranchProtection>> RepoEditBranchProtectionWithHttpInfoAsync(string owner, string repo, string name, EditBranchProtectionOption? body = default(EditBranchProtectionOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Edit a Git hook in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to get</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GitHook</returns>
        System.Threading.Tasks.Task<GitHook> RepoEditGitHookAsync(string owner, string repo, string id, EditGitHookOption? body = default(EditGitHookOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Edit a Git hook in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to get</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GitHook)</returns>
        System.Threading.Tasks.Task<ApiResponse<GitHook>> RepoEditGitHookWithHttpInfoAsync(string owner, string repo, string id, EditGitHookOption? body = default(EditGitHookOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Edit a hook in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">index of the hook</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Hook</returns>
        System.Threading.Tasks.Task<Hook> RepoEditHookAsync(string owner, string repo, long id, EditHookOption? body = default(EditHookOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Edit a hook in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">index of the hook</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Hook)</returns>
        System.Threading.Tasks.Task<ApiResponse<Hook>> RepoEditHookWithHttpInfoAsync(string owner, string repo, long id, EditHookOption? body = default(EditHookOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Update a pull request. If using deadline only the date will be taken into account, and time of day ignored.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to edit</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PullRequest</returns>
        System.Threading.Tasks.Task<PullRequest> RepoEditPullRequestAsync(string owner, string repo, long index, EditPullRequestOption? body = default(EditPullRequestOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Update a pull request. If using deadline only the date will be taken into account, and time of day ignored.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to edit</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PullRequest)</returns>
        System.Threading.Tasks.Task<ApiResponse<PullRequest>> RepoEditPullRequestWithHttpInfoAsync(string owner, string repo, long index, EditPullRequestOption? body = default(EditPullRequestOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Update a release
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release to edit</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Release</returns>
        System.Threading.Tasks.Task<Release> RepoEditReleaseAsync(string owner, string repo, long id, EditReleaseOption? body = default(EditReleaseOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Update a release
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release to edit</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Release)</returns>
        System.Threading.Tasks.Task<ApiResponse<Release>> RepoEditReleaseWithHttpInfoAsync(string owner, string repo, long id, EditReleaseOption? body = default(EditReleaseOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Edit a release attachment
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="attachmentId">id of the attachment to edit</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Attachment</returns>
        System.Threading.Tasks.Task<Attachment> RepoEditReleaseAttachmentAsync(string owner, string repo, long id, long attachmentId, EditAttachmentOptions? body = default(EditAttachmentOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Edit a release attachment
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="attachmentId">id of the attachment to edit</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Attachment)</returns>
        System.Threading.Tasks.Task<ApiResponse<Attachment>> RepoEditReleaseAttachmentWithHttpInfoAsync(string owner, string repo, long id, long attachmentId, EditAttachmentOptions? body = default(EditAttachmentOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Edit a wiki page
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="pageName">name of the page</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of WikiPage</returns>
        System.Threading.Tasks.Task<WikiPage> RepoEditWikiPageAsync(string owner, string repo, string pageName, CreateWikiPageOptions? body = default(CreateWikiPageOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Edit a wiki page
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="pageName">name of the page</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (WikiPage)</returns>
        System.Threading.Tasks.Task<ApiResponse<WikiPage>> RepoEditWikiPageWithHttpInfoAsync(string owner, string repo, string pageName, CreateWikiPageOptions? body = default(CreateWikiPageOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Repository</returns>
        System.Threading.Tasks.Task<Repository> RepoGetAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Repository)</returns>
        System.Threading.Tasks.Task<ApiResponse<Repository>> RepoGetWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get a list of all commits from a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">SHA or branch to start listing commits from (usually &#39;master&#39;) (optional)</param>
        /// <param name="path">filepath of a file/dir (optional)</param>
        /// <param name="stat">include diff stats for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="verification">include verification for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="files">include a list of affected files for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (ignored if used with &#39;path&#39;) (optional)</param>
        /// <param name="not">commits that match the given specifier will not be listed. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Commit&gt;</returns>
        System.Threading.Tasks.Task<List<Commit>> RepoGetAllCommitsAsync(string owner, string repo, string? sha = default(string?), string? path = default(string?), bool? stat = default(bool?), bool? verification = default(bool?), bool? files = default(bool?), int? page = default(int?), int? limit = default(int?), string? not = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get a list of all commits from a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">SHA or branch to start listing commits from (usually &#39;master&#39;) (optional)</param>
        /// <param name="path">filepath of a file/dir (optional)</param>
        /// <param name="stat">include diff stats for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="verification">include verification for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="files">include a list of affected files for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (ignored if used with &#39;path&#39;) (optional)</param>
        /// <param name="not">commits that match the given specifier will not be listed. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Commit&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<Commit>>> RepoGetAllCommitsWithHttpInfoAsync(string owner, string repo, string? sha = default(string?), string? path = default(string?), bool? stat = default(bool?), bool? verification = default(bool?), bool? files = default(bool?), int? page = default(int?), int? limit = default(int?), string? not = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get an archive of a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="archive">the git reference for download with attached archive format (e.g. master.zip)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RepoGetArchiveAsync(string owner, string repo, string archive, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get an archive of a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="archive">the git reference for download with attached archive format (e.g. master.zip)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RepoGetArchiveWithHttpInfoAsync(string owner, string repo, string archive, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Return all users that have write access and can be assigned to issues
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;User&gt;</returns>
        System.Threading.Tasks.Task<List<User>> RepoGetAssigneesAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Return all users that have write access and can be assigned to issues
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;User&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<User>>> RepoGetAssigneesWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Retrieve a specific branch from a repository, including its effective branch protection
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="branch">branch to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Branch</returns>
        System.Threading.Tasks.Task<Branch> RepoGetBranchAsync(string owner, string repo, string branch, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Retrieve a specific branch from a repository, including its effective branch protection
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="branch">branch to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Branch)</returns>
        System.Threading.Tasks.Task<ApiResponse<Branch>> RepoGetBranchWithHttpInfoAsync(string owner, string repo, string branch, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get a specific branch protection for the repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">name of protected branch</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BranchProtection</returns>
        System.Threading.Tasks.Task<BranchProtection> RepoGetBranchProtectionAsync(string owner, string repo, string name, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get a specific branch protection for the repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">name of protected branch</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BranchProtection)</returns>
        System.Threading.Tasks.Task<ApiResponse<BranchProtection>> RepoGetBranchProtectionWithHttpInfoAsync(string owner, string repo, string name, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get a repository by id
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">id of the repo to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Repository</returns>
        System.Threading.Tasks.Task<Repository> RepoGetByIDAsync(long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get a repository by id
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">id of the repo to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Repository)</returns>
        System.Threading.Tasks.Task<ApiResponse<Repository>> RepoGetByIDWithHttpInfoAsync(long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get a commit&#39;s combined status, by branch/tag/commit reference
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varRef">name of branch/tag/commit</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CombinedStatus</returns>
        System.Threading.Tasks.Task<CombinedStatus> RepoGetCombinedStatusByRefAsync(string owner, string repo, string varRef, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get a commit&#39;s combined status, by branch/tag/commit reference
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varRef">name of branch/tag/commit</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CombinedStatus)</returns>
        System.Threading.Tasks.Task<ApiResponse<CombinedStatus>> RepoGetCombinedStatusByRefWithHttpInfoAsync(string owner, string repo, string varRef, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get the pull request of the commit
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">SHA of the commit to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PullRequest</returns>
        System.Threading.Tasks.Task<PullRequest> RepoGetCommitPullRequestAsync(string owner, string repo, string sha, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get the pull request of the commit
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">SHA of the commit to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PullRequest)</returns>
        System.Threading.Tasks.Task<ApiResponse<PullRequest>> RepoGetCommitPullRequestWithHttpInfoAsync(string owner, string repo, string sha, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">path of the dir, file, symlink or submodule in the repo</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ContentsResponse</returns>
        System.Threading.Tasks.Task<ContentsResponse> RepoGetContentsAsync(string owner, string repo, string filepath, string? varRef = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">path of the dir, file, symlink or submodule in the repo</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ContentsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<ContentsResponse>> RepoGetContentsWithHttpInfoAsync(string owner, string repo, string filepath, string? varRef = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Gets the metadata of all the entries of the root dir
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;ContentsResponse&gt;</returns>
        System.Threading.Tasks.Task<List<ContentsResponse>> RepoGetContentsListAsync(string owner, string repo, string? varRef = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Gets the metadata of all the entries of the root dir
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;ContentsResponse&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<ContentsResponse>>> RepoGetContentsListWithHttpInfoAsync(string owner, string repo, string? varRef = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get the EditorConfig definitions of a file in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">filepath of file to get</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RepoGetEditorConfigAsync(string owner, string repo, string filepath, string? varRef = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get the EditorConfig definitions of a file in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">filepath of file to get</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RepoGetEditorConfigWithHttpInfoAsync(string owner, string repo, string filepath, string? varRef = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get a Git hook
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GitHook</returns>
        System.Threading.Tasks.Task<GitHook> RepoGetGitHookAsync(string owner, string repo, string id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get a Git hook
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GitHook)</returns>
        System.Threading.Tasks.Task<ApiResponse<GitHook>> RepoGetGitHookWithHttpInfoAsync(string owner, string repo, string id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get a hook
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Hook</returns>
        System.Threading.Tasks.Task<Hook> RepoGetHookAsync(string owner, string repo, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get a hook
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Hook)</returns>
        System.Threading.Tasks.Task<ApiResponse<Hook>> RepoGetHookWithHttpInfoAsync(string owner, string repo, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Returns the issue config for a repo
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of IssueConfig</returns>
        System.Threading.Tasks.Task<IssueConfig> RepoGetIssueConfigAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Returns the issue config for a repo
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (IssueConfig)</returns>
        System.Threading.Tasks.Task<ApiResponse<IssueConfig>> RepoGetIssueConfigWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get available issue templates for a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;IssueTemplate&gt;</returns>
        System.Threading.Tasks.Task<List<IssueTemplate>> RepoGetIssueTemplatesAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get available issue templates for a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;IssueTemplate&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<IssueTemplate>>> RepoGetIssueTemplatesWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get a repository&#39;s key by id
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the key to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of DeployKey</returns>
        System.Threading.Tasks.Task<DeployKey> RepoGetKeyAsync(string owner, string repo, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get a repository&#39;s key by id
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the key to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (DeployKey)</returns>
        System.Threading.Tasks.Task<ApiResponse<DeployKey>> RepoGetKeyWithHttpInfoAsync(string owner, string repo, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get languages and number of bytes of code written
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Dictionary&lt;string, long&gt;</returns>
        System.Threading.Tasks.Task<Dictionary<string, long>> RepoGetLanguagesAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get languages and number of bytes of code written
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Dictionary&lt;string, long&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<Dictionary<string, long>>> RepoGetLanguagesWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Gets the most recent non-prerelease, non-draft release of a repository, sorted by created_at
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Release</returns>
        System.Threading.Tasks.Task<Release> RepoGetLatestReleaseAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Gets the most recent non-prerelease, non-draft release of a repository, sorted by created_at
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Release)</returns>
        System.Threading.Tasks.Task<ApiResponse<Release>> RepoGetLatestReleaseWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get a note corresponding to a single commit from a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">a git ref or commit sha</param>
        /// <param name="verification">include verification for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="files">include a list of affected files for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Note</returns>
        System.Threading.Tasks.Task<Note> RepoGetNoteAsync(string owner, string repo, string sha, bool? verification = default(bool?), bool? files = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get a note corresponding to a single commit from a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">a git ref or commit sha</param>
        /// <param name="verification">include verification for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="files">include a list of affected files for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Note)</returns>
        System.Threading.Tasks.Task<ApiResponse<Note>> RepoGetNoteWithHttpInfoAsync(string owner, string repo, string sha, bool? verification = default(bool?), bool? files = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PullRequest</returns>
        System.Threading.Tasks.Task<PullRequest> RepoGetPullRequestAsync(string owner, string repo, long index, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PullRequest)</returns>
        System.Threading.Tasks.Task<ApiResponse<PullRequest>> RepoGetPullRequestWithHttpInfoAsync(string owner, string repo, long index, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get a pull request by base and head
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varBase">base of the pull request to get</param>
        /// <param name="head">head of the pull request to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PullRequest</returns>
        System.Threading.Tasks.Task<PullRequest> RepoGetPullRequestByBaseHeadAsync(string owner, string repo, string varBase, string head, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get a pull request by base and head
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varBase">base of the pull request to get</param>
        /// <param name="head">head of the pull request to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PullRequest)</returns>
        System.Threading.Tasks.Task<ApiResponse<PullRequest>> RepoGetPullRequestByBaseHeadWithHttpInfoAsync(string owner, string repo, string varBase, string head, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get commits for a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="verification">include verification for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="files">include a list of affected files for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Commit&gt;</returns>
        System.Threading.Tasks.Task<List<Commit>> RepoGetPullRequestCommitsAsync(string owner, string repo, long index, int? page = default(int?), int? limit = default(int?), bool? verification = default(bool?), bool? files = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get commits for a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="verification">include verification for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="files">include a list of affected files for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Commit&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<Commit>>> RepoGetPullRequestCommitsWithHttpInfoAsync(string owner, string repo, long index, int? page = default(int?), int? limit = default(int?), bool? verification = default(bool?), bool? files = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get changed files for a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="skipTo">skip to given file (optional)</param>
        /// <param name="whitespace">whitespace behavior (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;ChangedFile&gt;</returns>
        System.Threading.Tasks.Task<List<ChangedFile>> RepoGetPullRequestFilesAsync(string owner, string repo, long index, string? skipTo = default(string?), string? whitespace = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get changed files for a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="skipTo">skip to given file (optional)</param>
        /// <param name="whitespace">whitespace behavior (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;ChangedFile&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<ChangedFile>>> RepoGetPullRequestFilesWithHttpInfoAsync(string owner, string repo, long index, string? skipTo = default(string?), string? whitespace = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get a specific review for a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PullReview</returns>
        System.Threading.Tasks.Task<PullReview> RepoGetPullReviewAsync(string owner, string repo, long index, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get a specific review for a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PullReview)</returns>
        System.Threading.Tasks.Task<ApiResponse<PullReview>> RepoGetPullReviewWithHttpInfoAsync(string owner, string repo, long index, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get a specific review for a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;PullReviewComment&gt;</returns>
        System.Threading.Tasks.Task<List<PullReviewComment>> RepoGetPullReviewCommentsAsync(string owner, string repo, long index, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get a specific review for a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;PullReviewComment&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<PullReviewComment>>> RepoGetPullReviewCommentsWithHttpInfoAsync(string owner, string repo, long index, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get push mirror of the repository by remoteName
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">remote name of push mirror</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PushMirror</returns>
        System.Threading.Tasks.Task<PushMirror> RepoGetPushMirrorByRemoteNameAsync(string owner, string repo, string name, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get push mirror of the repository by remoteName
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">remote name of push mirror</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PushMirror)</returns>
        System.Threading.Tasks.Task<ApiResponse<PushMirror>> RepoGetPushMirrorByRemoteNameWithHttpInfoAsync(string owner, string repo, string name, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get a file from a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">filepath of the file to get</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RepoGetRawFileAsync(string owner, string repo, string filepath, string? varRef = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get a file from a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">filepath of the file to get</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RepoGetRawFileWithHttpInfoAsync(string owner, string repo, string filepath, string? varRef = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get a file or it&#39;s LFS object from a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">filepath of the file to get</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RepoGetRawFileOrLFSAsync(string owner, string repo, string filepath, string? varRef = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get a file or it&#39;s LFS object from a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">filepath of the file to get</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RepoGetRawFileOrLFSWithHttpInfoAsync(string owner, string repo, string filepath, string? varRef = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get a release
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Release</returns>
        System.Threading.Tasks.Task<Release> RepoGetReleaseAsync(string owner, string repo, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get a release
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Release)</returns>
        System.Threading.Tasks.Task<ApiResponse<Release>> RepoGetReleaseWithHttpInfoAsync(string owner, string repo, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get a release attachment
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="attachmentId">id of the attachment to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Attachment</returns>
        System.Threading.Tasks.Task<Attachment> RepoGetReleaseAttachmentAsync(string owner, string repo, long id, long attachmentId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get a release attachment
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="attachmentId">id of the attachment to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Attachment)</returns>
        System.Threading.Tasks.Task<ApiResponse<Attachment>> RepoGetReleaseAttachmentWithHttpInfoAsync(string owner, string repo, long id, long attachmentId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get a release by tag name
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="tag">tag name of the release to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Release</returns>
        System.Threading.Tasks.Task<Release> RepoGetReleaseByTagAsync(string owner, string repo, string tag, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get a release by tag name
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="tag">tag name of the release to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Release)</returns>
        System.Threading.Tasks.Task<ApiResponse<Release>> RepoGetReleaseByTagWithHttpInfoAsync(string owner, string repo, string tag, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get repository permissions for a user
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="collaborator">username of the collaborator</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of RepoCollaboratorPermission</returns>
        System.Threading.Tasks.Task<RepoCollaboratorPermission> RepoGetRepoPermissionsAsync(string owner, string repo, string collaborator, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get repository permissions for a user
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="collaborator">username of the collaborator</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (RepoCollaboratorPermission)</returns>
        System.Threading.Tasks.Task<ApiResponse<RepoCollaboratorPermission>> RepoGetRepoPermissionsWithHttpInfoAsync(string owner, string repo, string collaborator, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Return all users that can be requested to review in this repo
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;User&gt;</returns>
        System.Threading.Tasks.Task<List<User>> RepoGetReviewersAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Return all users that can be requested to review in this repo
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;User&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<User>>> RepoGetReviewersWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get a repository&#39;s actions runner registration token
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RepoGetRunnerRegistrationTokenAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get a repository&#39;s actions runner registration token
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RepoGetRunnerRegistrationTokenWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get a single commit from a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">a git ref or commit sha</param>
        /// <param name="stat">include diff stats for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="verification">include verification for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="files">include a list of affected files for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Commit</returns>
        System.Threading.Tasks.Task<Commit> RepoGetSingleCommitAsync(string owner, string repo, string sha, bool? stat = default(bool?), bool? verification = default(bool?), bool? files = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get a single commit from a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">a git ref or commit sha</param>
        /// <param name="stat">include diff stats for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="verification">include verification for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="files">include a list of affected files for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Commit)</returns>
        System.Threading.Tasks.Task<ApiResponse<Commit>> RepoGetSingleCommitWithHttpInfoAsync(string owner, string repo, string sha, bool? stat = default(bool?), bool? verification = default(bool?), bool? files = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get the tag of a repository by tag name
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="tag">name of tag</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Tag</returns>
        System.Threading.Tasks.Task<Tag> RepoGetTagAsync(string owner, string repo, string tag, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get the tag of a repository by tag name
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="tag">name of tag</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Tag)</returns>
        System.Threading.Tasks.Task<ApiResponse<Tag>> RepoGetTagWithHttpInfoAsync(string owner, string repo, string tag, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get a wiki page
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="pageName">name of the page</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of WikiPage</returns>
        System.Threading.Tasks.Task<WikiPage> RepoGetWikiPageAsync(string owner, string repo, string pageName, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get a wiki page
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="pageName">name of the page</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (WikiPage)</returns>
        System.Threading.Tasks.Task<ApiResponse<WikiPage>> RepoGetWikiPageWithHttpInfoAsync(string owner, string repo, string pageName, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get revisions of a wiki page
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="pageName">name of the page</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of WikiCommitList</returns>
        System.Threading.Tasks.Task<WikiCommitList> RepoGetWikiPageRevisionsAsync(string owner, string repo, string pageName, int? page = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get revisions of a wiki page
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="pageName">name of the page</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (WikiCommitList)</returns>
        System.Threading.Tasks.Task<ApiResponse<WikiCommitList>> RepoGetWikiPageRevisionsWithHttpInfoAsync(string owner, string repo, string pageName, int? page = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get all wiki pages
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;WikiPageMetaData&gt;</returns>
        System.Threading.Tasks.Task<List<WikiPageMetaData>> RepoGetWikiPagesAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get all wiki pages
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;WikiPageMetaData&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<WikiPageMetaData>>> RepoGetWikiPagesWithHttpInfoAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// List an repo&#39;s actions secrets
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repository</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Secret&gt;</returns>
        System.Threading.Tasks.Task<List<Secret>> RepoListActionsSecretsAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// List an repo&#39;s actions secrets
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repository</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Secret&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<Secret>>> RepoListActionsSecretsWithHttpInfoAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// List a repository&#39;s activity feeds
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="date">the date of the activities to be found (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Activity&gt;</returns>
        System.Threading.Tasks.Task<List<Activity>> RepoListActivityFeedsAsync(string owner, string repo, DateOnly? date = default(DateOnly?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// List a repository&#39;s activity feeds
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="date">the date of the activities to be found (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Activity&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<Activity>>> RepoListActivityFeedsWithHttpInfoAsync(string owner, string repo, DateOnly? date = default(DateOnly?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get specified ref or filtered repository&#39;s refs
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Reference&gt;</returns>
        System.Threading.Tasks.Task<List<Reference>> RepoListAllGitRefsAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get specified ref or filtered repository&#39;s refs
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Reference&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<Reference>>> RepoListAllGitRefsWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// List branch protections for a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;BranchProtection&gt;</returns>
        System.Threading.Tasks.Task<List<BranchProtection>> RepoListBranchProtectionAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// List branch protections for a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;BranchProtection&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<BranchProtection>>> RepoListBranchProtectionWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// List a repository&#39;s branches
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Branch&gt;</returns>
        System.Threading.Tasks.Task<List<Branch>> RepoListBranchesAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// List a repository&#39;s branches
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Branch&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<Branch>>> RepoListBranchesWithHttpInfoAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// List a repository&#39;s collaborators
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;User&gt;</returns>
        System.Threading.Tasks.Task<List<User>> RepoListCollaboratorsAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// List a repository&#39;s collaborators
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;User&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<User>>> RepoListCollaboratorsWithHttpInfoAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// List the Git hooks in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;GitHook&gt;</returns>
        System.Threading.Tasks.Task<List<GitHook>> RepoListGitHooksAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// List the Git hooks in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;GitHook&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<GitHook>>> RepoListGitHooksWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get specified ref or filtered repository&#39;s refs
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varRef">part or full name of the ref</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Reference&gt;</returns>
        System.Threading.Tasks.Task<List<Reference>> RepoListGitRefsAsync(string owner, string repo, string varRef, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get specified ref or filtered repository&#39;s refs
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varRef">part or full name of the ref</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Reference&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<Reference>>> RepoListGitRefsWithHttpInfoAsync(string owner, string repo, string varRef, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// List the hooks in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Hook&gt;</returns>
        System.Threading.Tasks.Task<List<Hook>> RepoListHooksAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// List the hooks in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Hook&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<Hook>>> RepoListHooksWithHttpInfoAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// List a repository&#39;s keys
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="keyId">the key_id to search for (optional)</param>
        /// <param name="fingerprint">fingerprint of the key (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;DeployKey&gt;</returns>
        System.Threading.Tasks.Task<List<DeployKey>> RepoListKeysAsync(string owner, string repo, int? keyId = default(int?), string? fingerprint = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// List a repository&#39;s keys
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="keyId">the key_id to search for (optional)</param>
        /// <param name="fingerprint">fingerprint of the key (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;DeployKey&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<DeployKey>>> RepoListKeysWithHttpInfoAsync(string owner, string repo, int? keyId = default(int?), string? fingerprint = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// List a repo&#39;s pinned issues
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Issue&gt;</returns>
        System.Threading.Tasks.Task<List<Issue>> RepoListPinnedIssuesAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// List a repo&#39;s pinned issues
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Issue&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<Issue>>> RepoListPinnedIssuesWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// List a repo&#39;s pinned pull requests
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;PullRequest&gt;</returns>
        System.Threading.Tasks.Task<List<PullRequest>> RepoListPinnedPullRequestsAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// List a repo&#39;s pinned pull requests
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;PullRequest&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<PullRequest>>> RepoListPinnedPullRequestsWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// List a repo&#39;s pull requests
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="state">State of pull request: open or closed (optional) (optional)</param>
        /// <param name="sort">Type of sort (optional)</param>
        /// <param name="milestone">ID of the milestone (optional)</param>
        /// <param name="labels">Label IDs (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;PullRequest&gt;</returns>
        System.Threading.Tasks.Task<List<PullRequest>> RepoListPullRequestsAsync(string owner, string repo, string? state = default(string?), string? sort = default(string?), long? milestone = default(long?), List<long>? labels = default(List<long>?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// List a repo&#39;s pull requests
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="state">State of pull request: open or closed (optional) (optional)</param>
        /// <param name="sort">Type of sort (optional)</param>
        /// <param name="milestone">ID of the milestone (optional)</param>
        /// <param name="labels">Label IDs (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;PullRequest&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<PullRequest>>> RepoListPullRequestsWithHttpInfoAsync(string owner, string repo, string? state = default(string?), string? sort = default(string?), long? milestone = default(long?), List<long>? labels = default(List<long>?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// List all reviews for a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;PullReview&gt;</returns>
        System.Threading.Tasks.Task<List<PullReview>> RepoListPullReviewsAsync(string owner, string repo, long index, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// List all reviews for a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;PullReview&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<PullReview>>> RepoListPullReviewsWithHttpInfoAsync(string owner, string repo, long index, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get all push mirrors of the repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;PushMirror&gt;</returns>
        System.Threading.Tasks.Task<List<PushMirror>> RepoListPushMirrorsAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get all push mirrors of the repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;PushMirror&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<PushMirror>>> RepoListPushMirrorsWithHttpInfoAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// List release&#39;s attachments
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Attachment&gt;</returns>
        System.Threading.Tasks.Task<List<Attachment>> RepoListReleaseAttachmentsAsync(string owner, string repo, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// List release&#39;s attachments
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Attachment&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<Attachment>>> RepoListReleaseAttachmentsWithHttpInfoAsync(string owner, string repo, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// List a repo&#39;s releases
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="draft">filter (exclude / include) drafts, if you dont have repo write access none will show (optional)</param>
        /// <param name="preRelease">filter (exclude / include) pre-releases (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Release&gt;</returns>
        System.Threading.Tasks.Task<List<Release>> RepoListReleasesAsync(string owner, string repo, bool? draft = default(bool?), bool? preRelease = default(bool?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// List a repo&#39;s releases
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="draft">filter (exclude / include) drafts, if you dont have repo write access none will show (optional)</param>
        /// <param name="preRelease">filter (exclude / include) pre-releases (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Release&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<Release>>> RepoListReleasesWithHttpInfoAsync(string owner, string repo, bool? draft = default(bool?), bool? preRelease = default(bool?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// List a repo&#39;s stargazers
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;User&gt;</returns>
        System.Threading.Tasks.Task<List<User>> RepoListStargazersAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// List a repo&#39;s stargazers
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;User&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<User>>> RepoListStargazersWithHttpInfoAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get a commit&#39;s statuses
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the commit</param>
        /// <param name="sort">type of sort (optional)</param>
        /// <param name="state">type of state (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;CommitStatus&gt;</returns>
        System.Threading.Tasks.Task<List<CommitStatus>> RepoListStatusesAsync(string owner, string repo, string sha, string? sort = default(string?), string? state = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get a commit&#39;s statuses
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the commit</param>
        /// <param name="sort">type of sort (optional)</param>
        /// <param name="state">type of state (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;CommitStatus&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<CommitStatus>>> RepoListStatusesWithHttpInfoAsync(string owner, string repo, string sha, string? sort = default(string?), string? state = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get a commit&#39;s statuses, by branch/tag/commit reference
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varRef">name of branch/tag/commit</param>
        /// <param name="sort">type of sort (optional)</param>
        /// <param name="state">type of state (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;CommitStatus&gt;</returns>
        System.Threading.Tasks.Task<List<CommitStatus>> RepoListStatusesByRefAsync(string owner, string repo, string varRef, string? sort = default(string?), string? state = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get a commit&#39;s statuses, by branch/tag/commit reference
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varRef">name of branch/tag/commit</param>
        /// <param name="sort">type of sort (optional)</param>
        /// <param name="state">type of state (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;CommitStatus&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<CommitStatus>>> RepoListStatusesByRefWithHttpInfoAsync(string owner, string repo, string varRef, string? sort = default(string?), string? state = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// List a repo&#39;s watchers
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;User&gt;</returns>
        System.Threading.Tasks.Task<List<User>> RepoListSubscribersAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// List a repo&#39;s watchers
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;User&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<User>>> RepoListSubscribersWithHttpInfoAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// List a repository&#39;s tags
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results, default maximum page size is 50 (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Tag&gt;</returns>
        System.Threading.Tasks.Task<List<Tag>> RepoListTagsAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// List a repository&#39;s tags
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results, default maximum page size is 50 (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Tag&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<Tag>>> RepoListTagsWithHttpInfoAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// List a repository&#39;s teams
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Team&gt;</returns>
        System.Threading.Tasks.Task<List<Team>> RepoListTeamsAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// List a repository&#39;s teams
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Team&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<Team>>> RepoListTeamsWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get list of topics that a repository has
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TopicName</returns>
        System.Threading.Tasks.Task<TopicName> RepoListTopicsAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get list of topics that a repository has
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TopicName)</returns>
        System.Threading.Tasks.Task<ApiResponse<TopicName>> RepoListTopicsWithHttpInfoAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Merge a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to merge</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RepoMergePullRequestAsync(string owner, string repo, long index, MergePullRequestOption? body = default(MergePullRequestOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Merge a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to merge</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RepoMergePullRequestWithHttpInfoAsync(string owner, string repo, long index, MergePullRequestOption? body = default(MergePullRequestOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Migrate a remote git repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Repository</returns>
        System.Threading.Tasks.Task<Repository> RepoMigrateAsync(MigrateRepoOptions? body = default(MigrateRepoOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Migrate a remote git repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Repository)</returns>
        System.Threading.Tasks.Task<ApiResponse<Repository>> RepoMigrateWithHttpInfoAsync(MigrateRepoOptions? body = default(MigrateRepoOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Sync a mirrored repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to sync</param>
        /// <param name="repo">name of the repo to sync</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RepoMirrorSyncAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Sync a mirrored repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to sync</param>
        /// <param name="repo">name of the repo to sync</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RepoMirrorSyncWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Returns if new Issue Pins are allowed
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of NewIssuePinsAllowed</returns>
        System.Threading.Tasks.Task<NewIssuePinsAllowed> RepoNewPinAllowedAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Returns if new Issue Pins are allowed
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (NewIssuePinsAllowed)</returns>
        System.Threading.Tasks.Task<ApiResponse<NewIssuePinsAllowed>> RepoNewPinAllowedWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Check if a pull request has been merged
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RepoPullRequestIsMergedAsync(string owner, string repo, long index, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Check if a pull request has been merged
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RepoPullRequestIsMergedWithHttpInfoAsync(string owner, string repo, long index, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Sync all push mirrored repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to sync</param>
        /// <param name="repo">name of the repo to sync</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RepoPushMirrorSyncAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Sync all push mirrored repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to sync</param>
        /// <param name="repo">name of the repo to sync</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RepoPushMirrorSyncWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Search for repositories
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">keyword (optional)</param>
        /// <param name="topic">Limit search to repositories with keyword as topic (optional)</param>
        /// <param name="includeDesc">include search of keyword within repository description (optional)</param>
        /// <param name="uid">search only for repos that the user with the given id owns or contributes to (optional)</param>
        /// <param name="priorityOwnerId">repo owner to prioritize in the results (optional)</param>
        /// <param name="teamId">search only for repos that belong to the given team id (optional)</param>
        /// <param name="starredBy">search only for repos that the user with the given id has starred (optional)</param>
        /// <param name="varPrivate">include private repositories this user has access to (defaults to true) (optional)</param>
        /// <param name="isPrivate">show only pubic, private or all repositories (defaults to all) (optional)</param>
        /// <param name="template">include template repositories this user has access to (defaults to true) (optional)</param>
        /// <param name="archived">show only archived, non-archived or all repositories (defaults to all) (optional)</param>
        /// <param name="mode">type of repository to search for. Supported values are \&quot;fork\&quot;, \&quot;source\&quot;, \&quot;mirror\&quot; and \&quot;collaborative\&quot; (optional)</param>
        /// <param name="exclusive">if &#x60;uid&#x60; is given, search only for repos that the user owns (optional)</param>
        /// <param name="sort">sort repos by attribute. Supported values are \&quot;alpha\&quot;, \&quot;created\&quot;, \&quot;updated\&quot;, \&quot;size\&quot;, and \&quot;id\&quot;. Default is \&quot;alpha\&quot; (optional)</param>
        /// <param name="order">sort order, either \&quot;asc\&quot; (ascending) or \&quot;desc\&quot; (descending). Default is \&quot;asc\&quot;, ignored if \&quot;sort\&quot; is not specified. (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SearchResults</returns>
        System.Threading.Tasks.Task<SearchResults> RepoSearchAsync(string? q = default(string?), bool? topic = default(bool?), bool? includeDesc = default(bool?), long? uid = default(long?), long? priorityOwnerId = default(long?), long? teamId = default(long?), long? starredBy = default(long?), bool? varPrivate = default(bool?), bool? isPrivate = default(bool?), bool? template = default(bool?), bool? archived = default(bool?), string? mode = default(string?), bool? exclusive = default(bool?), string? sort = default(string?), string? order = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Search for repositories
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">keyword (optional)</param>
        /// <param name="topic">Limit search to repositories with keyword as topic (optional)</param>
        /// <param name="includeDesc">include search of keyword within repository description (optional)</param>
        /// <param name="uid">search only for repos that the user with the given id owns or contributes to (optional)</param>
        /// <param name="priorityOwnerId">repo owner to prioritize in the results (optional)</param>
        /// <param name="teamId">search only for repos that belong to the given team id (optional)</param>
        /// <param name="starredBy">search only for repos that the user with the given id has starred (optional)</param>
        /// <param name="varPrivate">include private repositories this user has access to (defaults to true) (optional)</param>
        /// <param name="isPrivate">show only pubic, private or all repositories (defaults to all) (optional)</param>
        /// <param name="template">include template repositories this user has access to (defaults to true) (optional)</param>
        /// <param name="archived">show only archived, non-archived or all repositories (defaults to all) (optional)</param>
        /// <param name="mode">type of repository to search for. Supported values are \&quot;fork\&quot;, \&quot;source\&quot;, \&quot;mirror\&quot; and \&quot;collaborative\&quot; (optional)</param>
        /// <param name="exclusive">if &#x60;uid&#x60; is given, search only for repos that the user owns (optional)</param>
        /// <param name="sort">sort repos by attribute. Supported values are \&quot;alpha\&quot;, \&quot;created\&quot;, \&quot;updated\&quot;, \&quot;size\&quot;, and \&quot;id\&quot;. Default is \&quot;alpha\&quot; (optional)</param>
        /// <param name="order">sort order, either \&quot;asc\&quot; (ascending) or \&quot;desc\&quot; (descending). Default is \&quot;asc\&quot;, ignored if \&quot;sort\&quot; is not specified. (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SearchResults)</returns>
        System.Threading.Tasks.Task<ApiResponse<SearchResults>> RepoSearchWithHttpInfoAsync(string? q = default(string?), bool? topic = default(bool?), bool? includeDesc = default(bool?), long? uid = default(long?), long? priorityOwnerId = default(long?), long? teamId = default(long?), long? starredBy = default(long?), bool? varPrivate = default(bool?), bool? isPrivate = default(bool?), bool? template = default(bool?), bool? archived = default(bool?), string? mode = default(string?), bool? exclusive = default(bool?), string? sort = default(string?), string? order = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get signing-key.gpg for given repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> RepoSigningKeyAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get signing-key.gpg for given repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> RepoSigningKeyWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Submit a pending review to an pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PullReview</returns>
        System.Threading.Tasks.Task<PullReview> RepoSubmitPullReviewAsync(string owner, string repo, long index, long id, SubmitPullReviewOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Submit a pending review to an pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PullReview)</returns>
        System.Threading.Tasks.Task<ApiResponse<PullReview>> RepoSubmitPullReviewWithHttpInfoAsync(string owner, string repo, long index, long id, SubmitPullReviewOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Test a push webhook
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to test</param>
        /// <param name="varRef">The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RepoTestHookAsync(string owner, string repo, long id, string? varRef = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Test a push webhook
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to test</param>
        /// <param name="varRef">The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RepoTestHookWithHttpInfoAsync(string owner, string repo, long id, string? varRef = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// List a repo&#39;s tracked times
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="user">optional filter by user (available for issue managers) (optional)</param>
        /// <param name="since">Only show times updated after the given time. This is a timestamp in RFC 3339 format (optional)</param>
        /// <param name="before">Only show times updated before the given time. This is a timestamp in RFC 3339 format (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;TrackedTime&gt;</returns>
        System.Threading.Tasks.Task<List<TrackedTime>> RepoTrackedTimesAsync(string owner, string repo, string? user = default(string?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// List a repo&#39;s tracked times
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="user">optional filter by user (available for issue managers) (optional)</param>
        /// <param name="since">Only show times updated after the given time. This is a timestamp in RFC 3339 format (optional)</param>
        /// <param name="before">Only show times updated before the given time. This is a timestamp in RFC 3339 format (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;TrackedTime&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<TrackedTime>>> RepoTrackedTimesWithHttpInfoAsync(string owner, string repo, string? user = default(string?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Transfer a repo ownership
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to transfer</param>
        /// <param name="repo">name of the repo to transfer</param>
        /// <param name="body">Transfer Options</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Repository</returns>
        System.Threading.Tasks.Task<Repository> RepoTransferAsync(string owner, string repo, TransferRepoOption body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Transfer a repo ownership
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to transfer</param>
        /// <param name="repo">name of the repo to transfer</param>
        /// <param name="body">Transfer Options</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Repository)</returns>
        System.Threading.Tasks.Task<ApiResponse<Repository>> RepoTransferWithHttpInfoAsync(string owner, string repo, TransferRepoOption body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Cancel to dismiss a review for a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PullReview</returns>
        System.Threading.Tasks.Task<PullReview> RepoUnDismissPullReviewAsync(string owner, string repo, long index, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Cancel to dismiss a review for a pull request
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PullReview)</returns>
        System.Threading.Tasks.Task<ApiResponse<PullReview>> RepoUnDismissPullReviewWithHttpInfoAsync(string owner, string repo, long index, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Update avatar
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RepoUpdateAvatarAsync(string owner, string repo, UpdateRepoAvatarOption? body = default(UpdateRepoAvatarOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Update avatar
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RepoUpdateAvatarWithHttpInfoAsync(string owner, string repo, UpdateRepoAvatarOption? body = default(UpdateRepoAvatarOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Update a file in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">path of the file to update</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of FileResponse</returns>
        System.Threading.Tasks.Task<FileResponse> RepoUpdateFileAsync(string owner, string repo, string filepath, UpdateFileOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Update a file in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">path of the file to update</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (FileResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<FileResponse>> RepoUpdateFileWithHttpInfoAsync(string owner, string repo, string filepath, UpdateFileOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Merge PR&#39;s baseBranch into headBranch
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="style">how to update pull request (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RepoUpdatePullRequestAsync(string owner, string repo, long index, string? style = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Merge PR&#39;s baseBranch into headBranch
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="style">how to update pull request (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RepoUpdatePullRequestWithHttpInfoAsync(string owner, string repo, long index, string? style = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Replace list of topics for a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RepoUpdateTopicsAsync(string owner, string repo, RepoTopicOptions? body = default(RepoTopicOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Replace list of topics for a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RepoUpdateTopicsWithHttpInfoAsync(string owner, string repo, RepoTopicOptions? body = default(RepoTopicOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Returns the validation information for a issue config
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of IssueConfigValidation</returns>
        System.Threading.Tasks.Task<IssueConfigValidation> RepoValidateIssueConfigAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Returns the validation information for a issue config
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (IssueConfigValidation)</returns>
        System.Threading.Tasks.Task<ApiResponse<IssueConfigValidation>> RepoValidateIssueConfigWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// search topics via keyword
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">keywords to search</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;TopicResponse&gt;</returns>
        System.Threading.Tasks.Task<List<TopicResponse>> TopicSearchAsync(string q, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// search topics via keyword
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">keywords to search</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;TopicResponse&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<TopicResponse>>> TopicSearchWithHttpInfoAsync(string q, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Create or Update a secret value in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repository</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="secretname">name of the secret</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UpdateRepoSecretAsync(string owner, string repo, string secretname, CreateOrUpdateSecretOption? body = default(CreateOrUpdateSecretOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Create or Update a secret value in a repository
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repository</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="secretname">name of the secret</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UpdateRepoSecretWithHttpInfoAsync(string owner, string repo, string secretname, CreateOrUpdateSecretOption? body = default(CreateOrUpdateSecretOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Update a repo-level variable
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="variablename">name of the variable</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UpdateRepoVariableAsync(string owner, string repo, string variablename, UpdateVariableOption? body = default(UpdateVariableOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Update a repo-level variable
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="variablename">name of the variable</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UpdateRepoVariableWithHttpInfoAsync(string owner, string repo, string variablename, UpdateVariableOption? body = default(UpdateVariableOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Check if the current user is watching a repo
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of WatchInfo</returns>
        System.Threading.Tasks.Task<WatchInfo> UserCurrentCheckSubscriptionAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Check if the current user is watching a repo
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (WatchInfo)</returns>
        System.Threading.Tasks.Task<ApiResponse<WatchInfo>> UserCurrentCheckSubscriptionWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Unwatch a repo
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UserCurrentDeleteSubscriptionAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Unwatch a repo
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UserCurrentDeleteSubscriptionWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Watch a repo
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of WatchInfo</returns>
        System.Threading.Tasks.Task<WatchInfo> UserCurrentPutSubscriptionAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Watch a repo
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (WatchInfo)</returns>
        System.Threading.Tasks.Task<ApiResponse<WatchInfo>> UserCurrentPutSubscriptionWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// List a user&#39;s tracked times in a repo
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="user">username of user</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;TrackedTime&gt;</returns>
        [Obsolete]
        System.Threading.Tasks.Task<List<TrackedTime>> UserTrackedTimesAsync(string owner, string repo, string user, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// List a user&#39;s tracked times in a repo
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="user">username of user</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;TrackedTime&gt;)</returns>
        [Obsolete]
        System.Threading.Tasks.Task<ApiResponse<List<TrackedTime>>> UserTrackedTimesWithHttpInfoAsync(string owner, string repo, string user, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IRepositoryApi : IRepositoryApiSync, IRepositoryApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class RepositoryApi : IRepositoryApi
    {
        private Org.OpenAPITools.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryApi"/> class.
        /// </summary>
        /// <returns></returns>
        public RepositoryApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryApi"/> class.
        /// </summary>
        /// <returns></returns>
        public RepositoryApi(string basePath)
        {
            this.Configuration = Org.OpenAPITools.Client.Configuration.MergeConfigurations(
                Org.OpenAPITools.Client.GlobalConfiguration.Instance,
                new Org.OpenAPITools.Client.Configuration { BasePath = basePath }
            );
            this.Client = new Org.OpenAPITools.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Org.OpenAPITools.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = Org.OpenAPITools.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public RepositoryApi(Org.OpenAPITools.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = Org.OpenAPITools.Client.Configuration.MergeConfigurations(
                Org.OpenAPITools.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new Org.OpenAPITools.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Org.OpenAPITools.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = Org.OpenAPITools.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RepositoryApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public RepositoryApi(Org.OpenAPITools.Client.ISynchronousClient client, Org.OpenAPITools.Client.IAsynchronousClient asyncClient, Org.OpenAPITools.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = Org.OpenAPITools.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public Org.OpenAPITools.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public Org.OpenAPITools.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Org.OpenAPITools.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Org.OpenAPITools.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Accept a repo transfer 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to transfer</param>
        /// <param name="repo">name of the repo to transfer</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Repository</returns>
        public Repository AcceptRepoTransfer(string owner, string repo, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<Repository> localVarResponse = AcceptRepoTransferWithHttpInfo(owner, repo);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Accept a repo transfer 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to transfer</param>
        /// <param name="repo">name of the repo to transfer</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Repository</returns>
        public Org.OpenAPITools.Client.ApiResponse<Repository> AcceptRepoTransferWithHttpInfo(string owner, string repo, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->AcceptRepoTransfer");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->AcceptRepoTransfer");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.AcceptRepoTransfer";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Repository>("/repos/{owner}/{repo}/transfer/accept", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("AcceptRepoTransfer", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Accept a repo transfer 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to transfer</param>
        /// <param name="repo">name of the repo to transfer</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Repository</returns>
        public async System.Threading.Tasks.Task<Repository> AcceptRepoTransferAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<Repository> localVarResponse = await AcceptRepoTransferWithHttpInfoAsync(owner, repo, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Accept a repo transfer 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to transfer</param>
        /// <param name="repo">name of the repo to transfer</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Repository)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Repository>> AcceptRepoTransferWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->AcceptRepoTransfer");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->AcceptRepoTransfer");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.AcceptRepoTransfer";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Repository>("/repos/{owner}/{repo}/transfer/accept", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("AcceptRepoTransfer", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Repository</returns>
        public Repository CreateCurrentUserRepo(CreateRepoOption? body = default(CreateRepoOption?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<Repository> localVarResponse = CreateCurrentUserRepoWithHttpInfo(body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Repository</returns>
        public Org.OpenAPITools.Client.ApiResponse<Repository> CreateCurrentUserRepoWithHttpInfo(CreateRepoOption? body = default(CreateRepoOption?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.CreateCurrentUserRepo";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Repository>("/user/repos", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateCurrentUserRepo", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Repository</returns>
        public async System.Threading.Tasks.Task<Repository> CreateCurrentUserRepoAsync(CreateRepoOption? body = default(CreateRepoOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<Repository> localVarResponse = await CreateCurrentUserRepoWithHttpInfoAsync(body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Repository)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Repository>> CreateCurrentUserRepoWithHttpInfoAsync(CreateRepoOption? body = default(CreateRepoOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.CreateCurrentUserRepo";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Repository>("/user/repos", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateCurrentUserRepo", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Fork a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to fork</param>
        /// <param name="repo">name of the repo to fork</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Repository</returns>
        public Repository CreateFork(string owner, string repo, CreateForkOption? body = default(CreateForkOption?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<Repository> localVarResponse = CreateForkWithHttpInfo(owner, repo, body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Fork a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to fork</param>
        /// <param name="repo">name of the repo to fork</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Repository</returns>
        public Org.OpenAPITools.Client.ApiResponse<Repository> CreateForkWithHttpInfo(string owner, string repo, CreateForkOption? body = default(CreateForkOption?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->CreateFork");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->CreateFork");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json",
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.CreateFork";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Repository>("/repos/{owner}/{repo}/forks", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateFork", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Fork a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to fork</param>
        /// <param name="repo">name of the repo to fork</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Repository</returns>
        public async System.Threading.Tasks.Task<Repository> CreateForkAsync(string owner, string repo, CreateForkOption? body = default(CreateForkOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<Repository> localVarResponse = await CreateForkWithHttpInfoAsync(owner, repo, body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Fork a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to fork</param>
        /// <param name="repo">name of the repo to fork</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Repository)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Repository>> CreateForkWithHttpInfoAsync(string owner, string repo, CreateForkOption? body = default(CreateForkOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->CreateFork");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->CreateFork");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json", 
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.CreateFork";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Repository>("/repos/{owner}/{repo}/forks", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateFork", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a repo-level variable 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="variablename">name of the variable</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void CreateRepoVariable(string owner, string repo, string variablename, CreateVariableOption? body = default(CreateVariableOption?), int operationIndex = 0)
        {
            CreateRepoVariableWithHttpInfo(owner, repo, variablename, body);
        }

        /// <summary>
        /// Create a repo-level variable 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="variablename">name of the variable</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> CreateRepoVariableWithHttpInfo(string owner, string repo, string variablename, CreateVariableOption? body = default(CreateVariableOption?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->CreateRepoVariable");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->CreateRepoVariable");
            }

            // verify the required parameter 'variablename' is set
            if (variablename == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'variablename' when calling RepositoryApi->CreateRepoVariable");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json",
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("variablename", Org.OpenAPITools.Client.ClientUtils.ParameterToString(variablename)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.CreateRepoVariable";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/repos/{owner}/{repo}/actions/variables/{variablename}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateRepoVariable", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a repo-level variable 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="variablename">name of the variable</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task CreateRepoVariableAsync(string owner, string repo, string variablename, CreateVariableOption? body = default(CreateVariableOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await CreateRepoVariableWithHttpInfoAsync(owner, repo, variablename, body, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Create a repo-level variable 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="variablename">name of the variable</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> CreateRepoVariableWithHttpInfoAsync(string owner, string repo, string variablename, CreateVariableOption? body = default(CreateVariableOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->CreateRepoVariable");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->CreateRepoVariable");
            }

            // verify the required parameter 'variablename' is set
            if (variablename == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'variablename' when calling RepositoryApi->CreateRepoVariable");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json", 
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("variablename", Org.OpenAPITools.Client.ClientUtils.ParameterToString(variablename)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.CreateRepoVariable";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/repos/{owner}/{repo}/actions/variables/{variablename}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateRepoVariable", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a secret in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repository</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="secretname">name of the secret</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void DeleteRepoSecret(string owner, string repo, string secretname, int operationIndex = 0)
        {
            DeleteRepoSecretWithHttpInfo(owner, repo, secretname);
        }

        /// <summary>
        /// Delete a secret in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repository</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="secretname">name of the secret</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> DeleteRepoSecretWithHttpInfo(string owner, string repo, string secretname, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->DeleteRepoSecret");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->DeleteRepoSecret");
            }

            // verify the required parameter 'secretname' is set
            if (secretname == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'secretname' when calling RepositoryApi->DeleteRepoSecret");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("secretname", Org.OpenAPITools.Client.ClientUtils.ParameterToString(secretname)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.DeleteRepoSecret";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/repos/{owner}/{repo}/actions/secrets/{secretname}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteRepoSecret", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a secret in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repository</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="secretname">name of the secret</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteRepoSecretAsync(string owner, string repo, string secretname, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await DeleteRepoSecretWithHttpInfoAsync(owner, repo, secretname, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Delete a secret in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repository</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="secretname">name of the secret</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> DeleteRepoSecretWithHttpInfoAsync(string owner, string repo, string secretname, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->DeleteRepoSecret");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->DeleteRepoSecret");
            }

            // verify the required parameter 'secretname' is set
            if (secretname == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'secretname' when calling RepositoryApi->DeleteRepoSecret");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("secretname", Org.OpenAPITools.Client.ClientUtils.ParameterToString(secretname)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.DeleteRepoSecret";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/repos/{owner}/{repo}/actions/secrets/{secretname}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteRepoSecret", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a repo-level variable 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="variablename">name of the variable</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ActionVariable</returns>
        public ActionVariable DeleteRepoVariable(string owner, string repo, string variablename, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<ActionVariable> localVarResponse = DeleteRepoVariableWithHttpInfo(owner, repo, variablename);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Delete a repo-level variable 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="variablename">name of the variable</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ActionVariable</returns>
        public Org.OpenAPITools.Client.ApiResponse<ActionVariable> DeleteRepoVariableWithHttpInfo(string owner, string repo, string variablename, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->DeleteRepoVariable");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->DeleteRepoVariable");
            }

            // verify the required parameter 'variablename' is set
            if (variablename == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'variablename' when calling RepositoryApi->DeleteRepoVariable");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("variablename", Org.OpenAPITools.Client.ClientUtils.ParameterToString(variablename)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.DeleteRepoVariable";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<ActionVariable>("/repos/{owner}/{repo}/actions/variables/{variablename}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteRepoVariable", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a repo-level variable 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="variablename">name of the variable</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ActionVariable</returns>
        public async System.Threading.Tasks.Task<ActionVariable> DeleteRepoVariableAsync(string owner, string repo, string variablename, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<ActionVariable> localVarResponse = await DeleteRepoVariableWithHttpInfoAsync(owner, repo, variablename, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Delete a repo-level variable 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="variablename">name of the variable</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ActionVariable)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<ActionVariable>> DeleteRepoVariableWithHttpInfoAsync(string owner, string repo, string variablename, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->DeleteRepoVariable");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->DeleteRepoVariable");
            }

            // verify the required parameter 'variablename' is set
            if (variablename == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'variablename' when calling RepositoryApi->DeleteRepoVariable");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("variablename", Org.OpenAPITools.Client.ClientUtils.ParameterToString(variablename)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.DeleteRepoVariable";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<ActionVariable>("/repos/{owner}/{repo}/actions/variables/{variablename}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteRepoVariable", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a repository using a template 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="templateOwner">name of the template repository owner</param>
        /// <param name="templateRepo">name of the template repository</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Repository</returns>
        public Repository GenerateRepo(string templateOwner, string templateRepo, GenerateRepoOption? body = default(GenerateRepoOption?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<Repository> localVarResponse = GenerateRepoWithHttpInfo(templateOwner, templateRepo, body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create a repository using a template 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="templateOwner">name of the template repository owner</param>
        /// <param name="templateRepo">name of the template repository</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Repository</returns>
        public Org.OpenAPITools.Client.ApiResponse<Repository> GenerateRepoWithHttpInfo(string templateOwner, string templateRepo, GenerateRepoOption? body = default(GenerateRepoOption?), int operationIndex = 0)
        {
            // verify the required parameter 'templateOwner' is set
            if (templateOwner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'templateOwner' when calling RepositoryApi->GenerateRepo");
            }

            // verify the required parameter 'templateRepo' is set
            if (templateRepo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'templateRepo' when calling RepositoryApi->GenerateRepo");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("template_owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(templateOwner)); // path parameter
            localVarRequestOptions.PathParameters.Add("template_repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(templateRepo)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.GenerateRepo";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Repository>("/repos/{template_owner}/{template_repo}/generate", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GenerateRepo", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a repository using a template 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="templateOwner">name of the template repository owner</param>
        /// <param name="templateRepo">name of the template repository</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Repository</returns>
        public async System.Threading.Tasks.Task<Repository> GenerateRepoAsync(string templateOwner, string templateRepo, GenerateRepoOption? body = default(GenerateRepoOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<Repository> localVarResponse = await GenerateRepoWithHttpInfoAsync(templateOwner, templateRepo, body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create a repository using a template 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="templateOwner">name of the template repository owner</param>
        /// <param name="templateRepo">name of the template repository</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Repository)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Repository>> GenerateRepoWithHttpInfoAsync(string templateOwner, string templateRepo, GenerateRepoOption? body = default(GenerateRepoOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'templateOwner' is set
            if (templateOwner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'templateOwner' when calling RepositoryApi->GenerateRepo");
            }

            // verify the required parameter 'templateRepo' is set
            if (templateRepo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'templateRepo' when calling RepositoryApi->GenerateRepo");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("template_owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(templateOwner)); // path parameter
            localVarRequestOptions.PathParameters.Add("template_repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(templateRepo)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.GenerateRepo";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Repository>("/repos/{template_owner}/{template_repo}/generate", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GenerateRepo", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets the tag object of an annotated tag (not lightweight tags) 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>AnnotatedTag</returns>
        public AnnotatedTag GetAnnotatedTag(string owner, string repo, string sha, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<AnnotatedTag> localVarResponse = GetAnnotatedTagWithHttpInfo(owner, repo, sha);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets the tag object of an annotated tag (not lightweight tags) 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of AnnotatedTag</returns>
        public Org.OpenAPITools.Client.ApiResponse<AnnotatedTag> GetAnnotatedTagWithHttpInfo(string owner, string repo, string sha, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->GetAnnotatedTag");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->GetAnnotatedTag");
            }

            // verify the required parameter 'sha' is set
            if (sha == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'sha' when calling RepositoryApi->GetAnnotatedTag");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("sha", Org.OpenAPITools.Client.ClientUtils.ParameterToString(sha)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.GetAnnotatedTag";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<AnnotatedTag>("/repos/{owner}/{repo}/git/tags/{sha}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAnnotatedTag", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets the tag object of an annotated tag (not lightweight tags) 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of AnnotatedTag</returns>
        public async System.Threading.Tasks.Task<AnnotatedTag> GetAnnotatedTagAsync(string owner, string repo, string sha, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<AnnotatedTag> localVarResponse = await GetAnnotatedTagWithHttpInfoAsync(owner, repo, sha, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets the tag object of an annotated tag (not lightweight tags) 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (AnnotatedTag)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<AnnotatedTag>> GetAnnotatedTagWithHttpInfoAsync(string owner, string repo, string sha, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->GetAnnotatedTag");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->GetAnnotatedTag");
            }

            // verify the required parameter 'sha' is set
            if (sha == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'sha' when calling RepositoryApi->GetAnnotatedTag");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("sha", Org.OpenAPITools.Client.ClientUtils.ParameterToString(sha)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.GetAnnotatedTag";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<AnnotatedTag>("/repos/{owner}/{repo}/git/tags/{sha}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetAnnotatedTag", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets the blob of a repository. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the commit</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>GitBlobResponse</returns>
        public GitBlobResponse GetBlob(string owner, string repo, string sha, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<GitBlobResponse> localVarResponse = GetBlobWithHttpInfo(owner, repo, sha);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets the blob of a repository. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the commit</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of GitBlobResponse</returns>
        public Org.OpenAPITools.Client.ApiResponse<GitBlobResponse> GetBlobWithHttpInfo(string owner, string repo, string sha, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->GetBlob");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->GetBlob");
            }

            // verify the required parameter 'sha' is set
            if (sha == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'sha' when calling RepositoryApi->GetBlob");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("sha", Org.OpenAPITools.Client.ClientUtils.ParameterToString(sha)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.GetBlob";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<GitBlobResponse>("/repos/{owner}/{repo}/git/blobs/{sha}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetBlob", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets the blob of a repository. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the commit</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GitBlobResponse</returns>
        public async System.Threading.Tasks.Task<GitBlobResponse> GetBlobAsync(string owner, string repo, string sha, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<GitBlobResponse> localVarResponse = await GetBlobWithHttpInfoAsync(owner, repo, sha, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets the blob of a repository. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the commit</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GitBlobResponse)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<GitBlobResponse>> GetBlobWithHttpInfoAsync(string owner, string repo, string sha, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->GetBlob");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->GetBlob");
            }

            // verify the required parameter 'sha' is set
            if (sha == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'sha' when calling RepositoryApi->GetBlob");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("sha", Org.OpenAPITools.Client.ClientUtils.ParameterToString(sha)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.GetBlob";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<GitBlobResponse>("/repos/{owner}/{repo}/git/blobs/{sha}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetBlob", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a repo-level variable 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="variablename">name of the variable</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ActionVariable</returns>
        public ActionVariable GetRepoVariable(string owner, string repo, string variablename, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<ActionVariable> localVarResponse = GetRepoVariableWithHttpInfo(owner, repo, variablename);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a repo-level variable 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="variablename">name of the variable</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ActionVariable</returns>
        public Org.OpenAPITools.Client.ApiResponse<ActionVariable> GetRepoVariableWithHttpInfo(string owner, string repo, string variablename, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->GetRepoVariable");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->GetRepoVariable");
            }

            // verify the required parameter 'variablename' is set
            if (variablename == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'variablename' when calling RepositoryApi->GetRepoVariable");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("variablename", Org.OpenAPITools.Client.ClientUtils.ParameterToString(variablename)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.GetRepoVariable";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<ActionVariable>("/repos/{owner}/{repo}/actions/variables/{variablename}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetRepoVariable", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a repo-level variable 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="variablename">name of the variable</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ActionVariable</returns>
        public async System.Threading.Tasks.Task<ActionVariable> GetRepoVariableAsync(string owner, string repo, string variablename, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<ActionVariable> localVarResponse = await GetRepoVariableWithHttpInfoAsync(owner, repo, variablename, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a repo-level variable 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="variablename">name of the variable</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ActionVariable)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<ActionVariable>> GetRepoVariableWithHttpInfoAsync(string owner, string repo, string variablename, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->GetRepoVariable");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->GetRepoVariable");
            }

            // verify the required parameter 'variablename' is set
            if (variablename == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'variablename' when calling RepositoryApi->GetRepoVariable");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("variablename", Org.OpenAPITools.Client.ClientUtils.ParameterToString(variablename)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.GetRepoVariable";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<ActionVariable>("/repos/{owner}/{repo}/actions/variables/{variablename}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetRepoVariable", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get repo-level variables list 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;ActionVariable&gt;</returns>
        public List<ActionVariable> GetRepoVariablesList(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<ActionVariable>> localVarResponse = GetRepoVariablesListWithHttpInfo(owner, repo, page, limit);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get repo-level variables list 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;ActionVariable&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<ActionVariable>> GetRepoVariablesListWithHttpInfo(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->GetRepoVariablesList");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->GetRepoVariablesList");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.GetRepoVariablesList";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<ActionVariable>>("/repos/{owner}/{repo}/actions/variables", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetRepoVariablesList", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get repo-level variables list 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;ActionVariable&gt;</returns>
        public async System.Threading.Tasks.Task<List<ActionVariable>> GetRepoVariablesListAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<ActionVariable>> localVarResponse = await GetRepoVariablesListWithHttpInfoAsync(owner, repo, page, limit, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get repo-level variables list 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;ActionVariable&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<ActionVariable>>> GetRepoVariablesListWithHttpInfoAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->GetRepoVariablesList");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->GetRepoVariablesList");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.GetRepoVariablesList";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<ActionVariable>>("/repos/{owner}/{repo}/actions/variables", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetRepoVariablesList", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets the tree of a repository. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the commit</param>
        /// <param name="recursive">show all directories and files (optional)</param>
        /// <param name="page">page number; the &#39;truncated&#39; field in the response will be true if there are still more items after this page, false if the last page (optional)</param>
        /// <param name="perPage">number of items per page (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>GitTreeResponse</returns>
        public GitTreeResponse GetTree(string owner, string repo, string sha, bool? recursive = default(bool?), int? page = default(int?), int? perPage = default(int?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<GitTreeResponse> localVarResponse = GetTreeWithHttpInfo(owner, repo, sha, recursive, page, perPage);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets the tree of a repository. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the commit</param>
        /// <param name="recursive">show all directories and files (optional)</param>
        /// <param name="page">page number; the &#39;truncated&#39; field in the response will be true if there are still more items after this page, false if the last page (optional)</param>
        /// <param name="perPage">number of items per page (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of GitTreeResponse</returns>
        public Org.OpenAPITools.Client.ApiResponse<GitTreeResponse> GetTreeWithHttpInfo(string owner, string repo, string sha, bool? recursive = default(bool?), int? page = default(int?), int? perPage = default(int?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->GetTree");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->GetTree");
            }

            // verify the required parameter 'sha' is set
            if (sha == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'sha' when calling RepositoryApi->GetTree");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("sha", Org.OpenAPITools.Client.ClientUtils.ParameterToString(sha)); // path parameter
            if (recursive != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "recursive", recursive));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (perPage != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "per_page", perPage));
            }

            localVarRequestOptions.Operation = "RepositoryApi.GetTree";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<GitTreeResponse>("/repos/{owner}/{repo}/git/trees/{sha}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetTree", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets the tree of a repository. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the commit</param>
        /// <param name="recursive">show all directories and files (optional)</param>
        /// <param name="page">page number; the &#39;truncated&#39; field in the response will be true if there are still more items after this page, false if the last page (optional)</param>
        /// <param name="perPage">number of items per page (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GitTreeResponse</returns>
        public async System.Threading.Tasks.Task<GitTreeResponse> GetTreeAsync(string owner, string repo, string sha, bool? recursive = default(bool?), int? page = default(int?), int? perPage = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<GitTreeResponse> localVarResponse = await GetTreeWithHttpInfoAsync(owner, repo, sha, recursive, page, perPage, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets the tree of a repository. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the commit</param>
        /// <param name="recursive">show all directories and files (optional)</param>
        /// <param name="page">page number; the &#39;truncated&#39; field in the response will be true if there are still more items after this page, false if the last page (optional)</param>
        /// <param name="perPage">number of items per page (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GitTreeResponse)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<GitTreeResponse>> GetTreeWithHttpInfoAsync(string owner, string repo, string sha, bool? recursive = default(bool?), int? page = default(int?), int? perPage = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->GetTree");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->GetTree");
            }

            // verify the required parameter 'sha' is set
            if (sha == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'sha' when calling RepositoryApi->GetTree");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("sha", Org.OpenAPITools.Client.ClientUtils.ParameterToString(sha)); // path parameter
            if (recursive != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "recursive", recursive));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (perPage != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "per_page", perPage));
            }

            localVarRequestOptions.Operation = "RepositoryApi.GetTree";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<GitTreeResponse>("/repos/{owner}/{repo}/git/trees/{sha}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetTree", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List a repository&#39;s forks 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;Repository&gt;</returns>
        public List<Repository> ListForks(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<Repository>> localVarResponse = ListForksWithHttpInfo(owner, repo, page, limit);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List a repository&#39;s forks 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;Repository&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<Repository>> ListForksWithHttpInfo(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->ListForks");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->ListForks");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.ListForks";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<Repository>>("/repos/{owner}/{repo}/forks", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListForks", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List a repository&#39;s forks 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Repository&gt;</returns>
        public async System.Threading.Tasks.Task<List<Repository>> ListForksAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<Repository>> localVarResponse = await ListForksWithHttpInfoAsync(owner, repo, page, limit, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List a repository&#39;s forks 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Repository&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<Repository>>> ListForksWithHttpInfoAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->ListForks");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->ListForks");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.ListForks";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<Repository>>("/repos/{owner}/{repo}/forks", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListForks", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Reject a repo transfer 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to transfer</param>
        /// <param name="repo">name of the repo to transfer</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Repository</returns>
        public Repository RejectRepoTransfer(string owner, string repo, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<Repository> localVarResponse = RejectRepoTransferWithHttpInfo(owner, repo);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Reject a repo transfer 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to transfer</param>
        /// <param name="repo">name of the repo to transfer</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Repository</returns>
        public Org.OpenAPITools.Client.ApiResponse<Repository> RejectRepoTransferWithHttpInfo(string owner, string repo, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RejectRepoTransfer");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RejectRepoTransfer");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RejectRepoTransfer";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Repository>("/repos/{owner}/{repo}/transfer/reject", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RejectRepoTransfer", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Reject a repo transfer 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to transfer</param>
        /// <param name="repo">name of the repo to transfer</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Repository</returns>
        public async System.Threading.Tasks.Task<Repository> RejectRepoTransferAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<Repository> localVarResponse = await RejectRepoTransferWithHttpInfoAsync(owner, repo, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Reject a repo transfer 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to transfer</param>
        /// <param name="repo">name of the repo to transfer</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Repository)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Repository>> RejectRepoTransferWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RejectRepoTransfer");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RejectRepoTransfer");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RejectRepoTransfer";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Repository>("/repos/{owner}/{repo}/transfer/reject", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RejectRepoTransfer", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Add a collaborator to a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="collaborator">username of the collaborator to add</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RepoAddCollaborator(string owner, string repo, string collaborator, AddCollaboratorOption? body = default(AddCollaboratorOption?), int operationIndex = 0)
        {
            RepoAddCollaboratorWithHttpInfo(owner, repo, collaborator, body);
        }

        /// <summary>
        /// Add a collaborator to a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="collaborator">username of the collaborator to add</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> RepoAddCollaboratorWithHttpInfo(string owner, string repo, string collaborator, AddCollaboratorOption? body = default(AddCollaboratorOption?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoAddCollaborator");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoAddCollaborator");
            }

            // verify the required parameter 'collaborator' is set
            if (collaborator == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'collaborator' when calling RepositoryApi->RepoAddCollaborator");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json",
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("collaborator", Org.OpenAPITools.Client.ClientUtils.ParameterToString(collaborator)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoAddCollaborator";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<Object>("/repos/{owner}/{repo}/collaborators/{collaborator}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoAddCollaborator", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Add a collaborator to a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="collaborator">username of the collaborator to add</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RepoAddCollaboratorAsync(string owner, string repo, string collaborator, AddCollaboratorOption? body = default(AddCollaboratorOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RepoAddCollaboratorWithHttpInfoAsync(owner, repo, collaborator, body, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Add a collaborator to a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="collaborator">username of the collaborator to add</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> RepoAddCollaboratorWithHttpInfoAsync(string owner, string repo, string collaborator, AddCollaboratorOption? body = default(AddCollaboratorOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoAddCollaborator");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoAddCollaborator");
            }

            // verify the required parameter 'collaborator' is set
            if (collaborator == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'collaborator' when calling RepositoryApi->RepoAddCollaborator");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json", 
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("collaborator", Org.OpenAPITools.Client.ClientUtils.ParameterToString(collaborator)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoAddCollaborator";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<Object>("/repos/{owner}/{repo}/collaborators/{collaborator}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoAddCollaborator", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// add a push mirror to the repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PushMirror</returns>
        public PushMirror RepoAddPushMirror(string owner, string repo, CreatePushMirrorOption? body = default(CreatePushMirrorOption?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<PushMirror> localVarResponse = RepoAddPushMirrorWithHttpInfo(owner, repo, body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// add a push mirror to the repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PushMirror</returns>
        public Org.OpenAPITools.Client.ApiResponse<PushMirror> RepoAddPushMirrorWithHttpInfo(string owner, string repo, CreatePushMirrorOption? body = default(CreatePushMirrorOption?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoAddPushMirror");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoAddPushMirror");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoAddPushMirror";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<PushMirror>("/repos/{owner}/{repo}/push_mirrors", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoAddPushMirror", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// add a push mirror to the repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PushMirror</returns>
        public async System.Threading.Tasks.Task<PushMirror> RepoAddPushMirrorAsync(string owner, string repo, CreatePushMirrorOption? body = default(CreatePushMirrorOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<PushMirror> localVarResponse = await RepoAddPushMirrorWithHttpInfoAsync(owner, repo, body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// add a push mirror to the repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PushMirror)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<PushMirror>> RepoAddPushMirrorWithHttpInfoAsync(string owner, string repo, CreatePushMirrorOption? body = default(CreatePushMirrorOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoAddPushMirror");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoAddPushMirror");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoAddPushMirror";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<PushMirror>("/repos/{owner}/{repo}/push_mirrors", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoAddPushMirror", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Add a team to a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="team">team name</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RepoAddTeam(string owner, string repo, string team, int operationIndex = 0)
        {
            RepoAddTeamWithHttpInfo(owner, repo, team);
        }

        /// <summary>
        /// Add a team to a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="team">team name</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> RepoAddTeamWithHttpInfo(string owner, string repo, string team, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoAddTeam");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoAddTeam");
            }

            // verify the required parameter 'team' is set
            if (team == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'team' when calling RepositoryApi->RepoAddTeam");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("team", Org.OpenAPITools.Client.ClientUtils.ParameterToString(team)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoAddTeam";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<Object>("/repos/{owner}/{repo}/teams/{team}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoAddTeam", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Add a team to a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="team">team name</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RepoAddTeamAsync(string owner, string repo, string team, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RepoAddTeamWithHttpInfoAsync(owner, repo, team, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Add a team to a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="team">team name</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> RepoAddTeamWithHttpInfoAsync(string owner, string repo, string team, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoAddTeam");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoAddTeam");
            }

            // verify the required parameter 'team' is set
            if (team == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'team' when calling RepositoryApi->RepoAddTeam");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("team", Org.OpenAPITools.Client.ClientUtils.ParameterToString(team)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoAddTeam";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<Object>("/repos/{owner}/{repo}/teams/{team}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoAddTeam", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Add a topic to a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="topic">name of the topic to add</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RepoAddTopic(string owner, string repo, string topic, int operationIndex = 0)
        {
            RepoAddTopicWithHttpInfo(owner, repo, topic);
        }

        /// <summary>
        /// Add a topic to a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="topic">name of the topic to add</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> RepoAddTopicWithHttpInfo(string owner, string repo, string topic, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoAddTopic");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoAddTopic");
            }

            // verify the required parameter 'topic' is set
            if (topic == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'topic' when calling RepositoryApi->RepoAddTopic");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("topic", Org.OpenAPITools.Client.ClientUtils.ParameterToString(topic)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoAddTopic";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<Object>("/repos/{owner}/{repo}/topics/{topic}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoAddTopic", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Add a topic to a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="topic">name of the topic to add</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RepoAddTopicAsync(string owner, string repo, string topic, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RepoAddTopicWithHttpInfoAsync(owner, repo, topic, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Add a topic to a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="topic">name of the topic to add</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> RepoAddTopicWithHttpInfoAsync(string owner, string repo, string topic, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoAddTopic");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoAddTopic");
            }

            // verify the required parameter 'topic' is set
            if (topic == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'topic' when calling RepositoryApi->RepoAddTopic");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("topic", Org.OpenAPITools.Client.ClientUtils.ParameterToString(topic)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoAddTopic";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<Object>("/repos/{owner}/{repo}/topics/{topic}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoAddTopic", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Apply diff patch to repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>FileResponse</returns>
        public FileResponse RepoApplyDiffPatch(string owner, string repo, UpdateFileOptions body, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<FileResponse> localVarResponse = RepoApplyDiffPatchWithHttpInfo(owner, repo, body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Apply diff patch to repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of FileResponse</returns>
        public Org.OpenAPITools.Client.ApiResponse<FileResponse> RepoApplyDiffPatchWithHttpInfo(string owner, string repo, UpdateFileOptions body, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoApplyDiffPatch");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoApplyDiffPatch");
            }

            // verify the required parameter 'body' is set
            if (body == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'body' when calling RepositoryApi->RepoApplyDiffPatch");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoApplyDiffPatch";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<FileResponse>("/repos/{owner}/{repo}/diffpatch", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoApplyDiffPatch", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Apply diff patch to repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of FileResponse</returns>
        public async System.Threading.Tasks.Task<FileResponse> RepoApplyDiffPatchAsync(string owner, string repo, UpdateFileOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<FileResponse> localVarResponse = await RepoApplyDiffPatchWithHttpInfoAsync(owner, repo, body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Apply diff patch to repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (FileResponse)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<FileResponse>> RepoApplyDiffPatchWithHttpInfoAsync(string owner, string repo, UpdateFileOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoApplyDiffPatch");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoApplyDiffPatch");
            }

            // verify the required parameter 'body' is set
            if (body == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'body' when calling RepositoryApi->RepoApplyDiffPatch");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoApplyDiffPatch";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<FileResponse>("/repos/{owner}/{repo}/diffpatch", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoApplyDiffPatch", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Cancel the scheduled auto merge for the given pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to merge</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RepoCancelScheduledAutoMerge(string owner, string repo, long index, int operationIndex = 0)
        {
            RepoCancelScheduledAutoMergeWithHttpInfo(owner, repo, index);
        }

        /// <summary>
        /// Cancel the scheduled auto merge for the given pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to merge</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> RepoCancelScheduledAutoMergeWithHttpInfo(string owner, string repo, long index, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoCancelScheduledAutoMerge");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoCancelScheduledAutoMerge");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoCancelScheduledAutoMerge";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/repos/{owner}/{repo}/pulls/{index}/merge", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoCancelScheduledAutoMerge", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Cancel the scheduled auto merge for the given pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to merge</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RepoCancelScheduledAutoMergeAsync(string owner, string repo, long index, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RepoCancelScheduledAutoMergeWithHttpInfoAsync(owner, repo, index, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Cancel the scheduled auto merge for the given pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to merge</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> RepoCancelScheduledAutoMergeWithHttpInfoAsync(string owner, string repo, long index, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoCancelScheduledAutoMerge");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoCancelScheduledAutoMerge");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoCancelScheduledAutoMerge";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/repos/{owner}/{repo}/pulls/{index}/merge", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoCancelScheduledAutoMerge", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Modify multiple files in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>FilesResponse</returns>
        public FilesResponse RepoChangeFiles(string owner, string repo, ChangeFilesOptions body, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<FilesResponse> localVarResponse = RepoChangeFilesWithHttpInfo(owner, repo, body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Modify multiple files in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of FilesResponse</returns>
        public Org.OpenAPITools.Client.ApiResponse<FilesResponse> RepoChangeFilesWithHttpInfo(string owner, string repo, ChangeFilesOptions body, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoChangeFiles");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoChangeFiles");
            }

            // verify the required parameter 'body' is set
            if (body == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'body' when calling RepositoryApi->RepoChangeFiles");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoChangeFiles";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<FilesResponse>("/repos/{owner}/{repo}/contents", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoChangeFiles", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Modify multiple files in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of FilesResponse</returns>
        public async System.Threading.Tasks.Task<FilesResponse> RepoChangeFilesAsync(string owner, string repo, ChangeFilesOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<FilesResponse> localVarResponse = await RepoChangeFilesWithHttpInfoAsync(owner, repo, body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Modify multiple files in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (FilesResponse)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<FilesResponse>> RepoChangeFilesWithHttpInfoAsync(string owner, string repo, ChangeFilesOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoChangeFiles");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoChangeFiles");
            }

            // verify the required parameter 'body' is set
            if (body == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'body' when calling RepositoryApi->RepoChangeFiles");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoChangeFiles";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<FilesResponse>("/repos/{owner}/{repo}/contents", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoChangeFiles", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Check if a user is a collaborator of a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="collaborator">username of the collaborator</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RepoCheckCollaborator(string owner, string repo, string collaborator, int operationIndex = 0)
        {
            RepoCheckCollaboratorWithHttpInfo(owner, repo, collaborator);
        }

        /// <summary>
        /// Check if a user is a collaborator of a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="collaborator">username of the collaborator</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> RepoCheckCollaboratorWithHttpInfo(string owner, string repo, string collaborator, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoCheckCollaborator");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoCheckCollaborator");
            }

            // verify the required parameter 'collaborator' is set
            if (collaborator == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'collaborator' when calling RepositoryApi->RepoCheckCollaborator");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("collaborator", Org.OpenAPITools.Client.ClientUtils.ParameterToString(collaborator)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoCheckCollaborator";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Object>("/repos/{owner}/{repo}/collaborators/{collaborator}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoCheckCollaborator", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Check if a user is a collaborator of a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="collaborator">username of the collaborator</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RepoCheckCollaboratorAsync(string owner, string repo, string collaborator, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RepoCheckCollaboratorWithHttpInfoAsync(owner, repo, collaborator, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Check if a user is a collaborator of a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="collaborator">username of the collaborator</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> RepoCheckCollaboratorWithHttpInfoAsync(string owner, string repo, string collaborator, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoCheckCollaborator");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoCheckCollaborator");
            }

            // verify the required parameter 'collaborator' is set
            if (collaborator == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'collaborator' when calling RepositoryApi->RepoCheckCollaborator");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("collaborator", Org.OpenAPITools.Client.ClientUtils.ParameterToString(collaborator)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoCheckCollaborator";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Object>("/repos/{owner}/{repo}/collaborators/{collaborator}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoCheckCollaborator", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Check if a team is assigned to a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="team">team name</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Team</returns>
        public Team RepoCheckTeam(string owner, string repo, string team, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<Team> localVarResponse = RepoCheckTeamWithHttpInfo(owner, repo, team);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Check if a team is assigned to a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="team">team name</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Team</returns>
        public Org.OpenAPITools.Client.ApiResponse<Team> RepoCheckTeamWithHttpInfo(string owner, string repo, string team, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoCheckTeam");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoCheckTeam");
            }

            // verify the required parameter 'team' is set
            if (team == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'team' when calling RepositoryApi->RepoCheckTeam");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("team", Org.OpenAPITools.Client.ClientUtils.ParameterToString(team)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoCheckTeam";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Team>("/repos/{owner}/{repo}/teams/{team}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoCheckTeam", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Check if a team is assigned to a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="team">team name</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Team</returns>
        public async System.Threading.Tasks.Task<Team> RepoCheckTeamAsync(string owner, string repo, string team, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<Team> localVarResponse = await RepoCheckTeamWithHttpInfoAsync(owner, repo, team, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Check if a team is assigned to a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="team">team name</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Team)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Team>> RepoCheckTeamWithHttpInfoAsync(string owner, string repo, string team, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoCheckTeam");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoCheckTeam");
            }

            // verify the required parameter 'team' is set
            if (team == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'team' when calling RepositoryApi->RepoCheckTeam");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("team", Org.OpenAPITools.Client.ClientUtils.ParameterToString(team)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoCheckTeam";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Team>("/repos/{owner}/{repo}/teams/{team}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoCheckTeam", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get commit comparison information 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="basehead">compare two branches or commits</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Compare</returns>
        public Compare RepoCompareDiff(string owner, string repo, string basehead, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<Compare> localVarResponse = RepoCompareDiffWithHttpInfo(owner, repo, basehead);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get commit comparison information 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="basehead">compare two branches or commits</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Compare</returns>
        public Org.OpenAPITools.Client.ApiResponse<Compare> RepoCompareDiffWithHttpInfo(string owner, string repo, string basehead, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoCompareDiff");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoCompareDiff");
            }

            // verify the required parameter 'basehead' is set
            if (basehead == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'basehead' when calling RepositoryApi->RepoCompareDiff");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("basehead", Org.OpenAPITools.Client.ClientUtils.ParameterToString(basehead)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoCompareDiff";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Compare>("/repos/{owner}/{repo}/compare/{basehead}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoCompareDiff", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get commit comparison information 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="basehead">compare two branches or commits</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Compare</returns>
        public async System.Threading.Tasks.Task<Compare> RepoCompareDiffAsync(string owner, string repo, string basehead, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<Compare> localVarResponse = await RepoCompareDiffWithHttpInfoAsync(owner, repo, basehead, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get commit comparison information 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="basehead">compare two branches or commits</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Compare)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Compare>> RepoCompareDiffWithHttpInfoAsync(string owner, string repo, string basehead, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoCompareDiff");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoCompareDiff");
            }

            // verify the required parameter 'basehead' is set
            if (basehead == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'basehead' when calling RepositoryApi->RepoCompareDiff");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("basehead", Org.OpenAPITools.Client.ClientUtils.ParameterToString(basehead)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoCompareDiff";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Compare>("/repos/{owner}/{repo}/compare/{basehead}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoCompareDiff", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a branch 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Branch</returns>
        public Branch RepoCreateBranch(string owner, string repo, CreateBranchRepoOption? body = default(CreateBranchRepoOption?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<Branch> localVarResponse = RepoCreateBranchWithHttpInfo(owner, repo, body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create a branch 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Branch</returns>
        public Org.OpenAPITools.Client.ApiResponse<Branch> RepoCreateBranchWithHttpInfo(string owner, string repo, CreateBranchRepoOption? body = default(CreateBranchRepoOption?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoCreateBranch");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoCreateBranch");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoCreateBranch";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Branch>("/repos/{owner}/{repo}/branches", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoCreateBranch", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a branch 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Branch</returns>
        public async System.Threading.Tasks.Task<Branch> RepoCreateBranchAsync(string owner, string repo, CreateBranchRepoOption? body = default(CreateBranchRepoOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<Branch> localVarResponse = await RepoCreateBranchWithHttpInfoAsync(owner, repo, body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create a branch 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Branch)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Branch>> RepoCreateBranchWithHttpInfoAsync(string owner, string repo, CreateBranchRepoOption? body = default(CreateBranchRepoOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoCreateBranch");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoCreateBranch");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoCreateBranch";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Branch>("/repos/{owner}/{repo}/branches", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoCreateBranch", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a branch protections for a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>BranchProtection</returns>
        public BranchProtection RepoCreateBranchProtection(string owner, string repo, CreateBranchProtectionOption? body = default(CreateBranchProtectionOption?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<BranchProtection> localVarResponse = RepoCreateBranchProtectionWithHttpInfo(owner, repo, body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create a branch protections for a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of BranchProtection</returns>
        public Org.OpenAPITools.Client.ApiResponse<BranchProtection> RepoCreateBranchProtectionWithHttpInfo(string owner, string repo, CreateBranchProtectionOption? body = default(CreateBranchProtectionOption?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoCreateBranchProtection");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoCreateBranchProtection");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoCreateBranchProtection";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<BranchProtection>("/repos/{owner}/{repo}/branch_protections", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoCreateBranchProtection", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a branch protections for a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BranchProtection</returns>
        public async System.Threading.Tasks.Task<BranchProtection> RepoCreateBranchProtectionAsync(string owner, string repo, CreateBranchProtectionOption? body = default(CreateBranchProtectionOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<BranchProtection> localVarResponse = await RepoCreateBranchProtectionWithHttpInfoAsync(owner, repo, body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create a branch protections for a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BranchProtection)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<BranchProtection>> RepoCreateBranchProtectionWithHttpInfoAsync(string owner, string repo, CreateBranchProtectionOption? body = default(CreateBranchProtectionOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoCreateBranchProtection");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoCreateBranchProtection");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoCreateBranchProtection";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<BranchProtection>("/repos/{owner}/{repo}/branch_protections", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoCreateBranchProtection", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a file in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">path of the file to create</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>FileResponse</returns>
        public FileResponse RepoCreateFile(string owner, string repo, string filepath, CreateFileOptions body, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<FileResponse> localVarResponse = RepoCreateFileWithHttpInfo(owner, repo, filepath, body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create a file in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">path of the file to create</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of FileResponse</returns>
        public Org.OpenAPITools.Client.ApiResponse<FileResponse> RepoCreateFileWithHttpInfo(string owner, string repo, string filepath, CreateFileOptions body, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoCreateFile");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoCreateFile");
            }

            // verify the required parameter 'filepath' is set
            if (filepath == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'filepath' when calling RepositoryApi->RepoCreateFile");
            }

            // verify the required parameter 'body' is set
            if (body == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'body' when calling RepositoryApi->RepoCreateFile");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("filepath", Org.OpenAPITools.Client.ClientUtils.ParameterToString(filepath)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoCreateFile";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<FileResponse>("/repos/{owner}/{repo}/contents/{filepath}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoCreateFile", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a file in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">path of the file to create</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of FileResponse</returns>
        public async System.Threading.Tasks.Task<FileResponse> RepoCreateFileAsync(string owner, string repo, string filepath, CreateFileOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<FileResponse> localVarResponse = await RepoCreateFileWithHttpInfoAsync(owner, repo, filepath, body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create a file in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">path of the file to create</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (FileResponse)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<FileResponse>> RepoCreateFileWithHttpInfoAsync(string owner, string repo, string filepath, CreateFileOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoCreateFile");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoCreateFile");
            }

            // verify the required parameter 'filepath' is set
            if (filepath == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'filepath' when calling RepositoryApi->RepoCreateFile");
            }

            // verify the required parameter 'body' is set
            if (body == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'body' when calling RepositoryApi->RepoCreateFile");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("filepath", Org.OpenAPITools.Client.ClientUtils.ParameterToString(filepath)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoCreateFile";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<FileResponse>("/repos/{owner}/{repo}/contents/{filepath}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoCreateFile", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a hook 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Hook</returns>
        public Hook RepoCreateHook(string owner, string repo, CreateHookOption? body = default(CreateHookOption?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<Hook> localVarResponse = RepoCreateHookWithHttpInfo(owner, repo, body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create a hook 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Hook</returns>
        public Org.OpenAPITools.Client.ApiResponse<Hook> RepoCreateHookWithHttpInfo(string owner, string repo, CreateHookOption? body = default(CreateHookOption?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoCreateHook");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoCreateHook");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoCreateHook";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Hook>("/repos/{owner}/{repo}/hooks", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoCreateHook", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a hook 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Hook</returns>
        public async System.Threading.Tasks.Task<Hook> RepoCreateHookAsync(string owner, string repo, CreateHookOption? body = default(CreateHookOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<Hook> localVarResponse = await RepoCreateHookWithHttpInfoAsync(owner, repo, body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create a hook 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Hook)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Hook>> RepoCreateHookWithHttpInfoAsync(string owner, string repo, CreateHookOption? body = default(CreateHookOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoCreateHook");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoCreateHook");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoCreateHook";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Hook>("/repos/{owner}/{repo}/hooks", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoCreateHook", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Add a key to a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>DeployKey</returns>
        public DeployKey RepoCreateKey(string owner, string repo, CreateKeyOption? body = default(CreateKeyOption?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<DeployKey> localVarResponse = RepoCreateKeyWithHttpInfo(owner, repo, body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Add a key to a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of DeployKey</returns>
        public Org.OpenAPITools.Client.ApiResponse<DeployKey> RepoCreateKeyWithHttpInfo(string owner, string repo, CreateKeyOption? body = default(CreateKeyOption?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoCreateKey");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoCreateKey");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoCreateKey";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<DeployKey>("/repos/{owner}/{repo}/keys", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoCreateKey", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Add a key to a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of DeployKey</returns>
        public async System.Threading.Tasks.Task<DeployKey> RepoCreateKeyAsync(string owner, string repo, CreateKeyOption? body = default(CreateKeyOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<DeployKey> localVarResponse = await RepoCreateKeyWithHttpInfoAsync(owner, repo, body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Add a key to a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (DeployKey)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<DeployKey>> RepoCreateKeyWithHttpInfoAsync(string owner, string repo, CreateKeyOption? body = default(CreateKeyOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoCreateKey");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoCreateKey");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoCreateKey";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<DeployKey>("/repos/{owner}/{repo}/keys", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoCreateKey", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PullRequest</returns>
        public PullRequest RepoCreatePullRequest(string owner, string repo, CreatePullRequestOption? body = default(CreatePullRequestOption?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<PullRequest> localVarResponse = RepoCreatePullRequestWithHttpInfo(owner, repo, body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PullRequest</returns>
        public Org.OpenAPITools.Client.ApiResponse<PullRequest> RepoCreatePullRequestWithHttpInfo(string owner, string repo, CreatePullRequestOption? body = default(CreatePullRequestOption?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoCreatePullRequest");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoCreatePullRequest");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoCreatePullRequest";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<PullRequest>("/repos/{owner}/{repo}/pulls", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoCreatePullRequest", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PullRequest</returns>
        public async System.Threading.Tasks.Task<PullRequest> RepoCreatePullRequestAsync(string owner, string repo, CreatePullRequestOption? body = default(CreatePullRequestOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<PullRequest> localVarResponse = await RepoCreatePullRequestWithHttpInfoAsync(owner, repo, body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PullRequest)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<PullRequest>> RepoCreatePullRequestWithHttpInfoAsync(string owner, string repo, CreatePullRequestOption? body = default(CreatePullRequestOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoCreatePullRequest");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoCreatePullRequest");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoCreatePullRequest";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<PullRequest>("/repos/{owner}/{repo}/pulls", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoCreatePullRequest", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a review to an pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PullReview</returns>
        public PullReview RepoCreatePullReview(string owner, string repo, long index, CreatePullReviewOptions body, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<PullReview> localVarResponse = RepoCreatePullReviewWithHttpInfo(owner, repo, index, body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create a review to an pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PullReview</returns>
        public Org.OpenAPITools.Client.ApiResponse<PullReview> RepoCreatePullReviewWithHttpInfo(string owner, string repo, long index, CreatePullReviewOptions body, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoCreatePullReview");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoCreatePullReview");
            }

            // verify the required parameter 'body' is set
            if (body == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'body' when calling RepositoryApi->RepoCreatePullReview");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json",
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoCreatePullReview";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<PullReview>("/repos/{owner}/{repo}/pulls/{index}/reviews", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoCreatePullReview", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a review to an pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PullReview</returns>
        public async System.Threading.Tasks.Task<PullReview> RepoCreatePullReviewAsync(string owner, string repo, long index, CreatePullReviewOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<PullReview> localVarResponse = await RepoCreatePullReviewWithHttpInfoAsync(owner, repo, index, body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create a review to an pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PullReview)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<PullReview>> RepoCreatePullReviewWithHttpInfoAsync(string owner, string repo, long index, CreatePullReviewOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoCreatePullReview");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoCreatePullReview");
            }

            // verify the required parameter 'body' is set
            if (body == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'body' when calling RepositoryApi->RepoCreatePullReview");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json", 
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoCreatePullReview";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<PullReview>("/repos/{owner}/{repo}/pulls/{index}/reviews", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoCreatePullReview", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// create review requests for a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;PullReview&gt;</returns>
        public List<PullReview> RepoCreatePullReviewRequests(string owner, string repo, long index, PullReviewRequestOptions body, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<PullReview>> localVarResponse = RepoCreatePullReviewRequestsWithHttpInfo(owner, repo, index, body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// create review requests for a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;PullReview&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<PullReview>> RepoCreatePullReviewRequestsWithHttpInfo(string owner, string repo, long index, PullReviewRequestOptions body, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoCreatePullReviewRequests");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoCreatePullReviewRequests");
            }

            // verify the required parameter 'body' is set
            if (body == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'body' when calling RepositoryApi->RepoCreatePullReviewRequests");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json",
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoCreatePullReviewRequests";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<List<PullReview>>("/repos/{owner}/{repo}/pulls/{index}/requested_reviewers", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoCreatePullReviewRequests", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// create review requests for a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;PullReview&gt;</returns>
        public async System.Threading.Tasks.Task<List<PullReview>> RepoCreatePullReviewRequestsAsync(string owner, string repo, long index, PullReviewRequestOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<PullReview>> localVarResponse = await RepoCreatePullReviewRequestsWithHttpInfoAsync(owner, repo, index, body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// create review requests for a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;PullReview&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<PullReview>>> RepoCreatePullReviewRequestsWithHttpInfoAsync(string owner, string repo, long index, PullReviewRequestOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoCreatePullReviewRequests");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoCreatePullReviewRequests");
            }

            // verify the required parameter 'body' is set
            if (body == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'body' when calling RepositoryApi->RepoCreatePullReviewRequests");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json", 
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoCreatePullReviewRequests";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<List<PullReview>>("/repos/{owner}/{repo}/pulls/{index}/requested_reviewers", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoCreatePullReviewRequests", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a release 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Release</returns>
        public Release RepoCreateRelease(string owner, string repo, CreateReleaseOption? body = default(CreateReleaseOption?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<Release> localVarResponse = RepoCreateReleaseWithHttpInfo(owner, repo, body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create a release 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Release</returns>
        public Org.OpenAPITools.Client.ApiResponse<Release> RepoCreateReleaseWithHttpInfo(string owner, string repo, CreateReleaseOption? body = default(CreateReleaseOption?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoCreateRelease");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoCreateRelease");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoCreateRelease";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Release>("/repos/{owner}/{repo}/releases", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoCreateRelease", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a release 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Release</returns>
        public async System.Threading.Tasks.Task<Release> RepoCreateReleaseAsync(string owner, string repo, CreateReleaseOption? body = default(CreateReleaseOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<Release> localVarResponse = await RepoCreateReleaseWithHttpInfoAsync(owner, repo, body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create a release 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Release)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Release>> RepoCreateReleaseWithHttpInfoAsync(string owner, string repo, CreateReleaseOption? body = default(CreateReleaseOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoCreateRelease");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoCreateRelease");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoCreateRelease";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Release>("/repos/{owner}/{repo}/releases", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoCreateRelease", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a release attachment 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="name">name of the attachment (optional)</param>
        /// <param name="attachment">attachment to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Attachment</returns>
        public Attachment RepoCreateReleaseAttachment(string owner, string repo, long id, string? name = default(string?), System.IO.Stream? attachment = default(System.IO.Stream?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<Attachment> localVarResponse = RepoCreateReleaseAttachmentWithHttpInfo(owner, repo, id, name, attachment);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create a release attachment 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="name">name of the attachment (optional)</param>
        /// <param name="attachment">attachment to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Attachment</returns>
        public Org.OpenAPITools.Client.ApiResponse<Attachment> RepoCreateReleaseAttachmentWithHttpInfo(string owner, string repo, long id, string? name = default(string?), System.IO.Stream? attachment = default(System.IO.Stream?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoCreateReleaseAttachment");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoCreateReleaseAttachment");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "multipart/form-data",
                "application/octet-stream"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter
            if (name != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "name", name));
            }
            if (attachment != null)
            {
                localVarRequestOptions.FileParameters.Add("attachment", attachment);
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoCreateReleaseAttachment";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Attachment>("/repos/{owner}/{repo}/releases/{id}/assets", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoCreateReleaseAttachment", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a release attachment 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="name">name of the attachment (optional)</param>
        /// <param name="attachment">attachment to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Attachment</returns>
        public async System.Threading.Tasks.Task<Attachment> RepoCreateReleaseAttachmentAsync(string owner, string repo, long id, string? name = default(string?), System.IO.Stream? attachment = default(System.IO.Stream?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<Attachment> localVarResponse = await RepoCreateReleaseAttachmentWithHttpInfoAsync(owner, repo, id, name, attachment, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create a release attachment 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="name">name of the attachment (optional)</param>
        /// <param name="attachment">attachment to upload (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Attachment)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Attachment>> RepoCreateReleaseAttachmentWithHttpInfoAsync(string owner, string repo, long id, string? name = default(string?), System.IO.Stream? attachment = default(System.IO.Stream?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoCreateReleaseAttachment");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoCreateReleaseAttachment");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "multipart/form-data", 
                "application/octet-stream"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter
            if (name != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "name", name));
            }
            if (attachment != null)
            {
                localVarRequestOptions.FileParameters.Add("attachment", attachment);
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoCreateReleaseAttachment";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Attachment>("/repos/{owner}/{repo}/releases/{id}/assets", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoCreateReleaseAttachment", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a commit status 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the commit</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>CommitStatus</returns>
        public CommitStatus RepoCreateStatus(string owner, string repo, string sha, CreateStatusOption? body = default(CreateStatusOption?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<CommitStatus> localVarResponse = RepoCreateStatusWithHttpInfo(owner, repo, sha, body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create a commit status 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the commit</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of CommitStatus</returns>
        public Org.OpenAPITools.Client.ApiResponse<CommitStatus> RepoCreateStatusWithHttpInfo(string owner, string repo, string sha, CreateStatusOption? body = default(CreateStatusOption?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoCreateStatus");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoCreateStatus");
            }

            // verify the required parameter 'sha' is set
            if (sha == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'sha' when calling RepositoryApi->RepoCreateStatus");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json",
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("sha", Org.OpenAPITools.Client.ClientUtils.ParameterToString(sha)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoCreateStatus";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<CommitStatus>("/repos/{owner}/{repo}/statuses/{sha}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoCreateStatus", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a commit status 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the commit</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CommitStatus</returns>
        public async System.Threading.Tasks.Task<CommitStatus> RepoCreateStatusAsync(string owner, string repo, string sha, CreateStatusOption? body = default(CreateStatusOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<CommitStatus> localVarResponse = await RepoCreateStatusWithHttpInfoAsync(owner, repo, sha, body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create a commit status 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the commit</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CommitStatus)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<CommitStatus>> RepoCreateStatusWithHttpInfoAsync(string owner, string repo, string sha, CreateStatusOption? body = default(CreateStatusOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoCreateStatus");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoCreateStatus");
            }

            // verify the required parameter 'sha' is set
            if (sha == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'sha' when calling RepositoryApi->RepoCreateStatus");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json", 
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("sha", Org.OpenAPITools.Client.ClientUtils.ParameterToString(sha)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoCreateStatus";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<CommitStatus>("/repos/{owner}/{repo}/statuses/{sha}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoCreateStatus", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a new git tag in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Tag</returns>
        public Tag RepoCreateTag(string owner, string repo, CreateTagOption? body = default(CreateTagOption?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<Tag> localVarResponse = RepoCreateTagWithHttpInfo(owner, repo, body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create a new git tag in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Tag</returns>
        public Org.OpenAPITools.Client.ApiResponse<Tag> RepoCreateTagWithHttpInfo(string owner, string repo, CreateTagOption? body = default(CreateTagOption?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoCreateTag");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoCreateTag");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json",
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoCreateTag";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Tag>("/repos/{owner}/{repo}/tags", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoCreateTag", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a new git tag in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Tag</returns>
        public async System.Threading.Tasks.Task<Tag> RepoCreateTagAsync(string owner, string repo, CreateTagOption? body = default(CreateTagOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<Tag> localVarResponse = await RepoCreateTagWithHttpInfoAsync(owner, repo, body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create a new git tag in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Tag)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Tag>> RepoCreateTagWithHttpInfoAsync(string owner, string repo, CreateTagOption? body = default(CreateTagOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoCreateTag");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoCreateTag");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json", 
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoCreateTag";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Tag>("/repos/{owner}/{repo}/tags", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoCreateTag", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a wiki page 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>WikiPage</returns>
        public WikiPage RepoCreateWikiPage(string owner, string repo, CreateWikiPageOptions? body = default(CreateWikiPageOptions?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<WikiPage> localVarResponse = RepoCreateWikiPageWithHttpInfo(owner, repo, body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create a wiki page 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of WikiPage</returns>
        public Org.OpenAPITools.Client.ApiResponse<WikiPage> RepoCreateWikiPageWithHttpInfo(string owner, string repo, CreateWikiPageOptions? body = default(CreateWikiPageOptions?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoCreateWikiPage");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoCreateWikiPage");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "text/html"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoCreateWikiPage";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<WikiPage>("/repos/{owner}/{repo}/wiki/new", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoCreateWikiPage", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a wiki page 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of WikiPage</returns>
        public async System.Threading.Tasks.Task<WikiPage> RepoCreateWikiPageAsync(string owner, string repo, CreateWikiPageOptions? body = default(CreateWikiPageOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<WikiPage> localVarResponse = await RepoCreateWikiPageWithHttpInfoAsync(owner, repo, body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create a wiki page 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (WikiPage)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<WikiPage>> RepoCreateWikiPageWithHttpInfoAsync(string owner, string repo, CreateWikiPageOptions? body = default(CreateWikiPageOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoCreateWikiPage");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoCreateWikiPage");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "text/html"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoCreateWikiPage";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<WikiPage>("/repos/{owner}/{repo}/wiki/new", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoCreateWikiPage", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to delete</param>
        /// <param name="repo">name of the repo to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RepoDelete(string owner, string repo, int operationIndex = 0)
        {
            RepoDeleteWithHttpInfo(owner, repo);
        }

        /// <summary>
        /// Delete a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to delete</param>
        /// <param name="repo">name of the repo to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> RepoDeleteWithHttpInfo(string owner, string repo, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDelete");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDelete");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoDelete";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/repos/{owner}/{repo}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDelete", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to delete</param>
        /// <param name="repo">name of the repo to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RepoDeleteAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RepoDeleteWithHttpInfoAsync(owner, repo, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Delete a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to delete</param>
        /// <param name="repo">name of the repo to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> RepoDeleteWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDelete");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDelete");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoDelete";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/repos/{owner}/{repo}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDelete", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete avatar 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RepoDeleteAvatar(string owner, string repo, int operationIndex = 0)
        {
            RepoDeleteAvatarWithHttpInfo(owner, repo);
        }

        /// <summary>
        /// Delete avatar 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> RepoDeleteAvatarWithHttpInfo(string owner, string repo, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDeleteAvatar");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDeleteAvatar");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoDeleteAvatar";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/repos/{owner}/{repo}/avatar", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDeleteAvatar", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete avatar 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RepoDeleteAvatarAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RepoDeleteAvatarWithHttpInfoAsync(owner, repo, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Delete avatar 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> RepoDeleteAvatarWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDeleteAvatar");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDeleteAvatar");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoDeleteAvatar";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/repos/{owner}/{repo}/avatar", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDeleteAvatar", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a specific branch from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="branch">branch to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RepoDeleteBranch(string owner, string repo, string branch, int operationIndex = 0)
        {
            RepoDeleteBranchWithHttpInfo(owner, repo, branch);
        }

        /// <summary>
        /// Delete a specific branch from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="branch">branch to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> RepoDeleteBranchWithHttpInfo(string owner, string repo, string branch, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDeleteBranch");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDeleteBranch");
            }

            // verify the required parameter 'branch' is set
            if (branch == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'branch' when calling RepositoryApi->RepoDeleteBranch");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("branch", Org.OpenAPITools.Client.ClientUtils.ParameterToString(branch)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoDeleteBranch";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/repos/{owner}/{repo}/branches/{branch}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDeleteBranch", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a specific branch from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="branch">branch to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RepoDeleteBranchAsync(string owner, string repo, string branch, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RepoDeleteBranchWithHttpInfoAsync(owner, repo, branch, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Delete a specific branch from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="branch">branch to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> RepoDeleteBranchWithHttpInfoAsync(string owner, string repo, string branch, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDeleteBranch");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDeleteBranch");
            }

            // verify the required parameter 'branch' is set
            if (branch == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'branch' when calling RepositoryApi->RepoDeleteBranch");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("branch", Org.OpenAPITools.Client.ClientUtils.ParameterToString(branch)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoDeleteBranch";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/repos/{owner}/{repo}/branches/{branch}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDeleteBranch", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a specific branch protection for the repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">name of protected branch</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RepoDeleteBranchProtection(string owner, string repo, string name, int operationIndex = 0)
        {
            RepoDeleteBranchProtectionWithHttpInfo(owner, repo, name);
        }

        /// <summary>
        /// Delete a specific branch protection for the repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">name of protected branch</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> RepoDeleteBranchProtectionWithHttpInfo(string owner, string repo, string name, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDeleteBranchProtection");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDeleteBranchProtection");
            }

            // verify the required parameter 'name' is set
            if (name == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'name' when calling RepositoryApi->RepoDeleteBranchProtection");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("name", Org.OpenAPITools.Client.ClientUtils.ParameterToString(name)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoDeleteBranchProtection";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/repos/{owner}/{repo}/branch_protections/{name}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDeleteBranchProtection", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a specific branch protection for the repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">name of protected branch</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RepoDeleteBranchProtectionAsync(string owner, string repo, string name, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RepoDeleteBranchProtectionWithHttpInfoAsync(owner, repo, name, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Delete a specific branch protection for the repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">name of protected branch</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> RepoDeleteBranchProtectionWithHttpInfoAsync(string owner, string repo, string name, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDeleteBranchProtection");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDeleteBranchProtection");
            }

            // verify the required parameter 'name' is set
            if (name == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'name' when calling RepositoryApi->RepoDeleteBranchProtection");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("name", Org.OpenAPITools.Client.ClientUtils.ParameterToString(name)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoDeleteBranchProtection";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/repos/{owner}/{repo}/branch_protections/{name}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDeleteBranchProtection", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a collaborator from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="collaborator">username of the collaborator to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RepoDeleteCollaborator(string owner, string repo, string collaborator, int operationIndex = 0)
        {
            RepoDeleteCollaboratorWithHttpInfo(owner, repo, collaborator);
        }

        /// <summary>
        /// Delete a collaborator from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="collaborator">username of the collaborator to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> RepoDeleteCollaboratorWithHttpInfo(string owner, string repo, string collaborator, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDeleteCollaborator");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDeleteCollaborator");
            }

            // verify the required parameter 'collaborator' is set
            if (collaborator == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'collaborator' when calling RepositoryApi->RepoDeleteCollaborator");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("collaborator", Org.OpenAPITools.Client.ClientUtils.ParameterToString(collaborator)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoDeleteCollaborator";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/repos/{owner}/{repo}/collaborators/{collaborator}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDeleteCollaborator", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a collaborator from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="collaborator">username of the collaborator to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RepoDeleteCollaboratorAsync(string owner, string repo, string collaborator, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RepoDeleteCollaboratorWithHttpInfoAsync(owner, repo, collaborator, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Delete a collaborator from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="collaborator">username of the collaborator to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> RepoDeleteCollaboratorWithHttpInfoAsync(string owner, string repo, string collaborator, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDeleteCollaborator");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDeleteCollaborator");
            }

            // verify the required parameter 'collaborator' is set
            if (collaborator == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'collaborator' when calling RepositoryApi->RepoDeleteCollaborator");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("collaborator", Org.OpenAPITools.Client.ClientUtils.ParameterToString(collaborator)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoDeleteCollaborator";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/repos/{owner}/{repo}/collaborators/{collaborator}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDeleteCollaborator", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a file in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">path of the file to delete</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>FileDeleteResponse</returns>
        public FileDeleteResponse RepoDeleteFile(string owner, string repo, string filepath, DeleteFileOptions body, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<FileDeleteResponse> localVarResponse = RepoDeleteFileWithHttpInfo(owner, repo, filepath, body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Delete a file in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">path of the file to delete</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of FileDeleteResponse</returns>
        public Org.OpenAPITools.Client.ApiResponse<FileDeleteResponse> RepoDeleteFileWithHttpInfo(string owner, string repo, string filepath, DeleteFileOptions body, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDeleteFile");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDeleteFile");
            }

            // verify the required parameter 'filepath' is set
            if (filepath == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'filepath' when calling RepositoryApi->RepoDeleteFile");
            }

            // verify the required parameter 'body' is set
            if (body == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'body' when calling RepositoryApi->RepoDeleteFile");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("filepath", Org.OpenAPITools.Client.ClientUtils.ParameterToString(filepath)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoDeleteFile";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<FileDeleteResponse>("/repos/{owner}/{repo}/contents/{filepath}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDeleteFile", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a file in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">path of the file to delete</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of FileDeleteResponse</returns>
        public async System.Threading.Tasks.Task<FileDeleteResponse> RepoDeleteFileAsync(string owner, string repo, string filepath, DeleteFileOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<FileDeleteResponse> localVarResponse = await RepoDeleteFileWithHttpInfoAsync(owner, repo, filepath, body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Delete a file in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">path of the file to delete</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (FileDeleteResponse)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<FileDeleteResponse>> RepoDeleteFileWithHttpInfoAsync(string owner, string repo, string filepath, DeleteFileOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDeleteFile");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDeleteFile");
            }

            // verify the required parameter 'filepath' is set
            if (filepath == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'filepath' when calling RepositoryApi->RepoDeleteFile");
            }

            // verify the required parameter 'body' is set
            if (body == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'body' when calling RepositoryApi->RepoDeleteFile");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("filepath", Org.OpenAPITools.Client.ClientUtils.ParameterToString(filepath)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoDeleteFile";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<FileDeleteResponse>("/repos/{owner}/{repo}/contents/{filepath}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDeleteFile", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a Git hook in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RepoDeleteGitHook(string owner, string repo, string id, int operationIndex = 0)
        {
            RepoDeleteGitHookWithHttpInfo(owner, repo, id);
        }

        /// <summary>
        /// Delete a Git hook in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> RepoDeleteGitHookWithHttpInfo(string owner, string repo, string id, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDeleteGitHook");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDeleteGitHook");
            }

            // verify the required parameter 'id' is set
            if (id == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'id' when calling RepositoryApi->RepoDeleteGitHook");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoDeleteGitHook";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/repos/{owner}/{repo}/hooks/git/{id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDeleteGitHook", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a Git hook in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RepoDeleteGitHookAsync(string owner, string repo, string id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RepoDeleteGitHookWithHttpInfoAsync(owner, repo, id, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Delete a Git hook in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> RepoDeleteGitHookWithHttpInfoAsync(string owner, string repo, string id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDeleteGitHook");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDeleteGitHook");
            }

            // verify the required parameter 'id' is set
            if (id == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'id' when calling RepositoryApi->RepoDeleteGitHook");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoDeleteGitHook";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/repos/{owner}/{repo}/hooks/git/{id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDeleteGitHook", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a hook in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RepoDeleteHook(string owner, string repo, long id, int operationIndex = 0)
        {
            RepoDeleteHookWithHttpInfo(owner, repo, id);
        }

        /// <summary>
        /// Delete a hook in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> RepoDeleteHookWithHttpInfo(string owner, string repo, long id, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDeleteHook");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDeleteHook");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoDeleteHook";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/repos/{owner}/{repo}/hooks/{id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDeleteHook", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a hook in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RepoDeleteHookAsync(string owner, string repo, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RepoDeleteHookWithHttpInfoAsync(owner, repo, id, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Delete a hook in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> RepoDeleteHookWithHttpInfoAsync(string owner, string repo, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDeleteHook");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDeleteHook");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoDeleteHook";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/repos/{owner}/{repo}/hooks/{id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDeleteHook", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a key from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the key to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RepoDeleteKey(string owner, string repo, long id, int operationIndex = 0)
        {
            RepoDeleteKeyWithHttpInfo(owner, repo, id);
        }

        /// <summary>
        /// Delete a key from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the key to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> RepoDeleteKeyWithHttpInfo(string owner, string repo, long id, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDeleteKey");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDeleteKey");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoDeleteKey";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/repos/{owner}/{repo}/keys/{id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDeleteKey", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a key from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the key to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RepoDeleteKeyAsync(string owner, string repo, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RepoDeleteKeyWithHttpInfoAsync(owner, repo, id, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Delete a key from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the key to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> RepoDeleteKeyWithHttpInfoAsync(string owner, string repo, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDeleteKey");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDeleteKey");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoDeleteKey";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/repos/{owner}/{repo}/keys/{id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDeleteKey", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a specific review from a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RepoDeletePullReview(string owner, string repo, long index, long id, int operationIndex = 0)
        {
            RepoDeletePullReviewWithHttpInfo(owner, repo, index, id);
        }

        /// <summary>
        /// Delete a specific review from a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> RepoDeletePullReviewWithHttpInfo(string owner, string repo, long index, long id, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDeletePullReview");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDeletePullReview");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoDeletePullReview";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/repos/{owner}/{repo}/pulls/{index}/reviews/{id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDeletePullReview", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a specific review from a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RepoDeletePullReviewAsync(string owner, string repo, long index, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RepoDeletePullReviewWithHttpInfoAsync(owner, repo, index, id, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Delete a specific review from a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> RepoDeletePullReviewWithHttpInfoAsync(string owner, string repo, long index, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDeletePullReview");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDeletePullReview");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoDeletePullReview";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/repos/{owner}/{repo}/pulls/{index}/reviews/{id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDeletePullReview", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// cancel review requests for a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RepoDeletePullReviewRequests(string owner, string repo, long index, PullReviewRequestOptions body, int operationIndex = 0)
        {
            RepoDeletePullReviewRequestsWithHttpInfo(owner, repo, index, body);
        }

        /// <summary>
        /// cancel review requests for a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> RepoDeletePullReviewRequestsWithHttpInfo(string owner, string repo, long index, PullReviewRequestOptions body, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDeletePullReviewRequests");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDeletePullReviewRequests");
            }

            // verify the required parameter 'body' is set
            if (body == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'body' when calling RepositoryApi->RepoDeletePullReviewRequests");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json",
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoDeletePullReviewRequests";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/repos/{owner}/{repo}/pulls/{index}/requested_reviewers", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDeletePullReviewRequests", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// cancel review requests for a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RepoDeletePullReviewRequestsAsync(string owner, string repo, long index, PullReviewRequestOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RepoDeletePullReviewRequestsWithHttpInfoAsync(owner, repo, index, body, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// cancel review requests for a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> RepoDeletePullReviewRequestsWithHttpInfoAsync(string owner, string repo, long index, PullReviewRequestOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDeletePullReviewRequests");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDeletePullReviewRequests");
            }

            // verify the required parameter 'body' is set
            if (body == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'body' when calling RepositoryApi->RepoDeletePullReviewRequests");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json", 
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoDeletePullReviewRequests";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/repos/{owner}/{repo}/pulls/{index}/requested_reviewers", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDeletePullReviewRequests", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// deletes a push mirror from a repository by remoteName 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">remote name of the pushMirror</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RepoDeletePushMirror(string owner, string repo, string name, int operationIndex = 0)
        {
            RepoDeletePushMirrorWithHttpInfo(owner, repo, name);
        }

        /// <summary>
        /// deletes a push mirror from a repository by remoteName 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">remote name of the pushMirror</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> RepoDeletePushMirrorWithHttpInfo(string owner, string repo, string name, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDeletePushMirror");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDeletePushMirror");
            }

            // verify the required parameter 'name' is set
            if (name == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'name' when calling RepositoryApi->RepoDeletePushMirror");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("name", Org.OpenAPITools.Client.ClientUtils.ParameterToString(name)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoDeletePushMirror";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/repos/{owner}/{repo}/push_mirrors/{name}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDeletePushMirror", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// deletes a push mirror from a repository by remoteName 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">remote name of the pushMirror</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RepoDeletePushMirrorAsync(string owner, string repo, string name, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RepoDeletePushMirrorWithHttpInfoAsync(owner, repo, name, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// deletes a push mirror from a repository by remoteName 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">remote name of the pushMirror</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> RepoDeletePushMirrorWithHttpInfoAsync(string owner, string repo, string name, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDeletePushMirror");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDeletePushMirror");
            }

            // verify the required parameter 'name' is set
            if (name == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'name' when calling RepositoryApi->RepoDeletePushMirror");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("name", Org.OpenAPITools.Client.ClientUtils.ParameterToString(name)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoDeletePushMirror";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/repos/{owner}/{repo}/push_mirrors/{name}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDeletePushMirror", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a release 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RepoDeleteRelease(string owner, string repo, long id, int operationIndex = 0)
        {
            RepoDeleteReleaseWithHttpInfo(owner, repo, id);
        }

        /// <summary>
        /// Delete a release 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> RepoDeleteReleaseWithHttpInfo(string owner, string repo, long id, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDeleteRelease");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDeleteRelease");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoDeleteRelease";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/repos/{owner}/{repo}/releases/{id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDeleteRelease", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a release 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RepoDeleteReleaseAsync(string owner, string repo, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RepoDeleteReleaseWithHttpInfoAsync(owner, repo, id, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Delete a release 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> RepoDeleteReleaseWithHttpInfoAsync(string owner, string repo, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDeleteRelease");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDeleteRelease");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoDeleteRelease";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/repos/{owner}/{repo}/releases/{id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDeleteRelease", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a release attachment 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="attachmentId">id of the attachment to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RepoDeleteReleaseAttachment(string owner, string repo, long id, long attachmentId, int operationIndex = 0)
        {
            RepoDeleteReleaseAttachmentWithHttpInfo(owner, repo, id, attachmentId);
        }

        /// <summary>
        /// Delete a release attachment 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="attachmentId">id of the attachment to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> RepoDeleteReleaseAttachmentWithHttpInfo(string owner, string repo, long id, long attachmentId, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDeleteReleaseAttachment");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDeleteReleaseAttachment");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.PathParameters.Add("attachment_id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(attachmentId)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoDeleteReleaseAttachment";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDeleteReleaseAttachment", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a release attachment 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="attachmentId">id of the attachment to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RepoDeleteReleaseAttachmentAsync(string owner, string repo, long id, long attachmentId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RepoDeleteReleaseAttachmentWithHttpInfoAsync(owner, repo, id, attachmentId, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Delete a release attachment 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="attachmentId">id of the attachment to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> RepoDeleteReleaseAttachmentWithHttpInfoAsync(string owner, string repo, long id, long attachmentId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDeleteReleaseAttachment");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDeleteReleaseAttachment");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.PathParameters.Add("attachment_id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(attachmentId)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoDeleteReleaseAttachment";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDeleteReleaseAttachment", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a release by tag name 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="tag">tag name of the release to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RepoDeleteReleaseByTag(string owner, string repo, string tag, int operationIndex = 0)
        {
            RepoDeleteReleaseByTagWithHttpInfo(owner, repo, tag);
        }

        /// <summary>
        /// Delete a release by tag name 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="tag">tag name of the release to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> RepoDeleteReleaseByTagWithHttpInfo(string owner, string repo, string tag, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDeleteReleaseByTag");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDeleteReleaseByTag");
            }

            // verify the required parameter 'tag' is set
            if (tag == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'tag' when calling RepositoryApi->RepoDeleteReleaseByTag");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("tag", Org.OpenAPITools.Client.ClientUtils.ParameterToString(tag)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoDeleteReleaseByTag";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/repos/{owner}/{repo}/releases/tags/{tag}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDeleteReleaseByTag", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a release by tag name 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="tag">tag name of the release to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RepoDeleteReleaseByTagAsync(string owner, string repo, string tag, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RepoDeleteReleaseByTagWithHttpInfoAsync(owner, repo, tag, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Delete a release by tag name 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="tag">tag name of the release to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> RepoDeleteReleaseByTagWithHttpInfoAsync(string owner, string repo, string tag, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDeleteReleaseByTag");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDeleteReleaseByTag");
            }

            // verify the required parameter 'tag' is set
            if (tag == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'tag' when calling RepositoryApi->RepoDeleteReleaseByTag");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("tag", Org.OpenAPITools.Client.ClientUtils.ParameterToString(tag)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoDeleteReleaseByTag";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/repos/{owner}/{repo}/releases/tags/{tag}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDeleteReleaseByTag", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a repository&#39;s tag by name 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="tag">name of tag to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RepoDeleteTag(string owner, string repo, string tag, int operationIndex = 0)
        {
            RepoDeleteTagWithHttpInfo(owner, repo, tag);
        }

        /// <summary>
        /// Delete a repository&#39;s tag by name 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="tag">name of tag to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> RepoDeleteTagWithHttpInfo(string owner, string repo, string tag, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDeleteTag");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDeleteTag");
            }

            // verify the required parameter 'tag' is set
            if (tag == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'tag' when calling RepositoryApi->RepoDeleteTag");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("tag", Org.OpenAPITools.Client.ClientUtils.ParameterToString(tag)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoDeleteTag";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/repos/{owner}/{repo}/tags/{tag}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDeleteTag", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a repository&#39;s tag by name 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="tag">name of tag to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RepoDeleteTagAsync(string owner, string repo, string tag, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RepoDeleteTagWithHttpInfoAsync(owner, repo, tag, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Delete a repository&#39;s tag by name 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="tag">name of tag to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> RepoDeleteTagWithHttpInfoAsync(string owner, string repo, string tag, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDeleteTag");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDeleteTag");
            }

            // verify the required parameter 'tag' is set
            if (tag == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'tag' when calling RepositoryApi->RepoDeleteTag");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("tag", Org.OpenAPITools.Client.ClientUtils.ParameterToString(tag)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoDeleteTag";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/repos/{owner}/{repo}/tags/{tag}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDeleteTag", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a team from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="team">team name</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RepoDeleteTeam(string owner, string repo, string team, int operationIndex = 0)
        {
            RepoDeleteTeamWithHttpInfo(owner, repo, team);
        }

        /// <summary>
        /// Delete a team from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="team">team name</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> RepoDeleteTeamWithHttpInfo(string owner, string repo, string team, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDeleteTeam");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDeleteTeam");
            }

            // verify the required parameter 'team' is set
            if (team == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'team' when calling RepositoryApi->RepoDeleteTeam");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("team", Org.OpenAPITools.Client.ClientUtils.ParameterToString(team)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoDeleteTeam";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/repos/{owner}/{repo}/teams/{team}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDeleteTeam", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a team from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="team">team name</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RepoDeleteTeamAsync(string owner, string repo, string team, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RepoDeleteTeamWithHttpInfoAsync(owner, repo, team, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Delete a team from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="team">team name</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> RepoDeleteTeamWithHttpInfoAsync(string owner, string repo, string team, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDeleteTeam");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDeleteTeam");
            }

            // verify the required parameter 'team' is set
            if (team == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'team' when calling RepositoryApi->RepoDeleteTeam");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("team", Org.OpenAPITools.Client.ClientUtils.ParameterToString(team)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoDeleteTeam";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/repos/{owner}/{repo}/teams/{team}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDeleteTeam", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a topic from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="topic">name of the topic to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RepoDeleteTopic(string owner, string repo, string topic, int operationIndex = 0)
        {
            RepoDeleteTopicWithHttpInfo(owner, repo, topic);
        }

        /// <summary>
        /// Delete a topic from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="topic">name of the topic to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> RepoDeleteTopicWithHttpInfo(string owner, string repo, string topic, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDeleteTopic");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDeleteTopic");
            }

            // verify the required parameter 'topic' is set
            if (topic == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'topic' when calling RepositoryApi->RepoDeleteTopic");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("topic", Org.OpenAPITools.Client.ClientUtils.ParameterToString(topic)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoDeleteTopic";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/repos/{owner}/{repo}/topics/{topic}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDeleteTopic", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a topic from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="topic">name of the topic to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RepoDeleteTopicAsync(string owner, string repo, string topic, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RepoDeleteTopicWithHttpInfoAsync(owner, repo, topic, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Delete a topic from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="topic">name of the topic to delete</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> RepoDeleteTopicWithHttpInfoAsync(string owner, string repo, string topic, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDeleteTopic");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDeleteTopic");
            }

            // verify the required parameter 'topic' is set
            if (topic == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'topic' when calling RepositoryApi->RepoDeleteTopic");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("topic", Org.OpenAPITools.Client.ClientUtils.ParameterToString(topic)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoDeleteTopic";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/repos/{owner}/{repo}/topics/{topic}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDeleteTopic", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a wiki page 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="pageName">name of the page</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RepoDeleteWikiPage(string owner, string repo, string pageName, int operationIndex = 0)
        {
            RepoDeleteWikiPageWithHttpInfo(owner, repo, pageName);
        }

        /// <summary>
        /// Delete a wiki page 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="pageName">name of the page</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> RepoDeleteWikiPageWithHttpInfo(string owner, string repo, string pageName, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDeleteWikiPage");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDeleteWikiPage");
            }

            // verify the required parameter 'pageName' is set
            if (pageName == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'pageName' when calling RepositoryApi->RepoDeleteWikiPage");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("pageName", Org.OpenAPITools.Client.ClientUtils.ParameterToString(pageName)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoDeleteWikiPage";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/repos/{owner}/{repo}/wiki/page/{pageName}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDeleteWikiPage", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete a wiki page 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="pageName">name of the page</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RepoDeleteWikiPageAsync(string owner, string repo, string pageName, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RepoDeleteWikiPageWithHttpInfoAsync(owner, repo, pageName, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Delete a wiki page 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="pageName">name of the page</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> RepoDeleteWikiPageWithHttpInfoAsync(string owner, string repo, string pageName, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDeleteWikiPage");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDeleteWikiPage");
            }

            // verify the required parameter 'pageName' is set
            if (pageName == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'pageName' when calling RepositoryApi->RepoDeleteWikiPage");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("pageName", Org.OpenAPITools.Client.ClientUtils.ParameterToString(pageName)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoDeleteWikiPage";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/repos/{owner}/{repo}/wiki/page/{pageName}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDeleteWikiPage", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Dismiss a review for a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PullReview</returns>
        public PullReview RepoDismissPullReview(string owner, string repo, long index, long id, DismissPullReviewOptions body, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<PullReview> localVarResponse = RepoDismissPullReviewWithHttpInfo(owner, repo, index, id, body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Dismiss a review for a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PullReview</returns>
        public Org.OpenAPITools.Client.ApiResponse<PullReview> RepoDismissPullReviewWithHttpInfo(string owner, string repo, long index, long id, DismissPullReviewOptions body, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDismissPullReview");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDismissPullReview");
            }

            // verify the required parameter 'body' is set
            if (body == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'body' when calling RepositoryApi->RepoDismissPullReview");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json",
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoDismissPullReview";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<PullReview>("/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/dismissals", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDismissPullReview", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Dismiss a review for a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PullReview</returns>
        public async System.Threading.Tasks.Task<PullReview> RepoDismissPullReviewAsync(string owner, string repo, long index, long id, DismissPullReviewOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<PullReview> localVarResponse = await RepoDismissPullReviewWithHttpInfoAsync(owner, repo, index, id, body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Dismiss a review for a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PullReview)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<PullReview>> RepoDismissPullReviewWithHttpInfoAsync(string owner, string repo, long index, long id, DismissPullReviewOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDismissPullReview");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDismissPullReview");
            }

            // verify the required parameter 'body' is set
            if (body == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'body' when calling RepositoryApi->RepoDismissPullReview");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json", 
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoDismissPullReview";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<PullReview>("/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/dismissals", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDismissPullReview", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a commit&#39;s diff or patch 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">SHA of the commit to get</param>
        /// <param name="diffType">whether the output is diff or patch</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>string</returns>
        public string RepoDownloadCommitDiffOrPatch(string owner, string repo, string sha, string diffType, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<string> localVarResponse = RepoDownloadCommitDiffOrPatchWithHttpInfo(owner, repo, sha, diffType);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a commit&#39;s diff or patch 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">SHA of the commit to get</param>
        /// <param name="diffType">whether the output is diff or patch</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of string</returns>
        public Org.OpenAPITools.Client.ApiResponse<string> RepoDownloadCommitDiffOrPatchWithHttpInfo(string owner, string repo, string sha, string diffType, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDownloadCommitDiffOrPatch");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDownloadCommitDiffOrPatch");
            }

            // verify the required parameter 'sha' is set
            if (sha == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'sha' when calling RepositoryApi->RepoDownloadCommitDiffOrPatch");
            }

            // verify the required parameter 'diffType' is set
            if (diffType == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'diffType' when calling RepositoryApi->RepoDownloadCommitDiffOrPatch");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("sha", Org.OpenAPITools.Client.ClientUtils.ParameterToString(sha)); // path parameter
            localVarRequestOptions.PathParameters.Add("diffType", Org.OpenAPITools.Client.ClientUtils.ParameterToString(diffType)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoDownloadCommitDiffOrPatch";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<string>("/repos/{owner}/{repo}/git/commits/{sha}.{diffType}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDownloadCommitDiffOrPatch", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a commit&#39;s diff or patch 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">SHA of the commit to get</param>
        /// <param name="diffType">whether the output is diff or patch</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> RepoDownloadCommitDiffOrPatchAsync(string owner, string repo, string sha, string diffType, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<string> localVarResponse = await RepoDownloadCommitDiffOrPatchWithHttpInfoAsync(owner, repo, sha, diffType, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a commit&#39;s diff or patch 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">SHA of the commit to get</param>
        /// <param name="diffType">whether the output is diff or patch</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<string>> RepoDownloadCommitDiffOrPatchWithHttpInfoAsync(string owner, string repo, string sha, string diffType, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDownloadCommitDiffOrPatch");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDownloadCommitDiffOrPatch");
            }

            // verify the required parameter 'sha' is set
            if (sha == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'sha' when calling RepositoryApi->RepoDownloadCommitDiffOrPatch");
            }

            // verify the required parameter 'diffType' is set
            if (diffType == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'diffType' when calling RepositoryApi->RepoDownloadCommitDiffOrPatch");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("sha", Org.OpenAPITools.Client.ClientUtils.ParameterToString(sha)); // path parameter
            localVarRequestOptions.PathParameters.Add("diffType", Org.OpenAPITools.Client.ClientUtils.ParameterToString(diffType)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoDownloadCommitDiffOrPatch";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<string>("/repos/{owner}/{repo}/git/commits/{sha}.{diffType}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDownloadCommitDiffOrPatch", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a pull request diff or patch 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="diffType">whether the output is diff or patch</param>
        /// <param name="binary">whether to include binary file changes. if true, the diff is applicable with &#x60;git apply&#x60; (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>string</returns>
        public string RepoDownloadPullDiffOrPatch(string owner, string repo, long index, string diffType, bool? binary = default(bool?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<string> localVarResponse = RepoDownloadPullDiffOrPatchWithHttpInfo(owner, repo, index, diffType, binary);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a pull request diff or patch 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="diffType">whether the output is diff or patch</param>
        /// <param name="binary">whether to include binary file changes. if true, the diff is applicable with &#x60;git apply&#x60; (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of string</returns>
        public Org.OpenAPITools.Client.ApiResponse<string> RepoDownloadPullDiffOrPatchWithHttpInfo(string owner, string repo, long index, string diffType, bool? binary = default(bool?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDownloadPullDiffOrPatch");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDownloadPullDiffOrPatch");
            }

            // verify the required parameter 'diffType' is set
            if (diffType == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'diffType' when calling RepositoryApi->RepoDownloadPullDiffOrPatch");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter
            localVarRequestOptions.PathParameters.Add("diffType", Org.OpenAPITools.Client.ClientUtils.ParameterToString(diffType)); // path parameter
            if (binary != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "binary", binary));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoDownloadPullDiffOrPatch";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<string>("/repos/{owner}/{repo}/pulls/{index}.{diffType}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDownloadPullDiffOrPatch", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a pull request diff or patch 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="diffType">whether the output is diff or patch</param>
        /// <param name="binary">whether to include binary file changes. if true, the diff is applicable with &#x60;git apply&#x60; (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> RepoDownloadPullDiffOrPatchAsync(string owner, string repo, long index, string diffType, bool? binary = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<string> localVarResponse = await RepoDownloadPullDiffOrPatchWithHttpInfoAsync(owner, repo, index, diffType, binary, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a pull request diff or patch 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="diffType">whether the output is diff or patch</param>
        /// <param name="binary">whether to include binary file changes. if true, the diff is applicable with &#x60;git apply&#x60; (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<string>> RepoDownloadPullDiffOrPatchWithHttpInfoAsync(string owner, string repo, long index, string diffType, bool? binary = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoDownloadPullDiffOrPatch");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoDownloadPullDiffOrPatch");
            }

            // verify the required parameter 'diffType' is set
            if (diffType == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'diffType' when calling RepositoryApi->RepoDownloadPullDiffOrPatch");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter
            localVarRequestOptions.PathParameters.Add("diffType", Org.OpenAPITools.Client.ClientUtils.ParameterToString(diffType)); // path parameter
            if (binary != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "binary", binary));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoDownloadPullDiffOrPatch";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<string>("/repos/{owner}/{repo}/pulls/{index}.{diffType}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoDownloadPullDiffOrPatch", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Edit a repository&#39;s properties. Only fields that are set will be changed. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to edit</param>
        /// <param name="repo">name of the repo to edit</param>
        /// <param name="body">Properties of a repo that you can edit (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Repository</returns>
        public Repository RepoEdit(string owner, string repo, EditRepoOption? body = default(EditRepoOption?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<Repository> localVarResponse = RepoEditWithHttpInfo(owner, repo, body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Edit a repository&#39;s properties. Only fields that are set will be changed. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to edit</param>
        /// <param name="repo">name of the repo to edit</param>
        /// <param name="body">Properties of a repo that you can edit (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Repository</returns>
        public Org.OpenAPITools.Client.ApiResponse<Repository> RepoEditWithHttpInfo(string owner, string repo, EditRepoOption? body = default(EditRepoOption?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoEdit");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoEdit");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json",
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoEdit";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Patch<Repository>("/repos/{owner}/{repo}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoEdit", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Edit a repository&#39;s properties. Only fields that are set will be changed. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to edit</param>
        /// <param name="repo">name of the repo to edit</param>
        /// <param name="body">Properties of a repo that you can edit (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Repository</returns>
        public async System.Threading.Tasks.Task<Repository> RepoEditAsync(string owner, string repo, EditRepoOption? body = default(EditRepoOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<Repository> localVarResponse = await RepoEditWithHttpInfoAsync(owner, repo, body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Edit a repository&#39;s properties. Only fields that are set will be changed. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to edit</param>
        /// <param name="repo">name of the repo to edit</param>
        /// <param name="body">Properties of a repo that you can edit (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Repository)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Repository>> RepoEditWithHttpInfoAsync(string owner, string repo, EditRepoOption? body = default(EditRepoOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoEdit");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoEdit");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json", 
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoEdit";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PatchAsync<Repository>("/repos/{owner}/{repo}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoEdit", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Edit a branch protections for a repository. Only fields that are set will be changed 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">name of protected branch</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>BranchProtection</returns>
        public BranchProtection RepoEditBranchProtection(string owner, string repo, string name, EditBranchProtectionOption? body = default(EditBranchProtectionOption?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<BranchProtection> localVarResponse = RepoEditBranchProtectionWithHttpInfo(owner, repo, name, body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Edit a branch protections for a repository. Only fields that are set will be changed 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">name of protected branch</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of BranchProtection</returns>
        public Org.OpenAPITools.Client.ApiResponse<BranchProtection> RepoEditBranchProtectionWithHttpInfo(string owner, string repo, string name, EditBranchProtectionOption? body = default(EditBranchProtectionOption?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoEditBranchProtection");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoEditBranchProtection");
            }

            // verify the required parameter 'name' is set
            if (name == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'name' when calling RepositoryApi->RepoEditBranchProtection");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("name", Org.OpenAPITools.Client.ClientUtils.ParameterToString(name)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoEditBranchProtection";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Patch<BranchProtection>("/repos/{owner}/{repo}/branch_protections/{name}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoEditBranchProtection", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Edit a branch protections for a repository. Only fields that are set will be changed 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">name of protected branch</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BranchProtection</returns>
        public async System.Threading.Tasks.Task<BranchProtection> RepoEditBranchProtectionAsync(string owner, string repo, string name, EditBranchProtectionOption? body = default(EditBranchProtectionOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<BranchProtection> localVarResponse = await RepoEditBranchProtectionWithHttpInfoAsync(owner, repo, name, body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Edit a branch protections for a repository. Only fields that are set will be changed 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">name of protected branch</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BranchProtection)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<BranchProtection>> RepoEditBranchProtectionWithHttpInfoAsync(string owner, string repo, string name, EditBranchProtectionOption? body = default(EditBranchProtectionOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoEditBranchProtection");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoEditBranchProtection");
            }

            // verify the required parameter 'name' is set
            if (name == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'name' when calling RepositoryApi->RepoEditBranchProtection");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("name", Org.OpenAPITools.Client.ClientUtils.ParameterToString(name)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoEditBranchProtection";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PatchAsync<BranchProtection>("/repos/{owner}/{repo}/branch_protections/{name}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoEditBranchProtection", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Edit a Git hook in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to get</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>GitHook</returns>
        public GitHook RepoEditGitHook(string owner, string repo, string id, EditGitHookOption? body = default(EditGitHookOption?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<GitHook> localVarResponse = RepoEditGitHookWithHttpInfo(owner, repo, id, body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Edit a Git hook in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to get</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of GitHook</returns>
        public Org.OpenAPITools.Client.ApiResponse<GitHook> RepoEditGitHookWithHttpInfo(string owner, string repo, string id, EditGitHookOption? body = default(EditGitHookOption?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoEditGitHook");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoEditGitHook");
            }

            // verify the required parameter 'id' is set
            if (id == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'id' when calling RepositoryApi->RepoEditGitHook");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json",
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoEditGitHook";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Patch<GitHook>("/repos/{owner}/{repo}/hooks/git/{id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoEditGitHook", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Edit a Git hook in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to get</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GitHook</returns>
        public async System.Threading.Tasks.Task<GitHook> RepoEditGitHookAsync(string owner, string repo, string id, EditGitHookOption? body = default(EditGitHookOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<GitHook> localVarResponse = await RepoEditGitHookWithHttpInfoAsync(owner, repo, id, body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Edit a Git hook in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to get</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GitHook)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<GitHook>> RepoEditGitHookWithHttpInfoAsync(string owner, string repo, string id, EditGitHookOption? body = default(EditGitHookOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoEditGitHook");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoEditGitHook");
            }

            // verify the required parameter 'id' is set
            if (id == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'id' when calling RepositoryApi->RepoEditGitHook");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json", 
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoEditGitHook";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PatchAsync<GitHook>("/repos/{owner}/{repo}/hooks/git/{id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoEditGitHook", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Edit a hook in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">index of the hook</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Hook</returns>
        public Hook RepoEditHook(string owner, string repo, long id, EditHookOption? body = default(EditHookOption?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<Hook> localVarResponse = RepoEditHookWithHttpInfo(owner, repo, id, body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Edit a hook in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">index of the hook</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Hook</returns>
        public Org.OpenAPITools.Client.ApiResponse<Hook> RepoEditHookWithHttpInfo(string owner, string repo, long id, EditHookOption? body = default(EditHookOption?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoEditHook");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoEditHook");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json",
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoEditHook";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Patch<Hook>("/repos/{owner}/{repo}/hooks/{id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoEditHook", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Edit a hook in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">index of the hook</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Hook</returns>
        public async System.Threading.Tasks.Task<Hook> RepoEditHookAsync(string owner, string repo, long id, EditHookOption? body = default(EditHookOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<Hook> localVarResponse = await RepoEditHookWithHttpInfoAsync(owner, repo, id, body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Edit a hook in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">index of the hook</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Hook)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Hook>> RepoEditHookWithHttpInfoAsync(string owner, string repo, long id, EditHookOption? body = default(EditHookOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoEditHook");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoEditHook");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json", 
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoEditHook";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PatchAsync<Hook>("/repos/{owner}/{repo}/hooks/{id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoEditHook", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update a pull request. If using deadline only the date will be taken into account, and time of day ignored. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to edit</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PullRequest</returns>
        public PullRequest RepoEditPullRequest(string owner, string repo, long index, EditPullRequestOption? body = default(EditPullRequestOption?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<PullRequest> localVarResponse = RepoEditPullRequestWithHttpInfo(owner, repo, index, body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Update a pull request. If using deadline only the date will be taken into account, and time of day ignored. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to edit</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PullRequest</returns>
        public Org.OpenAPITools.Client.ApiResponse<PullRequest> RepoEditPullRequestWithHttpInfo(string owner, string repo, long index, EditPullRequestOption? body = default(EditPullRequestOption?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoEditPullRequest");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoEditPullRequest");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoEditPullRequest";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Patch<PullRequest>("/repos/{owner}/{repo}/pulls/{index}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoEditPullRequest", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update a pull request. If using deadline only the date will be taken into account, and time of day ignored. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to edit</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PullRequest</returns>
        public async System.Threading.Tasks.Task<PullRequest> RepoEditPullRequestAsync(string owner, string repo, long index, EditPullRequestOption? body = default(EditPullRequestOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<PullRequest> localVarResponse = await RepoEditPullRequestWithHttpInfoAsync(owner, repo, index, body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Update a pull request. If using deadline only the date will be taken into account, and time of day ignored. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to edit</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PullRequest)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<PullRequest>> RepoEditPullRequestWithHttpInfoAsync(string owner, string repo, long index, EditPullRequestOption? body = default(EditPullRequestOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoEditPullRequest");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoEditPullRequest");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoEditPullRequest";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PatchAsync<PullRequest>("/repos/{owner}/{repo}/pulls/{index}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoEditPullRequest", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update a release 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release to edit</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Release</returns>
        public Release RepoEditRelease(string owner, string repo, long id, EditReleaseOption? body = default(EditReleaseOption?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<Release> localVarResponse = RepoEditReleaseWithHttpInfo(owner, repo, id, body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Update a release 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release to edit</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Release</returns>
        public Org.OpenAPITools.Client.ApiResponse<Release> RepoEditReleaseWithHttpInfo(string owner, string repo, long id, EditReleaseOption? body = default(EditReleaseOption?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoEditRelease");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoEditRelease");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoEditRelease";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Patch<Release>("/repos/{owner}/{repo}/releases/{id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoEditRelease", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update a release 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release to edit</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Release</returns>
        public async System.Threading.Tasks.Task<Release> RepoEditReleaseAsync(string owner, string repo, long id, EditReleaseOption? body = default(EditReleaseOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<Release> localVarResponse = await RepoEditReleaseWithHttpInfoAsync(owner, repo, id, body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Update a release 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release to edit</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Release)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Release>> RepoEditReleaseWithHttpInfoAsync(string owner, string repo, long id, EditReleaseOption? body = default(EditReleaseOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoEditRelease");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoEditRelease");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoEditRelease";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PatchAsync<Release>("/repos/{owner}/{repo}/releases/{id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoEditRelease", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Edit a release attachment 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="attachmentId">id of the attachment to edit</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Attachment</returns>
        public Attachment RepoEditReleaseAttachment(string owner, string repo, long id, long attachmentId, EditAttachmentOptions? body = default(EditAttachmentOptions?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<Attachment> localVarResponse = RepoEditReleaseAttachmentWithHttpInfo(owner, repo, id, attachmentId, body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Edit a release attachment 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="attachmentId">id of the attachment to edit</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Attachment</returns>
        public Org.OpenAPITools.Client.ApiResponse<Attachment> RepoEditReleaseAttachmentWithHttpInfo(string owner, string repo, long id, long attachmentId, EditAttachmentOptions? body = default(EditAttachmentOptions?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoEditReleaseAttachment");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoEditReleaseAttachment");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.PathParameters.Add("attachment_id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(attachmentId)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoEditReleaseAttachment";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Patch<Attachment>("/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoEditReleaseAttachment", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Edit a release attachment 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="attachmentId">id of the attachment to edit</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Attachment</returns>
        public async System.Threading.Tasks.Task<Attachment> RepoEditReleaseAttachmentAsync(string owner, string repo, long id, long attachmentId, EditAttachmentOptions? body = default(EditAttachmentOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<Attachment> localVarResponse = await RepoEditReleaseAttachmentWithHttpInfoAsync(owner, repo, id, attachmentId, body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Edit a release attachment 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="attachmentId">id of the attachment to edit</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Attachment)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Attachment>> RepoEditReleaseAttachmentWithHttpInfoAsync(string owner, string repo, long id, long attachmentId, EditAttachmentOptions? body = default(EditAttachmentOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoEditReleaseAttachment");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoEditReleaseAttachment");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.PathParameters.Add("attachment_id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(attachmentId)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoEditReleaseAttachment";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PatchAsync<Attachment>("/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoEditReleaseAttachment", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Edit a wiki page 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="pageName">name of the page</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>WikiPage</returns>
        public WikiPage RepoEditWikiPage(string owner, string repo, string pageName, CreateWikiPageOptions? body = default(CreateWikiPageOptions?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<WikiPage> localVarResponse = RepoEditWikiPageWithHttpInfo(owner, repo, pageName, body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Edit a wiki page 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="pageName">name of the page</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of WikiPage</returns>
        public Org.OpenAPITools.Client.ApiResponse<WikiPage> RepoEditWikiPageWithHttpInfo(string owner, string repo, string pageName, CreateWikiPageOptions? body = default(CreateWikiPageOptions?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoEditWikiPage");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoEditWikiPage");
            }

            // verify the required parameter 'pageName' is set
            if (pageName == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'pageName' when calling RepositoryApi->RepoEditWikiPage");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "text/html"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("pageName", Org.OpenAPITools.Client.ClientUtils.ParameterToString(pageName)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoEditWikiPage";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Patch<WikiPage>("/repos/{owner}/{repo}/wiki/page/{pageName}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoEditWikiPage", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Edit a wiki page 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="pageName">name of the page</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of WikiPage</returns>
        public async System.Threading.Tasks.Task<WikiPage> RepoEditWikiPageAsync(string owner, string repo, string pageName, CreateWikiPageOptions? body = default(CreateWikiPageOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<WikiPage> localVarResponse = await RepoEditWikiPageWithHttpInfoAsync(owner, repo, pageName, body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Edit a wiki page 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="pageName">name of the page</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (WikiPage)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<WikiPage>> RepoEditWikiPageWithHttpInfoAsync(string owner, string repo, string pageName, CreateWikiPageOptions? body = default(CreateWikiPageOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoEditWikiPage");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoEditWikiPage");
            }

            // verify the required parameter 'pageName' is set
            if (pageName == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'pageName' when calling RepositoryApi->RepoEditWikiPage");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "text/html"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("pageName", Org.OpenAPITools.Client.ClientUtils.ParameterToString(pageName)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoEditWikiPage";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PatchAsync<WikiPage>("/repos/{owner}/{repo}/wiki/page/{pageName}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoEditWikiPage", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Repository</returns>
        public Repository RepoGet(string owner, string repo, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<Repository> localVarResponse = RepoGetWithHttpInfo(owner, repo);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Repository</returns>
        public Org.OpenAPITools.Client.ApiResponse<Repository> RepoGetWithHttpInfo(string owner, string repo, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGet");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGet");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGet";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Repository>("/repos/{owner}/{repo}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGet", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Repository</returns>
        public async System.Threading.Tasks.Task<Repository> RepoGetAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<Repository> localVarResponse = await RepoGetWithHttpInfoAsync(owner, repo, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Repository)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Repository>> RepoGetWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGet");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGet");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGet";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Repository>("/repos/{owner}/{repo}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGet", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a list of all commits from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">SHA or branch to start listing commits from (usually &#39;master&#39;) (optional)</param>
        /// <param name="path">filepath of a file/dir (optional)</param>
        /// <param name="stat">include diff stats for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="verification">include verification for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="files">include a list of affected files for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (ignored if used with &#39;path&#39;) (optional)</param>
        /// <param name="not">commits that match the given specifier will not be listed. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;Commit&gt;</returns>
        public List<Commit> RepoGetAllCommits(string owner, string repo, string? sha = default(string?), string? path = default(string?), bool? stat = default(bool?), bool? verification = default(bool?), bool? files = default(bool?), int? page = default(int?), int? limit = default(int?), string? not = default(string?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<Commit>> localVarResponse = RepoGetAllCommitsWithHttpInfo(owner, repo, sha, path, stat, verification, files, page, limit, not);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a list of all commits from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">SHA or branch to start listing commits from (usually &#39;master&#39;) (optional)</param>
        /// <param name="path">filepath of a file/dir (optional)</param>
        /// <param name="stat">include diff stats for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="verification">include verification for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="files">include a list of affected files for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (ignored if used with &#39;path&#39;) (optional)</param>
        /// <param name="not">commits that match the given specifier will not be listed. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;Commit&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<Commit>> RepoGetAllCommitsWithHttpInfo(string owner, string repo, string? sha = default(string?), string? path = default(string?), bool? stat = default(bool?), bool? verification = default(bool?), bool? files = default(bool?), int? page = default(int?), int? limit = default(int?), string? not = default(string?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetAllCommits");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetAllCommits");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (sha != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sha", sha));
            }
            if (path != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "path", path));
            }
            if (stat != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "stat", stat));
            }
            if (verification != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "verification", verification));
            }
            if (files != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "files", files));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (not != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "not", not));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetAllCommits";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<Commit>>("/repos/{owner}/{repo}/commits", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetAllCommits", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a list of all commits from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">SHA or branch to start listing commits from (usually &#39;master&#39;) (optional)</param>
        /// <param name="path">filepath of a file/dir (optional)</param>
        /// <param name="stat">include diff stats for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="verification">include verification for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="files">include a list of affected files for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (ignored if used with &#39;path&#39;) (optional)</param>
        /// <param name="not">commits that match the given specifier will not be listed. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Commit&gt;</returns>
        public async System.Threading.Tasks.Task<List<Commit>> RepoGetAllCommitsAsync(string owner, string repo, string? sha = default(string?), string? path = default(string?), bool? stat = default(bool?), bool? verification = default(bool?), bool? files = default(bool?), int? page = default(int?), int? limit = default(int?), string? not = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<Commit>> localVarResponse = await RepoGetAllCommitsWithHttpInfoAsync(owner, repo, sha, path, stat, verification, files, page, limit, not, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a list of all commits from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">SHA or branch to start listing commits from (usually &#39;master&#39;) (optional)</param>
        /// <param name="path">filepath of a file/dir (optional)</param>
        /// <param name="stat">include diff stats for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="verification">include verification for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="files">include a list of affected files for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (ignored if used with &#39;path&#39;) (optional)</param>
        /// <param name="not">commits that match the given specifier will not be listed. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Commit&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<Commit>>> RepoGetAllCommitsWithHttpInfoAsync(string owner, string repo, string? sha = default(string?), string? path = default(string?), bool? stat = default(bool?), bool? verification = default(bool?), bool? files = default(bool?), int? page = default(int?), int? limit = default(int?), string? not = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetAllCommits");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetAllCommits");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (sha != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sha", sha));
            }
            if (path != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "path", path));
            }
            if (stat != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "stat", stat));
            }
            if (verification != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "verification", verification));
            }
            if (files != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "files", files));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (not != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "not", not));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetAllCommits";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<Commit>>("/repos/{owner}/{repo}/commits", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetAllCommits", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get an archive of a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="archive">the git reference for download with attached archive format (e.g. master.zip)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RepoGetArchive(string owner, string repo, string archive, int operationIndex = 0)
        {
            RepoGetArchiveWithHttpInfo(owner, repo, archive);
        }

        /// <summary>
        /// Get an archive of a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="archive">the git reference for download with attached archive format (e.g. master.zip)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> RepoGetArchiveWithHttpInfo(string owner, string repo, string archive, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetArchive");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetArchive");
            }

            // verify the required parameter 'archive' is set
            if (archive == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'archive' when calling RepositoryApi->RepoGetArchive");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("archive", Org.OpenAPITools.Client.ClientUtils.ParameterToString(archive)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetArchive";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Object>("/repos/{owner}/{repo}/archive/{archive}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetArchive", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get an archive of a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="archive">the git reference for download with attached archive format (e.g. master.zip)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RepoGetArchiveAsync(string owner, string repo, string archive, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RepoGetArchiveWithHttpInfoAsync(owner, repo, archive, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get an archive of a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="archive">the git reference for download with attached archive format (e.g. master.zip)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> RepoGetArchiveWithHttpInfoAsync(string owner, string repo, string archive, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetArchive");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetArchive");
            }

            // verify the required parameter 'archive' is set
            if (archive == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'archive' when calling RepositoryApi->RepoGetArchive");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("archive", Org.OpenAPITools.Client.ClientUtils.ParameterToString(archive)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetArchive";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Object>("/repos/{owner}/{repo}/archive/{archive}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetArchive", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Return all users that have write access and can be assigned to issues 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;User&gt;</returns>
        public List<User> RepoGetAssignees(string owner, string repo, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<User>> localVarResponse = RepoGetAssigneesWithHttpInfo(owner, repo);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Return all users that have write access and can be assigned to issues 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;User&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<User>> RepoGetAssigneesWithHttpInfo(string owner, string repo, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetAssignees");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetAssignees");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetAssignees";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<User>>("/repos/{owner}/{repo}/assignees", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetAssignees", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Return all users that have write access and can be assigned to issues 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;User&gt;</returns>
        public async System.Threading.Tasks.Task<List<User>> RepoGetAssigneesAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<User>> localVarResponse = await RepoGetAssigneesWithHttpInfoAsync(owner, repo, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Return all users that have write access and can be assigned to issues 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;User&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<User>>> RepoGetAssigneesWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetAssignees");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetAssignees");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetAssignees";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<User>>("/repos/{owner}/{repo}/assignees", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetAssignees", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieve a specific branch from a repository, including its effective branch protection 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="branch">branch to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Branch</returns>
        public Branch RepoGetBranch(string owner, string repo, string branch, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<Branch> localVarResponse = RepoGetBranchWithHttpInfo(owner, repo, branch);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve a specific branch from a repository, including its effective branch protection 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="branch">branch to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Branch</returns>
        public Org.OpenAPITools.Client.ApiResponse<Branch> RepoGetBranchWithHttpInfo(string owner, string repo, string branch, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetBranch");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetBranch");
            }

            // verify the required parameter 'branch' is set
            if (branch == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'branch' when calling RepositoryApi->RepoGetBranch");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("branch", Org.OpenAPITools.Client.ClientUtils.ParameterToString(branch)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetBranch";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Branch>("/repos/{owner}/{repo}/branches/{branch}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetBranch", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieve a specific branch from a repository, including its effective branch protection 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="branch">branch to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Branch</returns>
        public async System.Threading.Tasks.Task<Branch> RepoGetBranchAsync(string owner, string repo, string branch, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<Branch> localVarResponse = await RepoGetBranchWithHttpInfoAsync(owner, repo, branch, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve a specific branch from a repository, including its effective branch protection 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="branch">branch to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Branch)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Branch>> RepoGetBranchWithHttpInfoAsync(string owner, string repo, string branch, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetBranch");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetBranch");
            }

            // verify the required parameter 'branch' is set
            if (branch == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'branch' when calling RepositoryApi->RepoGetBranch");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("branch", Org.OpenAPITools.Client.ClientUtils.ParameterToString(branch)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetBranch";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Branch>("/repos/{owner}/{repo}/branches/{branch}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetBranch", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a specific branch protection for the repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">name of protected branch</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>BranchProtection</returns>
        public BranchProtection RepoGetBranchProtection(string owner, string repo, string name, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<BranchProtection> localVarResponse = RepoGetBranchProtectionWithHttpInfo(owner, repo, name);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a specific branch protection for the repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">name of protected branch</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of BranchProtection</returns>
        public Org.OpenAPITools.Client.ApiResponse<BranchProtection> RepoGetBranchProtectionWithHttpInfo(string owner, string repo, string name, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetBranchProtection");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetBranchProtection");
            }

            // verify the required parameter 'name' is set
            if (name == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'name' when calling RepositoryApi->RepoGetBranchProtection");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("name", Org.OpenAPITools.Client.ClientUtils.ParameterToString(name)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetBranchProtection";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<BranchProtection>("/repos/{owner}/{repo}/branch_protections/{name}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetBranchProtection", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a specific branch protection for the repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">name of protected branch</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BranchProtection</returns>
        public async System.Threading.Tasks.Task<BranchProtection> RepoGetBranchProtectionAsync(string owner, string repo, string name, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<BranchProtection> localVarResponse = await RepoGetBranchProtectionWithHttpInfoAsync(owner, repo, name, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a specific branch protection for the repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">name of protected branch</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BranchProtection)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<BranchProtection>> RepoGetBranchProtectionWithHttpInfoAsync(string owner, string repo, string name, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetBranchProtection");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetBranchProtection");
            }

            // verify the required parameter 'name' is set
            if (name == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'name' when calling RepositoryApi->RepoGetBranchProtection");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("name", Org.OpenAPITools.Client.ClientUtils.ParameterToString(name)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetBranchProtection";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<BranchProtection>("/repos/{owner}/{repo}/branch_protections/{name}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetBranchProtection", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a repository by id 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">id of the repo to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Repository</returns>
        public Repository RepoGetByID(long id, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<Repository> localVarResponse = RepoGetByIDWithHttpInfo(id);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a repository by id 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">id of the repo to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Repository</returns>
        public Org.OpenAPITools.Client.ApiResponse<Repository> RepoGetByIDWithHttpInfo(long id, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetByID";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Repository>("/repositories/{id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetByID", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a repository by id 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">id of the repo to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Repository</returns>
        public async System.Threading.Tasks.Task<Repository> RepoGetByIDAsync(long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<Repository> localVarResponse = await RepoGetByIDWithHttpInfoAsync(id, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a repository by id 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">id of the repo to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Repository)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Repository>> RepoGetByIDWithHttpInfoAsync(long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetByID";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Repository>("/repositories/{id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetByID", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a commit&#39;s combined status, by branch/tag/commit reference 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varRef">name of branch/tag/commit</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>CombinedStatus</returns>
        public CombinedStatus RepoGetCombinedStatusByRef(string owner, string repo, string varRef, int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<CombinedStatus> localVarResponse = RepoGetCombinedStatusByRefWithHttpInfo(owner, repo, varRef, page, limit);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a commit&#39;s combined status, by branch/tag/commit reference 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varRef">name of branch/tag/commit</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of CombinedStatus</returns>
        public Org.OpenAPITools.Client.ApiResponse<CombinedStatus> RepoGetCombinedStatusByRefWithHttpInfo(string owner, string repo, string varRef, int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetCombinedStatusByRef");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetCombinedStatusByRef");
            }

            // verify the required parameter 'varRef' is set
            if (varRef == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'varRef' when calling RepositoryApi->RepoGetCombinedStatusByRef");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("ref", Org.OpenAPITools.Client.ClientUtils.ParameterToString(varRef)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetCombinedStatusByRef";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<CombinedStatus>("/repos/{owner}/{repo}/commits/{ref}/status", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetCombinedStatusByRef", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a commit&#39;s combined status, by branch/tag/commit reference 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varRef">name of branch/tag/commit</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CombinedStatus</returns>
        public async System.Threading.Tasks.Task<CombinedStatus> RepoGetCombinedStatusByRefAsync(string owner, string repo, string varRef, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<CombinedStatus> localVarResponse = await RepoGetCombinedStatusByRefWithHttpInfoAsync(owner, repo, varRef, page, limit, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a commit&#39;s combined status, by branch/tag/commit reference 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varRef">name of branch/tag/commit</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CombinedStatus)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<CombinedStatus>> RepoGetCombinedStatusByRefWithHttpInfoAsync(string owner, string repo, string varRef, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetCombinedStatusByRef");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetCombinedStatusByRef");
            }

            // verify the required parameter 'varRef' is set
            if (varRef == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'varRef' when calling RepositoryApi->RepoGetCombinedStatusByRef");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("ref", Org.OpenAPITools.Client.ClientUtils.ParameterToString(varRef)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetCombinedStatusByRef";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<CombinedStatus>("/repos/{owner}/{repo}/commits/{ref}/status", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetCombinedStatusByRef", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get the pull request of the commit 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">SHA of the commit to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PullRequest</returns>
        public PullRequest RepoGetCommitPullRequest(string owner, string repo, string sha, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<PullRequest> localVarResponse = RepoGetCommitPullRequestWithHttpInfo(owner, repo, sha);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get the pull request of the commit 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">SHA of the commit to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PullRequest</returns>
        public Org.OpenAPITools.Client.ApiResponse<PullRequest> RepoGetCommitPullRequestWithHttpInfo(string owner, string repo, string sha, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetCommitPullRequest");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetCommitPullRequest");
            }

            // verify the required parameter 'sha' is set
            if (sha == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'sha' when calling RepositoryApi->RepoGetCommitPullRequest");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("sha", Org.OpenAPITools.Client.ClientUtils.ParameterToString(sha)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetCommitPullRequest";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PullRequest>("/repos/{owner}/{repo}/commits/{sha}/pull", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetCommitPullRequest", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get the pull request of the commit 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">SHA of the commit to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PullRequest</returns>
        public async System.Threading.Tasks.Task<PullRequest> RepoGetCommitPullRequestAsync(string owner, string repo, string sha, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<PullRequest> localVarResponse = await RepoGetCommitPullRequestWithHttpInfoAsync(owner, repo, sha, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get the pull request of the commit 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">SHA of the commit to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PullRequest)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<PullRequest>> RepoGetCommitPullRequestWithHttpInfoAsync(string owner, string repo, string sha, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetCommitPullRequest");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetCommitPullRequest");
            }

            // verify the required parameter 'sha' is set
            if (sha == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'sha' when calling RepositoryApi->RepoGetCommitPullRequest");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("sha", Org.OpenAPITools.Client.ClientUtils.ParameterToString(sha)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetCommitPullRequest";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PullRequest>("/repos/{owner}/{repo}/commits/{sha}/pull", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetCommitPullRequest", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">path of the dir, file, symlink or submodule in the repo</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ContentsResponse</returns>
        public ContentsResponse RepoGetContents(string owner, string repo, string filepath, string? varRef = default(string?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<ContentsResponse> localVarResponse = RepoGetContentsWithHttpInfo(owner, repo, filepath, varRef);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">path of the dir, file, symlink or submodule in the repo</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ContentsResponse</returns>
        public Org.OpenAPITools.Client.ApiResponse<ContentsResponse> RepoGetContentsWithHttpInfo(string owner, string repo, string filepath, string? varRef = default(string?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetContents");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetContents");
            }

            // verify the required parameter 'filepath' is set
            if (filepath == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'filepath' when calling RepositoryApi->RepoGetContents");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("filepath", Org.OpenAPITools.Client.ClientUtils.ParameterToString(filepath)); // path parameter
            if (varRef != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "ref", varRef));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetContents";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<ContentsResponse>("/repos/{owner}/{repo}/contents/{filepath}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetContents", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">path of the dir, file, symlink or submodule in the repo</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ContentsResponse</returns>
        public async System.Threading.Tasks.Task<ContentsResponse> RepoGetContentsAsync(string owner, string repo, string filepath, string? varRef = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<ContentsResponse> localVarResponse = await RepoGetContentsWithHttpInfoAsync(owner, repo, filepath, varRef, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">path of the dir, file, symlink or submodule in the repo</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ContentsResponse)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<ContentsResponse>> RepoGetContentsWithHttpInfoAsync(string owner, string repo, string filepath, string? varRef = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetContents");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetContents");
            }

            // verify the required parameter 'filepath' is set
            if (filepath == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'filepath' when calling RepositoryApi->RepoGetContents");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("filepath", Org.OpenAPITools.Client.ClientUtils.ParameterToString(filepath)); // path parameter
            if (varRef != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "ref", varRef));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetContents";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<ContentsResponse>("/repos/{owner}/{repo}/contents/{filepath}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetContents", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets the metadata of all the entries of the root dir 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;ContentsResponse&gt;</returns>
        public List<ContentsResponse> RepoGetContentsList(string owner, string repo, string? varRef = default(string?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<ContentsResponse>> localVarResponse = RepoGetContentsListWithHttpInfo(owner, repo, varRef);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets the metadata of all the entries of the root dir 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;ContentsResponse&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<ContentsResponse>> RepoGetContentsListWithHttpInfo(string owner, string repo, string? varRef = default(string?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetContentsList");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetContentsList");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (varRef != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "ref", varRef));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetContentsList";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<ContentsResponse>>("/repos/{owner}/{repo}/contents", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetContentsList", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets the metadata of all the entries of the root dir 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;ContentsResponse&gt;</returns>
        public async System.Threading.Tasks.Task<List<ContentsResponse>> RepoGetContentsListAsync(string owner, string repo, string? varRef = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<ContentsResponse>> localVarResponse = await RepoGetContentsListWithHttpInfoAsync(owner, repo, varRef, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets the metadata of all the entries of the root dir 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;ContentsResponse&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<ContentsResponse>>> RepoGetContentsListWithHttpInfoAsync(string owner, string repo, string? varRef = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetContentsList");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetContentsList");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (varRef != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "ref", varRef));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetContentsList";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<ContentsResponse>>("/repos/{owner}/{repo}/contents", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetContentsList", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get the EditorConfig definitions of a file in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">filepath of file to get</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RepoGetEditorConfig(string owner, string repo, string filepath, string? varRef = default(string?), int operationIndex = 0)
        {
            RepoGetEditorConfigWithHttpInfo(owner, repo, filepath, varRef);
        }

        /// <summary>
        /// Get the EditorConfig definitions of a file in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">filepath of file to get</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> RepoGetEditorConfigWithHttpInfo(string owner, string repo, string filepath, string? varRef = default(string?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetEditorConfig");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetEditorConfig");
            }

            // verify the required parameter 'filepath' is set
            if (filepath == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'filepath' when calling RepositoryApi->RepoGetEditorConfig");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("filepath", Org.OpenAPITools.Client.ClientUtils.ParameterToString(filepath)); // path parameter
            if (varRef != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "ref", varRef));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetEditorConfig";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Object>("/repos/{owner}/{repo}/editorconfig/{filepath}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetEditorConfig", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get the EditorConfig definitions of a file in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">filepath of file to get</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RepoGetEditorConfigAsync(string owner, string repo, string filepath, string? varRef = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RepoGetEditorConfigWithHttpInfoAsync(owner, repo, filepath, varRef, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get the EditorConfig definitions of a file in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">filepath of file to get</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> RepoGetEditorConfigWithHttpInfoAsync(string owner, string repo, string filepath, string? varRef = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetEditorConfig");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetEditorConfig");
            }

            // verify the required parameter 'filepath' is set
            if (filepath == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'filepath' when calling RepositoryApi->RepoGetEditorConfig");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("filepath", Org.OpenAPITools.Client.ClientUtils.ParameterToString(filepath)); // path parameter
            if (varRef != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "ref", varRef));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetEditorConfig";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Object>("/repos/{owner}/{repo}/editorconfig/{filepath}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetEditorConfig", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a Git hook 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>GitHook</returns>
        public GitHook RepoGetGitHook(string owner, string repo, string id, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<GitHook> localVarResponse = RepoGetGitHookWithHttpInfo(owner, repo, id);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a Git hook 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of GitHook</returns>
        public Org.OpenAPITools.Client.ApiResponse<GitHook> RepoGetGitHookWithHttpInfo(string owner, string repo, string id, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetGitHook");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetGitHook");
            }

            // verify the required parameter 'id' is set
            if (id == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'id' when calling RepositoryApi->RepoGetGitHook");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetGitHook";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<GitHook>("/repos/{owner}/{repo}/hooks/git/{id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetGitHook", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a Git hook 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GitHook</returns>
        public async System.Threading.Tasks.Task<GitHook> RepoGetGitHookAsync(string owner, string repo, string id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<GitHook> localVarResponse = await RepoGetGitHookWithHttpInfoAsync(owner, repo, id, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a Git hook 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GitHook)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<GitHook>> RepoGetGitHookWithHttpInfoAsync(string owner, string repo, string id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetGitHook");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetGitHook");
            }

            // verify the required parameter 'id' is set
            if (id == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'id' when calling RepositoryApi->RepoGetGitHook");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetGitHook";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<GitHook>("/repos/{owner}/{repo}/hooks/git/{id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetGitHook", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a hook 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Hook</returns>
        public Hook RepoGetHook(string owner, string repo, long id, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<Hook> localVarResponse = RepoGetHookWithHttpInfo(owner, repo, id);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a hook 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Hook</returns>
        public Org.OpenAPITools.Client.ApiResponse<Hook> RepoGetHookWithHttpInfo(string owner, string repo, long id, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetHook");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetHook");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetHook";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Hook>("/repos/{owner}/{repo}/hooks/{id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetHook", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a hook 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Hook</returns>
        public async System.Threading.Tasks.Task<Hook> RepoGetHookAsync(string owner, string repo, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<Hook> localVarResponse = await RepoGetHookWithHttpInfoAsync(owner, repo, id, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a hook 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Hook)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Hook>> RepoGetHookWithHttpInfoAsync(string owner, string repo, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetHook");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetHook");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetHook";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Hook>("/repos/{owner}/{repo}/hooks/{id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetHook", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Returns the issue config for a repo 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>IssueConfig</returns>
        public IssueConfig RepoGetIssueConfig(string owner, string repo, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<IssueConfig> localVarResponse = RepoGetIssueConfigWithHttpInfo(owner, repo);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Returns the issue config for a repo 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of IssueConfig</returns>
        public Org.OpenAPITools.Client.ApiResponse<IssueConfig> RepoGetIssueConfigWithHttpInfo(string owner, string repo, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetIssueConfig");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetIssueConfig");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetIssueConfig";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<IssueConfig>("/repos/{owner}/{repo}/issue_config", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetIssueConfig", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Returns the issue config for a repo 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of IssueConfig</returns>
        public async System.Threading.Tasks.Task<IssueConfig> RepoGetIssueConfigAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<IssueConfig> localVarResponse = await RepoGetIssueConfigWithHttpInfoAsync(owner, repo, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Returns the issue config for a repo 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (IssueConfig)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<IssueConfig>> RepoGetIssueConfigWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetIssueConfig");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetIssueConfig");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetIssueConfig";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<IssueConfig>("/repos/{owner}/{repo}/issue_config", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetIssueConfig", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get available issue templates for a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;IssueTemplate&gt;</returns>
        public List<IssueTemplate> RepoGetIssueTemplates(string owner, string repo, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<IssueTemplate>> localVarResponse = RepoGetIssueTemplatesWithHttpInfo(owner, repo);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get available issue templates for a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;IssueTemplate&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<IssueTemplate>> RepoGetIssueTemplatesWithHttpInfo(string owner, string repo, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetIssueTemplates");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetIssueTemplates");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetIssueTemplates";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<IssueTemplate>>("/repos/{owner}/{repo}/issue_templates", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetIssueTemplates", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get available issue templates for a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;IssueTemplate&gt;</returns>
        public async System.Threading.Tasks.Task<List<IssueTemplate>> RepoGetIssueTemplatesAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<IssueTemplate>> localVarResponse = await RepoGetIssueTemplatesWithHttpInfoAsync(owner, repo, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get available issue templates for a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;IssueTemplate&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<IssueTemplate>>> RepoGetIssueTemplatesWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetIssueTemplates");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetIssueTemplates");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetIssueTemplates";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<IssueTemplate>>("/repos/{owner}/{repo}/issue_templates", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetIssueTemplates", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a repository&#39;s key by id 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the key to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>DeployKey</returns>
        public DeployKey RepoGetKey(string owner, string repo, long id, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<DeployKey> localVarResponse = RepoGetKeyWithHttpInfo(owner, repo, id);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a repository&#39;s key by id 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the key to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of DeployKey</returns>
        public Org.OpenAPITools.Client.ApiResponse<DeployKey> RepoGetKeyWithHttpInfo(string owner, string repo, long id, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetKey");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetKey");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetKey";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<DeployKey>("/repos/{owner}/{repo}/keys/{id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetKey", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a repository&#39;s key by id 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the key to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of DeployKey</returns>
        public async System.Threading.Tasks.Task<DeployKey> RepoGetKeyAsync(string owner, string repo, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<DeployKey> localVarResponse = await RepoGetKeyWithHttpInfoAsync(owner, repo, id, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a repository&#39;s key by id 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the key to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (DeployKey)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<DeployKey>> RepoGetKeyWithHttpInfoAsync(string owner, string repo, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetKey");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetKey");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetKey";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<DeployKey>("/repos/{owner}/{repo}/keys/{id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetKey", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get languages and number of bytes of code written 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Dictionary&lt;string, long&gt;</returns>
        public Dictionary<string, long> RepoGetLanguages(string owner, string repo, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<Dictionary<string, long>> localVarResponse = RepoGetLanguagesWithHttpInfo(owner, repo);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get languages and number of bytes of code written 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Dictionary&lt;string, long&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<Dictionary<string, long>> RepoGetLanguagesWithHttpInfo(string owner, string repo, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetLanguages");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetLanguages");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetLanguages";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Dictionary<string, long>>("/repos/{owner}/{repo}/languages", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetLanguages", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get languages and number of bytes of code written 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Dictionary&lt;string, long&gt;</returns>
        public async System.Threading.Tasks.Task<Dictionary<string, long>> RepoGetLanguagesAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<Dictionary<string, long>> localVarResponse = await RepoGetLanguagesWithHttpInfoAsync(owner, repo, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get languages and number of bytes of code written 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Dictionary&lt;string, long&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Dictionary<string, long>>> RepoGetLanguagesWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetLanguages");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetLanguages");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetLanguages";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Dictionary<string, long>>("/repos/{owner}/{repo}/languages", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetLanguages", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets the most recent non-prerelease, non-draft release of a repository, sorted by created_at 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Release</returns>
        public Release RepoGetLatestRelease(string owner, string repo, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<Release> localVarResponse = RepoGetLatestReleaseWithHttpInfo(owner, repo);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets the most recent non-prerelease, non-draft release of a repository, sorted by created_at 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Release</returns>
        public Org.OpenAPITools.Client.ApiResponse<Release> RepoGetLatestReleaseWithHttpInfo(string owner, string repo, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetLatestRelease");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetLatestRelease");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetLatestRelease";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Release>("/repos/{owner}/{repo}/releases/latest", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetLatestRelease", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Gets the most recent non-prerelease, non-draft release of a repository, sorted by created_at 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Release</returns>
        public async System.Threading.Tasks.Task<Release> RepoGetLatestReleaseAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<Release> localVarResponse = await RepoGetLatestReleaseWithHttpInfoAsync(owner, repo, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Gets the most recent non-prerelease, non-draft release of a repository, sorted by created_at 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Release)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Release>> RepoGetLatestReleaseWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetLatestRelease");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetLatestRelease");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetLatestRelease";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Release>("/repos/{owner}/{repo}/releases/latest", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetLatestRelease", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a note corresponding to a single commit from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">a git ref or commit sha</param>
        /// <param name="verification">include verification for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="files">include a list of affected files for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Note</returns>
        public Note RepoGetNote(string owner, string repo, string sha, bool? verification = default(bool?), bool? files = default(bool?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<Note> localVarResponse = RepoGetNoteWithHttpInfo(owner, repo, sha, verification, files);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a note corresponding to a single commit from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">a git ref or commit sha</param>
        /// <param name="verification">include verification for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="files">include a list of affected files for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Note</returns>
        public Org.OpenAPITools.Client.ApiResponse<Note> RepoGetNoteWithHttpInfo(string owner, string repo, string sha, bool? verification = default(bool?), bool? files = default(bool?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetNote");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetNote");
            }

            // verify the required parameter 'sha' is set
            if (sha == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'sha' when calling RepositoryApi->RepoGetNote");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("sha", Org.OpenAPITools.Client.ClientUtils.ParameterToString(sha)); // path parameter
            if (verification != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "verification", verification));
            }
            if (files != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "files", files));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetNote";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Note>("/repos/{owner}/{repo}/git/notes/{sha}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetNote", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a note corresponding to a single commit from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">a git ref or commit sha</param>
        /// <param name="verification">include verification for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="files">include a list of affected files for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Note</returns>
        public async System.Threading.Tasks.Task<Note> RepoGetNoteAsync(string owner, string repo, string sha, bool? verification = default(bool?), bool? files = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<Note> localVarResponse = await RepoGetNoteWithHttpInfoAsync(owner, repo, sha, verification, files, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a note corresponding to a single commit from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">a git ref or commit sha</param>
        /// <param name="verification">include verification for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="files">include a list of affected files for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Note)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Note>> RepoGetNoteWithHttpInfoAsync(string owner, string repo, string sha, bool? verification = default(bool?), bool? files = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetNote");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetNote");
            }

            // verify the required parameter 'sha' is set
            if (sha == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'sha' when calling RepositoryApi->RepoGetNote");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("sha", Org.OpenAPITools.Client.ClientUtils.ParameterToString(sha)); // path parameter
            if (verification != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "verification", verification));
            }
            if (files != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "files", files));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetNote";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Note>("/repos/{owner}/{repo}/git/notes/{sha}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetNote", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PullRequest</returns>
        public PullRequest RepoGetPullRequest(string owner, string repo, long index, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<PullRequest> localVarResponse = RepoGetPullRequestWithHttpInfo(owner, repo, index);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PullRequest</returns>
        public Org.OpenAPITools.Client.ApiResponse<PullRequest> RepoGetPullRequestWithHttpInfo(string owner, string repo, long index, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetPullRequest");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetPullRequest");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetPullRequest";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PullRequest>("/repos/{owner}/{repo}/pulls/{index}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetPullRequest", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PullRequest</returns>
        public async System.Threading.Tasks.Task<PullRequest> RepoGetPullRequestAsync(string owner, string repo, long index, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<PullRequest> localVarResponse = await RepoGetPullRequestWithHttpInfoAsync(owner, repo, index, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PullRequest)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<PullRequest>> RepoGetPullRequestWithHttpInfoAsync(string owner, string repo, long index, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetPullRequest");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetPullRequest");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetPullRequest";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PullRequest>("/repos/{owner}/{repo}/pulls/{index}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetPullRequest", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a pull request by base and head 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varBase">base of the pull request to get</param>
        /// <param name="head">head of the pull request to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PullRequest</returns>
        public PullRequest RepoGetPullRequestByBaseHead(string owner, string repo, string varBase, string head, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<PullRequest> localVarResponse = RepoGetPullRequestByBaseHeadWithHttpInfo(owner, repo, varBase, head);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a pull request by base and head 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varBase">base of the pull request to get</param>
        /// <param name="head">head of the pull request to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PullRequest</returns>
        public Org.OpenAPITools.Client.ApiResponse<PullRequest> RepoGetPullRequestByBaseHeadWithHttpInfo(string owner, string repo, string varBase, string head, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetPullRequestByBaseHead");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetPullRequestByBaseHead");
            }

            // verify the required parameter 'varBase' is set
            if (varBase == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'varBase' when calling RepositoryApi->RepoGetPullRequestByBaseHead");
            }

            // verify the required parameter 'head' is set
            if (head == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'head' when calling RepositoryApi->RepoGetPullRequestByBaseHead");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("base", Org.OpenAPITools.Client.ClientUtils.ParameterToString(varBase)); // path parameter
            localVarRequestOptions.PathParameters.Add("head", Org.OpenAPITools.Client.ClientUtils.ParameterToString(head)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetPullRequestByBaseHead";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PullRequest>("/repos/{owner}/{repo}/pulls/{base}/{head}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetPullRequestByBaseHead", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a pull request by base and head 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varBase">base of the pull request to get</param>
        /// <param name="head">head of the pull request to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PullRequest</returns>
        public async System.Threading.Tasks.Task<PullRequest> RepoGetPullRequestByBaseHeadAsync(string owner, string repo, string varBase, string head, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<PullRequest> localVarResponse = await RepoGetPullRequestByBaseHeadWithHttpInfoAsync(owner, repo, varBase, head, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a pull request by base and head 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varBase">base of the pull request to get</param>
        /// <param name="head">head of the pull request to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PullRequest)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<PullRequest>> RepoGetPullRequestByBaseHeadWithHttpInfoAsync(string owner, string repo, string varBase, string head, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetPullRequestByBaseHead");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetPullRequestByBaseHead");
            }

            // verify the required parameter 'varBase' is set
            if (varBase == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'varBase' when calling RepositoryApi->RepoGetPullRequestByBaseHead");
            }

            // verify the required parameter 'head' is set
            if (head == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'head' when calling RepositoryApi->RepoGetPullRequestByBaseHead");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("base", Org.OpenAPITools.Client.ClientUtils.ParameterToString(varBase)); // path parameter
            localVarRequestOptions.PathParameters.Add("head", Org.OpenAPITools.Client.ClientUtils.ParameterToString(head)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetPullRequestByBaseHead";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PullRequest>("/repos/{owner}/{repo}/pulls/{base}/{head}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetPullRequestByBaseHead", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get commits for a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="verification">include verification for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="files">include a list of affected files for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;Commit&gt;</returns>
        public List<Commit> RepoGetPullRequestCommits(string owner, string repo, long index, int? page = default(int?), int? limit = default(int?), bool? verification = default(bool?), bool? files = default(bool?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<Commit>> localVarResponse = RepoGetPullRequestCommitsWithHttpInfo(owner, repo, index, page, limit, verification, files);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get commits for a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="verification">include verification for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="files">include a list of affected files for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;Commit&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<Commit>> RepoGetPullRequestCommitsWithHttpInfo(string owner, string repo, long index, int? page = default(int?), int? limit = default(int?), bool? verification = default(bool?), bool? files = default(bool?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetPullRequestCommits");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetPullRequestCommits");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (verification != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "verification", verification));
            }
            if (files != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "files", files));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetPullRequestCommits";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<Commit>>("/repos/{owner}/{repo}/pulls/{index}/commits", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetPullRequestCommits", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get commits for a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="verification">include verification for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="files">include a list of affected files for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Commit&gt;</returns>
        public async System.Threading.Tasks.Task<List<Commit>> RepoGetPullRequestCommitsAsync(string owner, string repo, long index, int? page = default(int?), int? limit = default(int?), bool? verification = default(bool?), bool? files = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<Commit>> localVarResponse = await RepoGetPullRequestCommitsWithHttpInfoAsync(owner, repo, index, page, limit, verification, files, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get commits for a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="verification">include verification for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="files">include a list of affected files for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Commit&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<Commit>>> RepoGetPullRequestCommitsWithHttpInfoAsync(string owner, string repo, long index, int? page = default(int?), int? limit = default(int?), bool? verification = default(bool?), bool? files = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetPullRequestCommits");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetPullRequestCommits");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (verification != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "verification", verification));
            }
            if (files != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "files", files));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetPullRequestCommits";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<Commit>>("/repos/{owner}/{repo}/pulls/{index}/commits", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetPullRequestCommits", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get changed files for a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="skipTo">skip to given file (optional)</param>
        /// <param name="whitespace">whitespace behavior (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;ChangedFile&gt;</returns>
        public List<ChangedFile> RepoGetPullRequestFiles(string owner, string repo, long index, string? skipTo = default(string?), string? whitespace = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<ChangedFile>> localVarResponse = RepoGetPullRequestFilesWithHttpInfo(owner, repo, index, skipTo, whitespace, page, limit);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get changed files for a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="skipTo">skip to given file (optional)</param>
        /// <param name="whitespace">whitespace behavior (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;ChangedFile&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<ChangedFile>> RepoGetPullRequestFilesWithHttpInfo(string owner, string repo, long index, string? skipTo = default(string?), string? whitespace = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetPullRequestFiles");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetPullRequestFiles");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter
            if (skipTo != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "skip-to", skipTo));
            }
            if (whitespace != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "whitespace", whitespace));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetPullRequestFiles";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<ChangedFile>>("/repos/{owner}/{repo}/pulls/{index}/files", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetPullRequestFiles", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get changed files for a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="skipTo">skip to given file (optional)</param>
        /// <param name="whitespace">whitespace behavior (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;ChangedFile&gt;</returns>
        public async System.Threading.Tasks.Task<List<ChangedFile>> RepoGetPullRequestFilesAsync(string owner, string repo, long index, string? skipTo = default(string?), string? whitespace = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<ChangedFile>> localVarResponse = await RepoGetPullRequestFilesWithHttpInfoAsync(owner, repo, index, skipTo, whitespace, page, limit, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get changed files for a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="skipTo">skip to given file (optional)</param>
        /// <param name="whitespace">whitespace behavior (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;ChangedFile&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<ChangedFile>>> RepoGetPullRequestFilesWithHttpInfoAsync(string owner, string repo, long index, string? skipTo = default(string?), string? whitespace = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetPullRequestFiles");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetPullRequestFiles");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter
            if (skipTo != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "skip-to", skipTo));
            }
            if (whitespace != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "whitespace", whitespace));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetPullRequestFiles";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<ChangedFile>>("/repos/{owner}/{repo}/pulls/{index}/files", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetPullRequestFiles", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a specific review for a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PullReview</returns>
        public PullReview RepoGetPullReview(string owner, string repo, long index, long id, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<PullReview> localVarResponse = RepoGetPullReviewWithHttpInfo(owner, repo, index, id);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a specific review for a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PullReview</returns>
        public Org.OpenAPITools.Client.ApiResponse<PullReview> RepoGetPullReviewWithHttpInfo(string owner, string repo, long index, long id, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetPullReview");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetPullReview");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetPullReview";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PullReview>("/repos/{owner}/{repo}/pulls/{index}/reviews/{id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetPullReview", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a specific review for a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PullReview</returns>
        public async System.Threading.Tasks.Task<PullReview> RepoGetPullReviewAsync(string owner, string repo, long index, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<PullReview> localVarResponse = await RepoGetPullReviewWithHttpInfoAsync(owner, repo, index, id, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a specific review for a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PullReview)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<PullReview>> RepoGetPullReviewWithHttpInfoAsync(string owner, string repo, long index, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetPullReview");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetPullReview");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetPullReview";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PullReview>("/repos/{owner}/{repo}/pulls/{index}/reviews/{id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetPullReview", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a specific review for a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;PullReviewComment&gt;</returns>
        public List<PullReviewComment> RepoGetPullReviewComments(string owner, string repo, long index, long id, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<PullReviewComment>> localVarResponse = RepoGetPullReviewCommentsWithHttpInfo(owner, repo, index, id);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a specific review for a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;PullReviewComment&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<PullReviewComment>> RepoGetPullReviewCommentsWithHttpInfo(string owner, string repo, long index, long id, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetPullReviewComments");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetPullReviewComments");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetPullReviewComments";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<PullReviewComment>>("/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/comments", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetPullReviewComments", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a specific review for a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;PullReviewComment&gt;</returns>
        public async System.Threading.Tasks.Task<List<PullReviewComment>> RepoGetPullReviewCommentsAsync(string owner, string repo, long index, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<PullReviewComment>> localVarResponse = await RepoGetPullReviewCommentsWithHttpInfoAsync(owner, repo, index, id, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a specific review for a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;PullReviewComment&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<PullReviewComment>>> RepoGetPullReviewCommentsWithHttpInfoAsync(string owner, string repo, long index, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetPullReviewComments");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetPullReviewComments");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetPullReviewComments";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<PullReviewComment>>("/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/comments", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetPullReviewComments", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get push mirror of the repository by remoteName 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">remote name of push mirror</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PushMirror</returns>
        public PushMirror RepoGetPushMirrorByRemoteName(string owner, string repo, string name, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<PushMirror> localVarResponse = RepoGetPushMirrorByRemoteNameWithHttpInfo(owner, repo, name);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get push mirror of the repository by remoteName 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">remote name of push mirror</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PushMirror</returns>
        public Org.OpenAPITools.Client.ApiResponse<PushMirror> RepoGetPushMirrorByRemoteNameWithHttpInfo(string owner, string repo, string name, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetPushMirrorByRemoteName");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetPushMirrorByRemoteName");
            }

            // verify the required parameter 'name' is set
            if (name == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'name' when calling RepositoryApi->RepoGetPushMirrorByRemoteName");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("name", Org.OpenAPITools.Client.ClientUtils.ParameterToString(name)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetPushMirrorByRemoteName";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PushMirror>("/repos/{owner}/{repo}/push_mirrors/{name}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetPushMirrorByRemoteName", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get push mirror of the repository by remoteName 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">remote name of push mirror</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PushMirror</returns>
        public async System.Threading.Tasks.Task<PushMirror> RepoGetPushMirrorByRemoteNameAsync(string owner, string repo, string name, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<PushMirror> localVarResponse = await RepoGetPushMirrorByRemoteNameWithHttpInfoAsync(owner, repo, name, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get push mirror of the repository by remoteName 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="name">remote name of push mirror</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PushMirror)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<PushMirror>> RepoGetPushMirrorByRemoteNameWithHttpInfoAsync(string owner, string repo, string name, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetPushMirrorByRemoteName");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetPushMirrorByRemoteName");
            }

            // verify the required parameter 'name' is set
            if (name == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'name' when calling RepositoryApi->RepoGetPushMirrorByRemoteName");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("name", Org.OpenAPITools.Client.ClientUtils.ParameterToString(name)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetPushMirrorByRemoteName";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PushMirror>("/repos/{owner}/{repo}/push_mirrors/{name}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetPushMirrorByRemoteName", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a file from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">filepath of the file to get</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RepoGetRawFile(string owner, string repo, string filepath, string? varRef = default(string?), int operationIndex = 0)
        {
            RepoGetRawFileWithHttpInfo(owner, repo, filepath, varRef);
        }

        /// <summary>
        /// Get a file from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">filepath of the file to get</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> RepoGetRawFileWithHttpInfo(string owner, string repo, string filepath, string? varRef = default(string?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetRawFile");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetRawFile");
            }

            // verify the required parameter 'filepath' is set
            if (filepath == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'filepath' when calling RepositoryApi->RepoGetRawFile");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("filepath", Org.OpenAPITools.Client.ClientUtils.ParameterToString(filepath)); // path parameter
            if (varRef != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "ref", varRef));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetRawFile";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Object>("/repos/{owner}/{repo}/raw/{filepath}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetRawFile", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a file from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">filepath of the file to get</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RepoGetRawFileAsync(string owner, string repo, string filepath, string? varRef = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RepoGetRawFileWithHttpInfoAsync(owner, repo, filepath, varRef, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get a file from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">filepath of the file to get</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> RepoGetRawFileWithHttpInfoAsync(string owner, string repo, string filepath, string? varRef = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetRawFile");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetRawFile");
            }

            // verify the required parameter 'filepath' is set
            if (filepath == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'filepath' when calling RepositoryApi->RepoGetRawFile");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("filepath", Org.OpenAPITools.Client.ClientUtils.ParameterToString(filepath)); // path parameter
            if (varRef != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "ref", varRef));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetRawFile";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Object>("/repos/{owner}/{repo}/raw/{filepath}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetRawFile", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a file or it&#39;s LFS object from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">filepath of the file to get</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RepoGetRawFileOrLFS(string owner, string repo, string filepath, string? varRef = default(string?), int operationIndex = 0)
        {
            RepoGetRawFileOrLFSWithHttpInfo(owner, repo, filepath, varRef);
        }

        /// <summary>
        /// Get a file or it&#39;s LFS object from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">filepath of the file to get</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> RepoGetRawFileOrLFSWithHttpInfo(string owner, string repo, string filepath, string? varRef = default(string?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetRawFileOrLFS");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetRawFileOrLFS");
            }

            // verify the required parameter 'filepath' is set
            if (filepath == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'filepath' when calling RepositoryApi->RepoGetRawFileOrLFS");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("filepath", Org.OpenAPITools.Client.ClientUtils.ParameterToString(filepath)); // path parameter
            if (varRef != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "ref", varRef));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetRawFileOrLFS";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Object>("/repos/{owner}/{repo}/media/{filepath}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetRawFileOrLFS", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a file or it&#39;s LFS object from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">filepath of the file to get</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RepoGetRawFileOrLFSAsync(string owner, string repo, string filepath, string? varRef = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RepoGetRawFileOrLFSWithHttpInfoAsync(owner, repo, filepath, varRef, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get a file or it&#39;s LFS object from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">filepath of the file to get</param>
        /// <param name="varRef">The name of the commit/branch/tag. Default the repositorys default branch (usually master) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> RepoGetRawFileOrLFSWithHttpInfoAsync(string owner, string repo, string filepath, string? varRef = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetRawFileOrLFS");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetRawFileOrLFS");
            }

            // verify the required parameter 'filepath' is set
            if (filepath == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'filepath' when calling RepositoryApi->RepoGetRawFileOrLFS");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("filepath", Org.OpenAPITools.Client.ClientUtils.ParameterToString(filepath)); // path parameter
            if (varRef != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "ref", varRef));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetRawFileOrLFS";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Object>("/repos/{owner}/{repo}/media/{filepath}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetRawFileOrLFS", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a release 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Release</returns>
        public Release RepoGetRelease(string owner, string repo, long id, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<Release> localVarResponse = RepoGetReleaseWithHttpInfo(owner, repo, id);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a release 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Release</returns>
        public Org.OpenAPITools.Client.ApiResponse<Release> RepoGetReleaseWithHttpInfo(string owner, string repo, long id, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetRelease");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetRelease");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetRelease";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Release>("/repos/{owner}/{repo}/releases/{id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetRelease", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a release 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Release</returns>
        public async System.Threading.Tasks.Task<Release> RepoGetReleaseAsync(string owner, string repo, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<Release> localVarResponse = await RepoGetReleaseWithHttpInfoAsync(owner, repo, id, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a release 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Release)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Release>> RepoGetReleaseWithHttpInfoAsync(string owner, string repo, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetRelease");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetRelease");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetRelease";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Release>("/repos/{owner}/{repo}/releases/{id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetRelease", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a release attachment 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="attachmentId">id of the attachment to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Attachment</returns>
        public Attachment RepoGetReleaseAttachment(string owner, string repo, long id, long attachmentId, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<Attachment> localVarResponse = RepoGetReleaseAttachmentWithHttpInfo(owner, repo, id, attachmentId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a release attachment 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="attachmentId">id of the attachment to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Attachment</returns>
        public Org.OpenAPITools.Client.ApiResponse<Attachment> RepoGetReleaseAttachmentWithHttpInfo(string owner, string repo, long id, long attachmentId, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetReleaseAttachment");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetReleaseAttachment");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.PathParameters.Add("attachment_id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(attachmentId)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetReleaseAttachment";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Attachment>("/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetReleaseAttachment", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a release attachment 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="attachmentId">id of the attachment to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Attachment</returns>
        public async System.Threading.Tasks.Task<Attachment> RepoGetReleaseAttachmentAsync(string owner, string repo, long id, long attachmentId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<Attachment> localVarResponse = await RepoGetReleaseAttachmentWithHttpInfoAsync(owner, repo, id, attachmentId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a release attachment 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="attachmentId">id of the attachment to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Attachment)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Attachment>> RepoGetReleaseAttachmentWithHttpInfoAsync(string owner, string repo, long id, long attachmentId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetReleaseAttachment");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetReleaseAttachment");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.PathParameters.Add("attachment_id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(attachmentId)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetReleaseAttachment";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Attachment>("/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetReleaseAttachment", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a release by tag name 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="tag">tag name of the release to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Release</returns>
        public Release RepoGetReleaseByTag(string owner, string repo, string tag, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<Release> localVarResponse = RepoGetReleaseByTagWithHttpInfo(owner, repo, tag);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a release by tag name 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="tag">tag name of the release to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Release</returns>
        public Org.OpenAPITools.Client.ApiResponse<Release> RepoGetReleaseByTagWithHttpInfo(string owner, string repo, string tag, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetReleaseByTag");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetReleaseByTag");
            }

            // verify the required parameter 'tag' is set
            if (tag == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'tag' when calling RepositoryApi->RepoGetReleaseByTag");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("tag", Org.OpenAPITools.Client.ClientUtils.ParameterToString(tag)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetReleaseByTag";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Release>("/repos/{owner}/{repo}/releases/tags/{tag}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetReleaseByTag", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a release by tag name 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="tag">tag name of the release to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Release</returns>
        public async System.Threading.Tasks.Task<Release> RepoGetReleaseByTagAsync(string owner, string repo, string tag, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<Release> localVarResponse = await RepoGetReleaseByTagWithHttpInfoAsync(owner, repo, tag, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a release by tag name 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="tag">tag name of the release to get</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Release)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Release>> RepoGetReleaseByTagWithHttpInfoAsync(string owner, string repo, string tag, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetReleaseByTag");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetReleaseByTag");
            }

            // verify the required parameter 'tag' is set
            if (tag == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'tag' when calling RepositoryApi->RepoGetReleaseByTag");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("tag", Org.OpenAPITools.Client.ClientUtils.ParameterToString(tag)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetReleaseByTag";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Release>("/repos/{owner}/{repo}/releases/tags/{tag}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetReleaseByTag", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get repository permissions for a user 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="collaborator">username of the collaborator</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>RepoCollaboratorPermission</returns>
        public RepoCollaboratorPermission RepoGetRepoPermissions(string owner, string repo, string collaborator, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<RepoCollaboratorPermission> localVarResponse = RepoGetRepoPermissionsWithHttpInfo(owner, repo, collaborator);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get repository permissions for a user 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="collaborator">username of the collaborator</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of RepoCollaboratorPermission</returns>
        public Org.OpenAPITools.Client.ApiResponse<RepoCollaboratorPermission> RepoGetRepoPermissionsWithHttpInfo(string owner, string repo, string collaborator, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetRepoPermissions");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetRepoPermissions");
            }

            // verify the required parameter 'collaborator' is set
            if (collaborator == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'collaborator' when calling RepositoryApi->RepoGetRepoPermissions");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("collaborator", Org.OpenAPITools.Client.ClientUtils.ParameterToString(collaborator)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetRepoPermissions";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<RepoCollaboratorPermission>("/repos/{owner}/{repo}/collaborators/{collaborator}/permission", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetRepoPermissions", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get repository permissions for a user 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="collaborator">username of the collaborator</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of RepoCollaboratorPermission</returns>
        public async System.Threading.Tasks.Task<RepoCollaboratorPermission> RepoGetRepoPermissionsAsync(string owner, string repo, string collaborator, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<RepoCollaboratorPermission> localVarResponse = await RepoGetRepoPermissionsWithHttpInfoAsync(owner, repo, collaborator, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get repository permissions for a user 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="collaborator">username of the collaborator</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (RepoCollaboratorPermission)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<RepoCollaboratorPermission>> RepoGetRepoPermissionsWithHttpInfoAsync(string owner, string repo, string collaborator, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetRepoPermissions");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetRepoPermissions");
            }

            // verify the required parameter 'collaborator' is set
            if (collaborator == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'collaborator' when calling RepositoryApi->RepoGetRepoPermissions");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("collaborator", Org.OpenAPITools.Client.ClientUtils.ParameterToString(collaborator)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetRepoPermissions";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<RepoCollaboratorPermission>("/repos/{owner}/{repo}/collaborators/{collaborator}/permission", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetRepoPermissions", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Return all users that can be requested to review in this repo 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;User&gt;</returns>
        public List<User> RepoGetReviewers(string owner, string repo, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<User>> localVarResponse = RepoGetReviewersWithHttpInfo(owner, repo);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Return all users that can be requested to review in this repo 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;User&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<User>> RepoGetReviewersWithHttpInfo(string owner, string repo, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetReviewers");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetReviewers");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetReviewers";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<User>>("/repos/{owner}/{repo}/reviewers", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetReviewers", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Return all users that can be requested to review in this repo 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;User&gt;</returns>
        public async System.Threading.Tasks.Task<List<User>> RepoGetReviewersAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<User>> localVarResponse = await RepoGetReviewersWithHttpInfoAsync(owner, repo, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Return all users that can be requested to review in this repo 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;User&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<User>>> RepoGetReviewersWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetReviewers");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetReviewers");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetReviewers";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<User>>("/repos/{owner}/{repo}/reviewers", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetReviewers", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a repository&#39;s actions runner registration token 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RepoGetRunnerRegistrationToken(string owner, string repo, int operationIndex = 0)
        {
            RepoGetRunnerRegistrationTokenWithHttpInfo(owner, repo);
        }

        /// <summary>
        /// Get a repository&#39;s actions runner registration token 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> RepoGetRunnerRegistrationTokenWithHttpInfo(string owner, string repo, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetRunnerRegistrationToken");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetRunnerRegistrationToken");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetRunnerRegistrationToken";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Object>("/repos/{owner}/{repo}/runners/registration-token", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetRunnerRegistrationToken", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a repository&#39;s actions runner registration token 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RepoGetRunnerRegistrationTokenAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RepoGetRunnerRegistrationTokenWithHttpInfoAsync(owner, repo, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get a repository&#39;s actions runner registration token 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> RepoGetRunnerRegistrationTokenWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetRunnerRegistrationToken");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetRunnerRegistrationToken");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetRunnerRegistrationToken";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Object>("/repos/{owner}/{repo}/runners/registration-token", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetRunnerRegistrationToken", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a single commit from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">a git ref or commit sha</param>
        /// <param name="stat">include diff stats for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="verification">include verification for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="files">include a list of affected files for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Commit</returns>
        public Commit RepoGetSingleCommit(string owner, string repo, string sha, bool? stat = default(bool?), bool? verification = default(bool?), bool? files = default(bool?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<Commit> localVarResponse = RepoGetSingleCommitWithHttpInfo(owner, repo, sha, stat, verification, files);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a single commit from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">a git ref or commit sha</param>
        /// <param name="stat">include diff stats for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="verification">include verification for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="files">include a list of affected files for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Commit</returns>
        public Org.OpenAPITools.Client.ApiResponse<Commit> RepoGetSingleCommitWithHttpInfo(string owner, string repo, string sha, bool? stat = default(bool?), bool? verification = default(bool?), bool? files = default(bool?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetSingleCommit");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetSingleCommit");
            }

            // verify the required parameter 'sha' is set
            if (sha == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'sha' when calling RepositoryApi->RepoGetSingleCommit");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("sha", Org.OpenAPITools.Client.ClientUtils.ParameterToString(sha)); // path parameter
            if (stat != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "stat", stat));
            }
            if (verification != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "verification", verification));
            }
            if (files != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "files", files));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetSingleCommit";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Commit>("/repos/{owner}/{repo}/git/commits/{sha}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetSingleCommit", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a single commit from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">a git ref or commit sha</param>
        /// <param name="stat">include diff stats for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="verification">include verification for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="files">include a list of affected files for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Commit</returns>
        public async System.Threading.Tasks.Task<Commit> RepoGetSingleCommitAsync(string owner, string repo, string sha, bool? stat = default(bool?), bool? verification = default(bool?), bool? files = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<Commit> localVarResponse = await RepoGetSingleCommitWithHttpInfoAsync(owner, repo, sha, stat, verification, files, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a single commit from a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">a git ref or commit sha</param>
        /// <param name="stat">include diff stats for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="verification">include verification for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="files">include a list of affected files for every commit (disable for speedup, default &#39;true&#39;) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Commit)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Commit>> RepoGetSingleCommitWithHttpInfoAsync(string owner, string repo, string sha, bool? stat = default(bool?), bool? verification = default(bool?), bool? files = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetSingleCommit");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetSingleCommit");
            }

            // verify the required parameter 'sha' is set
            if (sha == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'sha' when calling RepositoryApi->RepoGetSingleCommit");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("sha", Org.OpenAPITools.Client.ClientUtils.ParameterToString(sha)); // path parameter
            if (stat != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "stat", stat));
            }
            if (verification != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "verification", verification));
            }
            if (files != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "files", files));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetSingleCommit";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Commit>("/repos/{owner}/{repo}/git/commits/{sha}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetSingleCommit", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get the tag of a repository by tag name 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="tag">name of tag</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Tag</returns>
        public Tag RepoGetTag(string owner, string repo, string tag, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<Tag> localVarResponse = RepoGetTagWithHttpInfo(owner, repo, tag);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get the tag of a repository by tag name 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="tag">name of tag</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Tag</returns>
        public Org.OpenAPITools.Client.ApiResponse<Tag> RepoGetTagWithHttpInfo(string owner, string repo, string tag, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetTag");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetTag");
            }

            // verify the required parameter 'tag' is set
            if (tag == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'tag' when calling RepositoryApi->RepoGetTag");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("tag", Org.OpenAPITools.Client.ClientUtils.ParameterToString(tag)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetTag";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Tag>("/repos/{owner}/{repo}/tags/{tag}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetTag", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get the tag of a repository by tag name 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="tag">name of tag</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Tag</returns>
        public async System.Threading.Tasks.Task<Tag> RepoGetTagAsync(string owner, string repo, string tag, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<Tag> localVarResponse = await RepoGetTagWithHttpInfoAsync(owner, repo, tag, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get the tag of a repository by tag name 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="tag">name of tag</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Tag)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Tag>> RepoGetTagWithHttpInfoAsync(string owner, string repo, string tag, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetTag");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetTag");
            }

            // verify the required parameter 'tag' is set
            if (tag == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'tag' when calling RepositoryApi->RepoGetTag");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("tag", Org.OpenAPITools.Client.ClientUtils.ParameterToString(tag)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetTag";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Tag>("/repos/{owner}/{repo}/tags/{tag}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetTag", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a wiki page 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="pageName">name of the page</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>WikiPage</returns>
        public WikiPage RepoGetWikiPage(string owner, string repo, string pageName, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<WikiPage> localVarResponse = RepoGetWikiPageWithHttpInfo(owner, repo, pageName);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a wiki page 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="pageName">name of the page</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of WikiPage</returns>
        public Org.OpenAPITools.Client.ApiResponse<WikiPage> RepoGetWikiPageWithHttpInfo(string owner, string repo, string pageName, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetWikiPage");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetWikiPage");
            }

            // verify the required parameter 'pageName' is set
            if (pageName == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'pageName' when calling RepositoryApi->RepoGetWikiPage");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("pageName", Org.OpenAPITools.Client.ClientUtils.ParameterToString(pageName)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetWikiPage";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<WikiPage>("/repos/{owner}/{repo}/wiki/page/{pageName}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetWikiPage", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a wiki page 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="pageName">name of the page</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of WikiPage</returns>
        public async System.Threading.Tasks.Task<WikiPage> RepoGetWikiPageAsync(string owner, string repo, string pageName, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<WikiPage> localVarResponse = await RepoGetWikiPageWithHttpInfoAsync(owner, repo, pageName, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a wiki page 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="pageName">name of the page</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (WikiPage)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<WikiPage>> RepoGetWikiPageWithHttpInfoAsync(string owner, string repo, string pageName, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetWikiPage");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetWikiPage");
            }

            // verify the required parameter 'pageName' is set
            if (pageName == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'pageName' when calling RepositoryApi->RepoGetWikiPage");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("pageName", Org.OpenAPITools.Client.ClientUtils.ParameterToString(pageName)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetWikiPage";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<WikiPage>("/repos/{owner}/{repo}/wiki/page/{pageName}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetWikiPage", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get revisions of a wiki page 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="pageName">name of the page</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>WikiCommitList</returns>
        public WikiCommitList RepoGetWikiPageRevisions(string owner, string repo, string pageName, int? page = default(int?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<WikiCommitList> localVarResponse = RepoGetWikiPageRevisionsWithHttpInfo(owner, repo, pageName, page);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get revisions of a wiki page 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="pageName">name of the page</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of WikiCommitList</returns>
        public Org.OpenAPITools.Client.ApiResponse<WikiCommitList> RepoGetWikiPageRevisionsWithHttpInfo(string owner, string repo, string pageName, int? page = default(int?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetWikiPageRevisions");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetWikiPageRevisions");
            }

            // verify the required parameter 'pageName' is set
            if (pageName == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'pageName' when calling RepositoryApi->RepoGetWikiPageRevisions");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("pageName", Org.OpenAPITools.Client.ClientUtils.ParameterToString(pageName)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetWikiPageRevisions";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<WikiCommitList>("/repos/{owner}/{repo}/wiki/revisions/{pageName}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetWikiPageRevisions", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get revisions of a wiki page 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="pageName">name of the page</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of WikiCommitList</returns>
        public async System.Threading.Tasks.Task<WikiCommitList> RepoGetWikiPageRevisionsAsync(string owner, string repo, string pageName, int? page = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<WikiCommitList> localVarResponse = await RepoGetWikiPageRevisionsWithHttpInfoAsync(owner, repo, pageName, page, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get revisions of a wiki page 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="pageName">name of the page</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (WikiCommitList)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<WikiCommitList>> RepoGetWikiPageRevisionsWithHttpInfoAsync(string owner, string repo, string pageName, int? page = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetWikiPageRevisions");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetWikiPageRevisions");
            }

            // verify the required parameter 'pageName' is set
            if (pageName == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'pageName' when calling RepositoryApi->RepoGetWikiPageRevisions");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("pageName", Org.OpenAPITools.Client.ClientUtils.ParameterToString(pageName)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetWikiPageRevisions";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<WikiCommitList>("/repos/{owner}/{repo}/wiki/revisions/{pageName}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetWikiPageRevisions", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get all wiki pages 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;WikiPageMetaData&gt;</returns>
        public List<WikiPageMetaData> RepoGetWikiPages(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<WikiPageMetaData>> localVarResponse = RepoGetWikiPagesWithHttpInfo(owner, repo, page, limit);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get all wiki pages 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;WikiPageMetaData&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<WikiPageMetaData>> RepoGetWikiPagesWithHttpInfo(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetWikiPages");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetWikiPages");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetWikiPages";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<WikiPageMetaData>>("/repos/{owner}/{repo}/wiki/pages", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetWikiPages", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get all wiki pages 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;WikiPageMetaData&gt;</returns>
        public async System.Threading.Tasks.Task<List<WikiPageMetaData>> RepoGetWikiPagesAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<WikiPageMetaData>> localVarResponse = await RepoGetWikiPagesWithHttpInfoAsync(owner, repo, page, limit, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get all wiki pages 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;WikiPageMetaData&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<WikiPageMetaData>>> RepoGetWikiPagesWithHttpInfoAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoGetWikiPages");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoGetWikiPages");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoGetWikiPages";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<WikiPageMetaData>>("/repos/{owner}/{repo}/wiki/pages", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoGetWikiPages", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List an repo&#39;s actions secrets 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repository</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;Secret&gt;</returns>
        public List<Secret> RepoListActionsSecrets(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<Secret>> localVarResponse = RepoListActionsSecretsWithHttpInfo(owner, repo, page, limit);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List an repo&#39;s actions secrets 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repository</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;Secret&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<Secret>> RepoListActionsSecretsWithHttpInfo(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListActionsSecrets");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListActionsSecrets");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoListActionsSecrets";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<Secret>>("/repos/{owner}/{repo}/actions/secrets", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListActionsSecrets", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List an repo&#39;s actions secrets 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repository</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Secret&gt;</returns>
        public async System.Threading.Tasks.Task<List<Secret>> RepoListActionsSecretsAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<Secret>> localVarResponse = await RepoListActionsSecretsWithHttpInfoAsync(owner, repo, page, limit, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List an repo&#39;s actions secrets 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repository</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Secret&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<Secret>>> RepoListActionsSecretsWithHttpInfoAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListActionsSecrets");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListActionsSecrets");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoListActionsSecrets";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<Secret>>("/repos/{owner}/{repo}/actions/secrets", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListActionsSecrets", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List a repository&#39;s activity feeds 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="date">the date of the activities to be found (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;Activity&gt;</returns>
        public List<Activity> RepoListActivityFeeds(string owner, string repo, DateOnly? date = default(DateOnly?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<Activity>> localVarResponse = RepoListActivityFeedsWithHttpInfo(owner, repo, date, page, limit);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List a repository&#39;s activity feeds 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="date">the date of the activities to be found (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;Activity&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<Activity>> RepoListActivityFeedsWithHttpInfo(string owner, string repo, DateOnly? date = default(DateOnly?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListActivityFeeds");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListActivityFeeds");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (date != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "date", date));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoListActivityFeeds";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<Activity>>("/repos/{owner}/{repo}/activities/feeds", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListActivityFeeds", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List a repository&#39;s activity feeds 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="date">the date of the activities to be found (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Activity&gt;</returns>
        public async System.Threading.Tasks.Task<List<Activity>> RepoListActivityFeedsAsync(string owner, string repo, DateOnly? date = default(DateOnly?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<Activity>> localVarResponse = await RepoListActivityFeedsWithHttpInfoAsync(owner, repo, date, page, limit, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List a repository&#39;s activity feeds 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="date">the date of the activities to be found (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Activity&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<Activity>>> RepoListActivityFeedsWithHttpInfoAsync(string owner, string repo, DateOnly? date = default(DateOnly?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListActivityFeeds");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListActivityFeeds");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (date != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "date", date));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoListActivityFeeds";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<Activity>>("/repos/{owner}/{repo}/activities/feeds", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListActivityFeeds", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get specified ref or filtered repository&#39;s refs 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;Reference&gt;</returns>
        public List<Reference> RepoListAllGitRefs(string owner, string repo, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<Reference>> localVarResponse = RepoListAllGitRefsWithHttpInfo(owner, repo);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get specified ref or filtered repository&#39;s refs 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;Reference&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<Reference>> RepoListAllGitRefsWithHttpInfo(string owner, string repo, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListAllGitRefs");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListAllGitRefs");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoListAllGitRefs";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<Reference>>("/repos/{owner}/{repo}/git/refs", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListAllGitRefs", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get specified ref or filtered repository&#39;s refs 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Reference&gt;</returns>
        public async System.Threading.Tasks.Task<List<Reference>> RepoListAllGitRefsAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<Reference>> localVarResponse = await RepoListAllGitRefsWithHttpInfoAsync(owner, repo, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get specified ref or filtered repository&#39;s refs 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Reference&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<Reference>>> RepoListAllGitRefsWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListAllGitRefs");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListAllGitRefs");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoListAllGitRefs";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<Reference>>("/repos/{owner}/{repo}/git/refs", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListAllGitRefs", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List branch protections for a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;BranchProtection&gt;</returns>
        public List<BranchProtection> RepoListBranchProtection(string owner, string repo, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<BranchProtection>> localVarResponse = RepoListBranchProtectionWithHttpInfo(owner, repo);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List branch protections for a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;BranchProtection&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<BranchProtection>> RepoListBranchProtectionWithHttpInfo(string owner, string repo, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListBranchProtection");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListBranchProtection");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoListBranchProtection";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<BranchProtection>>("/repos/{owner}/{repo}/branch_protections", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListBranchProtection", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List branch protections for a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;BranchProtection&gt;</returns>
        public async System.Threading.Tasks.Task<List<BranchProtection>> RepoListBranchProtectionAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<BranchProtection>> localVarResponse = await RepoListBranchProtectionWithHttpInfoAsync(owner, repo, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List branch protections for a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;BranchProtection&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<BranchProtection>>> RepoListBranchProtectionWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListBranchProtection");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListBranchProtection");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoListBranchProtection";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<BranchProtection>>("/repos/{owner}/{repo}/branch_protections", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListBranchProtection", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List a repository&#39;s branches 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;Branch&gt;</returns>
        public List<Branch> RepoListBranches(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<Branch>> localVarResponse = RepoListBranchesWithHttpInfo(owner, repo, page, limit);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List a repository&#39;s branches 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;Branch&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<Branch>> RepoListBranchesWithHttpInfo(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListBranches");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListBranches");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoListBranches";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<Branch>>("/repos/{owner}/{repo}/branches", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListBranches", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List a repository&#39;s branches 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Branch&gt;</returns>
        public async System.Threading.Tasks.Task<List<Branch>> RepoListBranchesAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<Branch>> localVarResponse = await RepoListBranchesWithHttpInfoAsync(owner, repo, page, limit, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List a repository&#39;s branches 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Branch&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<Branch>>> RepoListBranchesWithHttpInfoAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListBranches");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListBranches");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoListBranches";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<Branch>>("/repos/{owner}/{repo}/branches", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListBranches", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List a repository&#39;s collaborators 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;User&gt;</returns>
        public List<User> RepoListCollaborators(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<User>> localVarResponse = RepoListCollaboratorsWithHttpInfo(owner, repo, page, limit);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List a repository&#39;s collaborators 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;User&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<User>> RepoListCollaboratorsWithHttpInfo(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListCollaborators");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListCollaborators");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoListCollaborators";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<User>>("/repos/{owner}/{repo}/collaborators", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListCollaborators", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List a repository&#39;s collaborators 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;User&gt;</returns>
        public async System.Threading.Tasks.Task<List<User>> RepoListCollaboratorsAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<User>> localVarResponse = await RepoListCollaboratorsWithHttpInfoAsync(owner, repo, page, limit, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List a repository&#39;s collaborators 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;User&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<User>>> RepoListCollaboratorsWithHttpInfoAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListCollaborators");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListCollaborators");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoListCollaborators";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<User>>("/repos/{owner}/{repo}/collaborators", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListCollaborators", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List the Git hooks in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;GitHook&gt;</returns>
        public List<GitHook> RepoListGitHooks(string owner, string repo, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<GitHook>> localVarResponse = RepoListGitHooksWithHttpInfo(owner, repo);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List the Git hooks in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;GitHook&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<GitHook>> RepoListGitHooksWithHttpInfo(string owner, string repo, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListGitHooks");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListGitHooks");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoListGitHooks";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<GitHook>>("/repos/{owner}/{repo}/hooks/git", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListGitHooks", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List the Git hooks in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;GitHook&gt;</returns>
        public async System.Threading.Tasks.Task<List<GitHook>> RepoListGitHooksAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<GitHook>> localVarResponse = await RepoListGitHooksWithHttpInfoAsync(owner, repo, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List the Git hooks in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;GitHook&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<GitHook>>> RepoListGitHooksWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListGitHooks");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListGitHooks");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoListGitHooks";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<GitHook>>("/repos/{owner}/{repo}/hooks/git", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListGitHooks", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get specified ref or filtered repository&#39;s refs 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varRef">part or full name of the ref</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;Reference&gt;</returns>
        public List<Reference> RepoListGitRefs(string owner, string repo, string varRef, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<Reference>> localVarResponse = RepoListGitRefsWithHttpInfo(owner, repo, varRef);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get specified ref or filtered repository&#39;s refs 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varRef">part or full name of the ref</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;Reference&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<Reference>> RepoListGitRefsWithHttpInfo(string owner, string repo, string varRef, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListGitRefs");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListGitRefs");
            }

            // verify the required parameter 'varRef' is set
            if (varRef == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'varRef' when calling RepositoryApi->RepoListGitRefs");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("ref", Org.OpenAPITools.Client.ClientUtils.ParameterToString(varRef)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoListGitRefs";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<Reference>>("/repos/{owner}/{repo}/git/refs/{ref}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListGitRefs", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get specified ref or filtered repository&#39;s refs 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varRef">part or full name of the ref</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Reference&gt;</returns>
        public async System.Threading.Tasks.Task<List<Reference>> RepoListGitRefsAsync(string owner, string repo, string varRef, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<Reference>> localVarResponse = await RepoListGitRefsWithHttpInfoAsync(owner, repo, varRef, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get specified ref or filtered repository&#39;s refs 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varRef">part or full name of the ref</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Reference&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<Reference>>> RepoListGitRefsWithHttpInfoAsync(string owner, string repo, string varRef, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListGitRefs");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListGitRefs");
            }

            // verify the required parameter 'varRef' is set
            if (varRef == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'varRef' when calling RepositoryApi->RepoListGitRefs");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("ref", Org.OpenAPITools.Client.ClientUtils.ParameterToString(varRef)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoListGitRefs";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<Reference>>("/repos/{owner}/{repo}/git/refs/{ref}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListGitRefs", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List the hooks in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;Hook&gt;</returns>
        public List<Hook> RepoListHooks(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<Hook>> localVarResponse = RepoListHooksWithHttpInfo(owner, repo, page, limit);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List the hooks in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;Hook&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<Hook>> RepoListHooksWithHttpInfo(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListHooks");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListHooks");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoListHooks";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<Hook>>("/repos/{owner}/{repo}/hooks", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListHooks", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List the hooks in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Hook&gt;</returns>
        public async System.Threading.Tasks.Task<List<Hook>> RepoListHooksAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<Hook>> localVarResponse = await RepoListHooksWithHttpInfoAsync(owner, repo, page, limit, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List the hooks in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Hook&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<Hook>>> RepoListHooksWithHttpInfoAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListHooks");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListHooks");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoListHooks";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<Hook>>("/repos/{owner}/{repo}/hooks", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListHooks", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List a repository&#39;s keys 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="keyId">the key_id to search for (optional)</param>
        /// <param name="fingerprint">fingerprint of the key (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;DeployKey&gt;</returns>
        public List<DeployKey> RepoListKeys(string owner, string repo, int? keyId = default(int?), string? fingerprint = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<DeployKey>> localVarResponse = RepoListKeysWithHttpInfo(owner, repo, keyId, fingerprint, page, limit);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List a repository&#39;s keys 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="keyId">the key_id to search for (optional)</param>
        /// <param name="fingerprint">fingerprint of the key (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;DeployKey&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<DeployKey>> RepoListKeysWithHttpInfo(string owner, string repo, int? keyId = default(int?), string? fingerprint = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListKeys");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListKeys");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (keyId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "key_id", keyId));
            }
            if (fingerprint != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "fingerprint", fingerprint));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoListKeys";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<DeployKey>>("/repos/{owner}/{repo}/keys", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListKeys", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List a repository&#39;s keys 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="keyId">the key_id to search for (optional)</param>
        /// <param name="fingerprint">fingerprint of the key (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;DeployKey&gt;</returns>
        public async System.Threading.Tasks.Task<List<DeployKey>> RepoListKeysAsync(string owner, string repo, int? keyId = default(int?), string? fingerprint = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<DeployKey>> localVarResponse = await RepoListKeysWithHttpInfoAsync(owner, repo, keyId, fingerprint, page, limit, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List a repository&#39;s keys 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="keyId">the key_id to search for (optional)</param>
        /// <param name="fingerprint">fingerprint of the key (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;DeployKey&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<DeployKey>>> RepoListKeysWithHttpInfoAsync(string owner, string repo, int? keyId = default(int?), string? fingerprint = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListKeys");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListKeys");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (keyId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "key_id", keyId));
            }
            if (fingerprint != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "fingerprint", fingerprint));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoListKeys";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<DeployKey>>("/repos/{owner}/{repo}/keys", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListKeys", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List a repo&#39;s pinned issues 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;Issue&gt;</returns>
        public List<Issue> RepoListPinnedIssues(string owner, string repo, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<Issue>> localVarResponse = RepoListPinnedIssuesWithHttpInfo(owner, repo);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List a repo&#39;s pinned issues 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;Issue&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<Issue>> RepoListPinnedIssuesWithHttpInfo(string owner, string repo, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListPinnedIssues");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListPinnedIssues");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoListPinnedIssues";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<Issue>>("/repos/{owner}/{repo}/issues/pinned", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListPinnedIssues", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List a repo&#39;s pinned issues 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Issue&gt;</returns>
        public async System.Threading.Tasks.Task<List<Issue>> RepoListPinnedIssuesAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<Issue>> localVarResponse = await RepoListPinnedIssuesWithHttpInfoAsync(owner, repo, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List a repo&#39;s pinned issues 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Issue&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<Issue>>> RepoListPinnedIssuesWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListPinnedIssues");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListPinnedIssues");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoListPinnedIssues";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<Issue>>("/repos/{owner}/{repo}/issues/pinned", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListPinnedIssues", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List a repo&#39;s pinned pull requests 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;PullRequest&gt;</returns>
        public List<PullRequest> RepoListPinnedPullRequests(string owner, string repo, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<PullRequest>> localVarResponse = RepoListPinnedPullRequestsWithHttpInfo(owner, repo);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List a repo&#39;s pinned pull requests 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;PullRequest&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<PullRequest>> RepoListPinnedPullRequestsWithHttpInfo(string owner, string repo, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListPinnedPullRequests");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListPinnedPullRequests");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoListPinnedPullRequests";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<PullRequest>>("/repos/{owner}/{repo}/pulls/pinned", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListPinnedPullRequests", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List a repo&#39;s pinned pull requests 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;PullRequest&gt;</returns>
        public async System.Threading.Tasks.Task<List<PullRequest>> RepoListPinnedPullRequestsAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<PullRequest>> localVarResponse = await RepoListPinnedPullRequestsWithHttpInfoAsync(owner, repo, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List a repo&#39;s pinned pull requests 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;PullRequest&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<PullRequest>>> RepoListPinnedPullRequestsWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListPinnedPullRequests");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListPinnedPullRequests");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoListPinnedPullRequests";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<PullRequest>>("/repos/{owner}/{repo}/pulls/pinned", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListPinnedPullRequests", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List a repo&#39;s pull requests 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="state">State of pull request: open or closed (optional) (optional)</param>
        /// <param name="sort">Type of sort (optional)</param>
        /// <param name="milestone">ID of the milestone (optional)</param>
        /// <param name="labels">Label IDs (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;PullRequest&gt;</returns>
        public List<PullRequest> RepoListPullRequests(string owner, string repo, string? state = default(string?), string? sort = default(string?), long? milestone = default(long?), List<long>? labels = default(List<long>?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<PullRequest>> localVarResponse = RepoListPullRequestsWithHttpInfo(owner, repo, state, sort, milestone, labels, page, limit);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List a repo&#39;s pull requests 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="state">State of pull request: open or closed (optional) (optional)</param>
        /// <param name="sort">Type of sort (optional)</param>
        /// <param name="milestone">ID of the milestone (optional)</param>
        /// <param name="labels">Label IDs (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;PullRequest&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<PullRequest>> RepoListPullRequestsWithHttpInfo(string owner, string repo, string? state = default(string?), string? sort = default(string?), long? milestone = default(long?), List<long>? labels = default(List<long>?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListPullRequests");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListPullRequests");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (state != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "state", state));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (milestone != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "milestone", milestone));
            }
            if (labels != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("multi", "labels", labels));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoListPullRequests";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<PullRequest>>("/repos/{owner}/{repo}/pulls", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListPullRequests", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List a repo&#39;s pull requests 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="state">State of pull request: open or closed (optional) (optional)</param>
        /// <param name="sort">Type of sort (optional)</param>
        /// <param name="milestone">ID of the milestone (optional)</param>
        /// <param name="labels">Label IDs (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;PullRequest&gt;</returns>
        public async System.Threading.Tasks.Task<List<PullRequest>> RepoListPullRequestsAsync(string owner, string repo, string? state = default(string?), string? sort = default(string?), long? milestone = default(long?), List<long>? labels = default(List<long>?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<PullRequest>> localVarResponse = await RepoListPullRequestsWithHttpInfoAsync(owner, repo, state, sort, milestone, labels, page, limit, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List a repo&#39;s pull requests 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="state">State of pull request: open or closed (optional) (optional)</param>
        /// <param name="sort">Type of sort (optional)</param>
        /// <param name="milestone">ID of the milestone (optional)</param>
        /// <param name="labels">Label IDs (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;PullRequest&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<PullRequest>>> RepoListPullRequestsWithHttpInfoAsync(string owner, string repo, string? state = default(string?), string? sort = default(string?), long? milestone = default(long?), List<long>? labels = default(List<long>?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListPullRequests");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListPullRequests");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (state != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "state", state));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (milestone != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "milestone", milestone));
            }
            if (labels != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("multi", "labels", labels));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoListPullRequests";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<PullRequest>>("/repos/{owner}/{repo}/pulls", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListPullRequests", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List all reviews for a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;PullReview&gt;</returns>
        public List<PullReview> RepoListPullReviews(string owner, string repo, long index, int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<PullReview>> localVarResponse = RepoListPullReviewsWithHttpInfo(owner, repo, index, page, limit);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List all reviews for a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;PullReview&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<PullReview>> RepoListPullReviewsWithHttpInfo(string owner, string repo, long index, int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListPullReviews");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListPullReviews");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoListPullReviews";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<PullReview>>("/repos/{owner}/{repo}/pulls/{index}/reviews", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListPullReviews", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List all reviews for a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;PullReview&gt;</returns>
        public async System.Threading.Tasks.Task<List<PullReview>> RepoListPullReviewsAsync(string owner, string repo, long index, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<PullReview>> localVarResponse = await RepoListPullReviewsWithHttpInfoAsync(owner, repo, index, page, limit, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List all reviews for a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;PullReview&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<PullReview>>> RepoListPullReviewsWithHttpInfoAsync(string owner, string repo, long index, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListPullReviews");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListPullReviews");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoListPullReviews";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<PullReview>>("/repos/{owner}/{repo}/pulls/{index}/reviews", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListPullReviews", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get all push mirrors of the repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;PushMirror&gt;</returns>
        public List<PushMirror> RepoListPushMirrors(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<PushMirror>> localVarResponse = RepoListPushMirrorsWithHttpInfo(owner, repo, page, limit);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get all push mirrors of the repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;PushMirror&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<PushMirror>> RepoListPushMirrorsWithHttpInfo(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListPushMirrors");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListPushMirrors");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoListPushMirrors";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<PushMirror>>("/repos/{owner}/{repo}/push_mirrors", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListPushMirrors", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get all push mirrors of the repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;PushMirror&gt;</returns>
        public async System.Threading.Tasks.Task<List<PushMirror>> RepoListPushMirrorsAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<PushMirror>> localVarResponse = await RepoListPushMirrorsWithHttpInfoAsync(owner, repo, page, limit, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get all push mirrors of the repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;PushMirror&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<PushMirror>>> RepoListPushMirrorsWithHttpInfoAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListPushMirrors");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListPushMirrors");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoListPushMirrors";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<PushMirror>>("/repos/{owner}/{repo}/push_mirrors", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListPushMirrors", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List release&#39;s attachments 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;Attachment&gt;</returns>
        public List<Attachment> RepoListReleaseAttachments(string owner, string repo, long id, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<Attachment>> localVarResponse = RepoListReleaseAttachmentsWithHttpInfo(owner, repo, id);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List release&#39;s attachments 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;Attachment&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<Attachment>> RepoListReleaseAttachmentsWithHttpInfo(string owner, string repo, long id, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListReleaseAttachments");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListReleaseAttachments");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoListReleaseAttachments";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<Attachment>>("/repos/{owner}/{repo}/releases/{id}/assets", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListReleaseAttachments", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List release&#39;s attachments 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Attachment&gt;</returns>
        public async System.Threading.Tasks.Task<List<Attachment>> RepoListReleaseAttachmentsAsync(string owner, string repo, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<Attachment>> localVarResponse = await RepoListReleaseAttachmentsWithHttpInfoAsync(owner, repo, id, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List release&#39;s attachments 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the release</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Attachment&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<Attachment>>> RepoListReleaseAttachmentsWithHttpInfoAsync(string owner, string repo, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListReleaseAttachments");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListReleaseAttachments");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoListReleaseAttachments";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<Attachment>>("/repos/{owner}/{repo}/releases/{id}/assets", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListReleaseAttachments", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List a repo&#39;s releases 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="draft">filter (exclude / include) drafts, if you dont have repo write access none will show (optional)</param>
        /// <param name="preRelease">filter (exclude / include) pre-releases (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;Release&gt;</returns>
        public List<Release> RepoListReleases(string owner, string repo, bool? draft = default(bool?), bool? preRelease = default(bool?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<Release>> localVarResponse = RepoListReleasesWithHttpInfo(owner, repo, draft, preRelease, page, limit);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List a repo&#39;s releases 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="draft">filter (exclude / include) drafts, if you dont have repo write access none will show (optional)</param>
        /// <param name="preRelease">filter (exclude / include) pre-releases (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;Release&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<Release>> RepoListReleasesWithHttpInfo(string owner, string repo, bool? draft = default(bool?), bool? preRelease = default(bool?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListReleases");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListReleases");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (draft != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "draft", draft));
            }
            if (preRelease != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "pre-release", preRelease));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoListReleases";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<Release>>("/repos/{owner}/{repo}/releases", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListReleases", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List a repo&#39;s releases 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="draft">filter (exclude / include) drafts, if you dont have repo write access none will show (optional)</param>
        /// <param name="preRelease">filter (exclude / include) pre-releases (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Release&gt;</returns>
        public async System.Threading.Tasks.Task<List<Release>> RepoListReleasesAsync(string owner, string repo, bool? draft = default(bool?), bool? preRelease = default(bool?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<Release>> localVarResponse = await RepoListReleasesWithHttpInfoAsync(owner, repo, draft, preRelease, page, limit, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List a repo&#39;s releases 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="draft">filter (exclude / include) drafts, if you dont have repo write access none will show (optional)</param>
        /// <param name="preRelease">filter (exclude / include) pre-releases (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Release&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<Release>>> RepoListReleasesWithHttpInfoAsync(string owner, string repo, bool? draft = default(bool?), bool? preRelease = default(bool?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListReleases");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListReleases");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (draft != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "draft", draft));
            }
            if (preRelease != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "pre-release", preRelease));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoListReleases";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<Release>>("/repos/{owner}/{repo}/releases", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListReleases", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List a repo&#39;s stargazers 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;User&gt;</returns>
        public List<User> RepoListStargazers(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<User>> localVarResponse = RepoListStargazersWithHttpInfo(owner, repo, page, limit);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List a repo&#39;s stargazers 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;User&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<User>> RepoListStargazersWithHttpInfo(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListStargazers");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListStargazers");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoListStargazers";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<User>>("/repos/{owner}/{repo}/stargazers", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListStargazers", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List a repo&#39;s stargazers 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;User&gt;</returns>
        public async System.Threading.Tasks.Task<List<User>> RepoListStargazersAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<User>> localVarResponse = await RepoListStargazersWithHttpInfoAsync(owner, repo, page, limit, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List a repo&#39;s stargazers 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;User&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<User>>> RepoListStargazersWithHttpInfoAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListStargazers");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListStargazers");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoListStargazers";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<User>>("/repos/{owner}/{repo}/stargazers", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListStargazers", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a commit&#39;s statuses 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the commit</param>
        /// <param name="sort">type of sort (optional)</param>
        /// <param name="state">type of state (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;CommitStatus&gt;</returns>
        public List<CommitStatus> RepoListStatuses(string owner, string repo, string sha, string? sort = default(string?), string? state = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<CommitStatus>> localVarResponse = RepoListStatusesWithHttpInfo(owner, repo, sha, sort, state, page, limit);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a commit&#39;s statuses 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the commit</param>
        /// <param name="sort">type of sort (optional)</param>
        /// <param name="state">type of state (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;CommitStatus&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<CommitStatus>> RepoListStatusesWithHttpInfo(string owner, string repo, string sha, string? sort = default(string?), string? state = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListStatuses");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListStatuses");
            }

            // verify the required parameter 'sha' is set
            if (sha == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'sha' when calling RepositoryApi->RepoListStatuses");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("sha", Org.OpenAPITools.Client.ClientUtils.ParameterToString(sha)); // path parameter
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (state != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "state", state));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoListStatuses";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<CommitStatus>>("/repos/{owner}/{repo}/statuses/{sha}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListStatuses", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a commit&#39;s statuses 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the commit</param>
        /// <param name="sort">type of sort (optional)</param>
        /// <param name="state">type of state (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;CommitStatus&gt;</returns>
        public async System.Threading.Tasks.Task<List<CommitStatus>> RepoListStatusesAsync(string owner, string repo, string sha, string? sort = default(string?), string? state = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<CommitStatus>> localVarResponse = await RepoListStatusesWithHttpInfoAsync(owner, repo, sha, sort, state, page, limit, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a commit&#39;s statuses 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="sha">sha of the commit</param>
        /// <param name="sort">type of sort (optional)</param>
        /// <param name="state">type of state (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;CommitStatus&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<CommitStatus>>> RepoListStatusesWithHttpInfoAsync(string owner, string repo, string sha, string? sort = default(string?), string? state = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListStatuses");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListStatuses");
            }

            // verify the required parameter 'sha' is set
            if (sha == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'sha' when calling RepositoryApi->RepoListStatuses");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("sha", Org.OpenAPITools.Client.ClientUtils.ParameterToString(sha)); // path parameter
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (state != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "state", state));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoListStatuses";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<CommitStatus>>("/repos/{owner}/{repo}/statuses/{sha}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListStatuses", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a commit&#39;s statuses, by branch/tag/commit reference 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varRef">name of branch/tag/commit</param>
        /// <param name="sort">type of sort (optional)</param>
        /// <param name="state">type of state (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;CommitStatus&gt;</returns>
        public List<CommitStatus> RepoListStatusesByRef(string owner, string repo, string varRef, string? sort = default(string?), string? state = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<CommitStatus>> localVarResponse = RepoListStatusesByRefWithHttpInfo(owner, repo, varRef, sort, state, page, limit);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a commit&#39;s statuses, by branch/tag/commit reference 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varRef">name of branch/tag/commit</param>
        /// <param name="sort">type of sort (optional)</param>
        /// <param name="state">type of state (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;CommitStatus&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<CommitStatus>> RepoListStatusesByRefWithHttpInfo(string owner, string repo, string varRef, string? sort = default(string?), string? state = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListStatusesByRef");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListStatusesByRef");
            }

            // verify the required parameter 'varRef' is set
            if (varRef == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'varRef' when calling RepositoryApi->RepoListStatusesByRef");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("ref", Org.OpenAPITools.Client.ClientUtils.ParameterToString(varRef)); // path parameter
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (state != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "state", state));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoListStatusesByRef";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<CommitStatus>>("/repos/{owner}/{repo}/commits/{ref}/statuses", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListStatusesByRef", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a commit&#39;s statuses, by branch/tag/commit reference 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varRef">name of branch/tag/commit</param>
        /// <param name="sort">type of sort (optional)</param>
        /// <param name="state">type of state (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;CommitStatus&gt;</returns>
        public async System.Threading.Tasks.Task<List<CommitStatus>> RepoListStatusesByRefAsync(string owner, string repo, string varRef, string? sort = default(string?), string? state = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<CommitStatus>> localVarResponse = await RepoListStatusesByRefWithHttpInfoAsync(owner, repo, varRef, sort, state, page, limit, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a commit&#39;s statuses, by branch/tag/commit reference 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="varRef">name of branch/tag/commit</param>
        /// <param name="sort">type of sort (optional)</param>
        /// <param name="state">type of state (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;CommitStatus&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<CommitStatus>>> RepoListStatusesByRefWithHttpInfoAsync(string owner, string repo, string varRef, string? sort = default(string?), string? state = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListStatusesByRef");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListStatusesByRef");
            }

            // verify the required parameter 'varRef' is set
            if (varRef == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'varRef' when calling RepositoryApi->RepoListStatusesByRef");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("ref", Org.OpenAPITools.Client.ClientUtils.ParameterToString(varRef)); // path parameter
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (state != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "state", state));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoListStatusesByRef";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<CommitStatus>>("/repos/{owner}/{repo}/commits/{ref}/statuses", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListStatusesByRef", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List a repo&#39;s watchers 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;User&gt;</returns>
        public List<User> RepoListSubscribers(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<User>> localVarResponse = RepoListSubscribersWithHttpInfo(owner, repo, page, limit);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List a repo&#39;s watchers 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;User&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<User>> RepoListSubscribersWithHttpInfo(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListSubscribers");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListSubscribers");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoListSubscribers";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<User>>("/repos/{owner}/{repo}/subscribers", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListSubscribers", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List a repo&#39;s watchers 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;User&gt;</returns>
        public async System.Threading.Tasks.Task<List<User>> RepoListSubscribersAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<User>> localVarResponse = await RepoListSubscribersWithHttpInfoAsync(owner, repo, page, limit, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List a repo&#39;s watchers 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;User&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<User>>> RepoListSubscribersWithHttpInfoAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListSubscribers");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListSubscribers");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoListSubscribers";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<User>>("/repos/{owner}/{repo}/subscribers", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListSubscribers", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List a repository&#39;s tags 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results, default maximum page size is 50 (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;Tag&gt;</returns>
        public List<Tag> RepoListTags(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<Tag>> localVarResponse = RepoListTagsWithHttpInfo(owner, repo, page, limit);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List a repository&#39;s tags 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results, default maximum page size is 50 (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;Tag&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<Tag>> RepoListTagsWithHttpInfo(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListTags");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListTags");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoListTags";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<Tag>>("/repos/{owner}/{repo}/tags", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListTags", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List a repository&#39;s tags 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results, default maximum page size is 50 (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Tag&gt;</returns>
        public async System.Threading.Tasks.Task<List<Tag>> RepoListTagsAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<Tag>> localVarResponse = await RepoListTagsWithHttpInfoAsync(owner, repo, page, limit, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List a repository&#39;s tags 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results, default maximum page size is 50 (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Tag&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<Tag>>> RepoListTagsWithHttpInfoAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListTags");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListTags");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoListTags";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<Tag>>("/repos/{owner}/{repo}/tags", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListTags", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List a repository&#39;s teams 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;Team&gt;</returns>
        public List<Team> RepoListTeams(string owner, string repo, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<Team>> localVarResponse = RepoListTeamsWithHttpInfo(owner, repo);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List a repository&#39;s teams 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;Team&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<Team>> RepoListTeamsWithHttpInfo(string owner, string repo, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListTeams");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListTeams");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoListTeams";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<Team>>("/repos/{owner}/{repo}/teams", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListTeams", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List a repository&#39;s teams 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Team&gt;</returns>
        public async System.Threading.Tasks.Task<List<Team>> RepoListTeamsAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<Team>> localVarResponse = await RepoListTeamsWithHttpInfoAsync(owner, repo, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List a repository&#39;s teams 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Team&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<Team>>> RepoListTeamsWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListTeams");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListTeams");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoListTeams";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<Team>>("/repos/{owner}/{repo}/teams", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListTeams", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get list of topics that a repository has 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>TopicName</returns>
        public TopicName RepoListTopics(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<TopicName> localVarResponse = RepoListTopicsWithHttpInfo(owner, repo, page, limit);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get list of topics that a repository has 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of TopicName</returns>
        public Org.OpenAPITools.Client.ApiResponse<TopicName> RepoListTopicsWithHttpInfo(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListTopics");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListTopics");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoListTopics";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<TopicName>("/repos/{owner}/{repo}/topics", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListTopics", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get list of topics that a repository has 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TopicName</returns>
        public async System.Threading.Tasks.Task<TopicName> RepoListTopicsAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<TopicName> localVarResponse = await RepoListTopicsWithHttpInfoAsync(owner, repo, page, limit, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get list of topics that a repository has 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TopicName)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<TopicName>> RepoListTopicsWithHttpInfoAsync(string owner, string repo, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoListTopics");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoListTopics");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoListTopics";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<TopicName>("/repos/{owner}/{repo}/topics", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoListTopics", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Merge a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to merge</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RepoMergePullRequest(string owner, string repo, long index, MergePullRequestOption? body = default(MergePullRequestOption?), int operationIndex = 0)
        {
            RepoMergePullRequestWithHttpInfo(owner, repo, index, body);
        }

        /// <summary>
        /// Merge a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to merge</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> RepoMergePullRequestWithHttpInfo(string owner, string repo, long index, MergePullRequestOption? body = default(MergePullRequestOption?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoMergePullRequest");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoMergePullRequest");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json",
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoMergePullRequest";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/repos/{owner}/{repo}/pulls/{index}/merge", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoMergePullRequest", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Merge a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to merge</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RepoMergePullRequestAsync(string owner, string repo, long index, MergePullRequestOption? body = default(MergePullRequestOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RepoMergePullRequestWithHttpInfoAsync(owner, repo, index, body, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Merge a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to merge</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> RepoMergePullRequestWithHttpInfoAsync(string owner, string repo, long index, MergePullRequestOption? body = default(MergePullRequestOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoMergePullRequest");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoMergePullRequest");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json", 
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoMergePullRequest";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/repos/{owner}/{repo}/pulls/{index}/merge", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoMergePullRequest", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Migrate a remote git repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Repository</returns>
        public Repository RepoMigrate(MigrateRepoOptions? body = default(MigrateRepoOptions?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<Repository> localVarResponse = RepoMigrateWithHttpInfo(body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Migrate a remote git repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Repository</returns>
        public Org.OpenAPITools.Client.ApiResponse<Repository> RepoMigrateWithHttpInfo(MigrateRepoOptions? body = default(MigrateRepoOptions?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoMigrate";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Repository>("/repos/migrate", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoMigrate", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Migrate a remote git repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Repository</returns>
        public async System.Threading.Tasks.Task<Repository> RepoMigrateAsync(MigrateRepoOptions? body = default(MigrateRepoOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<Repository> localVarResponse = await RepoMigrateWithHttpInfoAsync(body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Migrate a remote git repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Repository)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Repository>> RepoMigrateWithHttpInfoAsync(MigrateRepoOptions? body = default(MigrateRepoOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoMigrate";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Repository>("/repos/migrate", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoMigrate", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Sync a mirrored repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to sync</param>
        /// <param name="repo">name of the repo to sync</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RepoMirrorSync(string owner, string repo, int operationIndex = 0)
        {
            RepoMirrorSyncWithHttpInfo(owner, repo);
        }

        /// <summary>
        /// Sync a mirrored repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to sync</param>
        /// <param name="repo">name of the repo to sync</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> RepoMirrorSyncWithHttpInfo(string owner, string repo, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoMirrorSync");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoMirrorSync");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoMirrorSync";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/repos/{owner}/{repo}/mirror-sync", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoMirrorSync", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Sync a mirrored repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to sync</param>
        /// <param name="repo">name of the repo to sync</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RepoMirrorSyncAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RepoMirrorSyncWithHttpInfoAsync(owner, repo, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Sync a mirrored repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to sync</param>
        /// <param name="repo">name of the repo to sync</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> RepoMirrorSyncWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoMirrorSync");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoMirrorSync");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoMirrorSync";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/repos/{owner}/{repo}/mirror-sync", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoMirrorSync", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Returns if new Issue Pins are allowed 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>NewIssuePinsAllowed</returns>
        public NewIssuePinsAllowed RepoNewPinAllowed(string owner, string repo, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<NewIssuePinsAllowed> localVarResponse = RepoNewPinAllowedWithHttpInfo(owner, repo);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Returns if new Issue Pins are allowed 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of NewIssuePinsAllowed</returns>
        public Org.OpenAPITools.Client.ApiResponse<NewIssuePinsAllowed> RepoNewPinAllowedWithHttpInfo(string owner, string repo, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoNewPinAllowed");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoNewPinAllowed");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoNewPinAllowed";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<NewIssuePinsAllowed>("/repos/{owner}/{repo}/new_pin_allowed", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoNewPinAllowed", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Returns if new Issue Pins are allowed 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of NewIssuePinsAllowed</returns>
        public async System.Threading.Tasks.Task<NewIssuePinsAllowed> RepoNewPinAllowedAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<NewIssuePinsAllowed> localVarResponse = await RepoNewPinAllowedWithHttpInfoAsync(owner, repo, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Returns if new Issue Pins are allowed 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (NewIssuePinsAllowed)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<NewIssuePinsAllowed>> RepoNewPinAllowedWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoNewPinAllowed");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoNewPinAllowed");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoNewPinAllowed";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<NewIssuePinsAllowed>("/repos/{owner}/{repo}/new_pin_allowed", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoNewPinAllowed", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Check if a pull request has been merged 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RepoPullRequestIsMerged(string owner, string repo, long index, int operationIndex = 0)
        {
            RepoPullRequestIsMergedWithHttpInfo(owner, repo, index);
        }

        /// <summary>
        /// Check if a pull request has been merged 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> RepoPullRequestIsMergedWithHttpInfo(string owner, string repo, long index, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoPullRequestIsMerged");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoPullRequestIsMerged");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoPullRequestIsMerged";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Object>("/repos/{owner}/{repo}/pulls/{index}/merge", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoPullRequestIsMerged", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Check if a pull request has been merged 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RepoPullRequestIsMergedAsync(string owner, string repo, long index, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RepoPullRequestIsMergedWithHttpInfoAsync(owner, repo, index, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Check if a pull request has been merged 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> RepoPullRequestIsMergedWithHttpInfoAsync(string owner, string repo, long index, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoPullRequestIsMerged");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoPullRequestIsMerged");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoPullRequestIsMerged";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Object>("/repos/{owner}/{repo}/pulls/{index}/merge", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoPullRequestIsMerged", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Sync all push mirrored repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to sync</param>
        /// <param name="repo">name of the repo to sync</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RepoPushMirrorSync(string owner, string repo, int operationIndex = 0)
        {
            RepoPushMirrorSyncWithHttpInfo(owner, repo);
        }

        /// <summary>
        /// Sync all push mirrored repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to sync</param>
        /// <param name="repo">name of the repo to sync</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> RepoPushMirrorSyncWithHttpInfo(string owner, string repo, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoPushMirrorSync");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoPushMirrorSync");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoPushMirrorSync";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/repos/{owner}/{repo}/push_mirrors-sync", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoPushMirrorSync", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Sync all push mirrored repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to sync</param>
        /// <param name="repo">name of the repo to sync</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RepoPushMirrorSyncAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RepoPushMirrorSyncWithHttpInfoAsync(owner, repo, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Sync all push mirrored repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to sync</param>
        /// <param name="repo">name of the repo to sync</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> RepoPushMirrorSyncWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoPushMirrorSync");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoPushMirrorSync");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoPushMirrorSync";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/repos/{owner}/{repo}/push_mirrors-sync", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoPushMirrorSync", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search for repositories 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">keyword (optional)</param>
        /// <param name="topic">Limit search to repositories with keyword as topic (optional)</param>
        /// <param name="includeDesc">include search of keyword within repository description (optional)</param>
        /// <param name="uid">search only for repos that the user with the given id owns or contributes to (optional)</param>
        /// <param name="priorityOwnerId">repo owner to prioritize in the results (optional)</param>
        /// <param name="teamId">search only for repos that belong to the given team id (optional)</param>
        /// <param name="starredBy">search only for repos that the user with the given id has starred (optional)</param>
        /// <param name="varPrivate">include private repositories this user has access to (defaults to true) (optional)</param>
        /// <param name="isPrivate">show only pubic, private or all repositories (defaults to all) (optional)</param>
        /// <param name="template">include template repositories this user has access to (defaults to true) (optional)</param>
        /// <param name="archived">show only archived, non-archived or all repositories (defaults to all) (optional)</param>
        /// <param name="mode">type of repository to search for. Supported values are \&quot;fork\&quot;, \&quot;source\&quot;, \&quot;mirror\&quot; and \&quot;collaborative\&quot; (optional)</param>
        /// <param name="exclusive">if &#x60;uid&#x60; is given, search only for repos that the user owns (optional)</param>
        /// <param name="sort">sort repos by attribute. Supported values are \&quot;alpha\&quot;, \&quot;created\&quot;, \&quot;updated\&quot;, \&quot;size\&quot;, and \&quot;id\&quot;. Default is \&quot;alpha\&quot; (optional)</param>
        /// <param name="order">sort order, either \&quot;asc\&quot; (ascending) or \&quot;desc\&quot; (descending). Default is \&quot;asc\&quot;, ignored if \&quot;sort\&quot; is not specified. (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SearchResults</returns>
        public SearchResults RepoSearch(string? q = default(string?), bool? topic = default(bool?), bool? includeDesc = default(bool?), long? uid = default(long?), long? priorityOwnerId = default(long?), long? teamId = default(long?), long? starredBy = default(long?), bool? varPrivate = default(bool?), bool? isPrivate = default(bool?), bool? template = default(bool?), bool? archived = default(bool?), string? mode = default(string?), bool? exclusive = default(bool?), string? sort = default(string?), string? order = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<SearchResults> localVarResponse = RepoSearchWithHttpInfo(q, topic, includeDesc, uid, priorityOwnerId, teamId, starredBy, varPrivate, isPrivate, template, archived, mode, exclusive, sort, order, page, limit);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search for repositories 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">keyword (optional)</param>
        /// <param name="topic">Limit search to repositories with keyword as topic (optional)</param>
        /// <param name="includeDesc">include search of keyword within repository description (optional)</param>
        /// <param name="uid">search only for repos that the user with the given id owns or contributes to (optional)</param>
        /// <param name="priorityOwnerId">repo owner to prioritize in the results (optional)</param>
        /// <param name="teamId">search only for repos that belong to the given team id (optional)</param>
        /// <param name="starredBy">search only for repos that the user with the given id has starred (optional)</param>
        /// <param name="varPrivate">include private repositories this user has access to (defaults to true) (optional)</param>
        /// <param name="isPrivate">show only pubic, private or all repositories (defaults to all) (optional)</param>
        /// <param name="template">include template repositories this user has access to (defaults to true) (optional)</param>
        /// <param name="archived">show only archived, non-archived or all repositories (defaults to all) (optional)</param>
        /// <param name="mode">type of repository to search for. Supported values are \&quot;fork\&quot;, \&quot;source\&quot;, \&quot;mirror\&quot; and \&quot;collaborative\&quot; (optional)</param>
        /// <param name="exclusive">if &#x60;uid&#x60; is given, search only for repos that the user owns (optional)</param>
        /// <param name="sort">sort repos by attribute. Supported values are \&quot;alpha\&quot;, \&quot;created\&quot;, \&quot;updated\&quot;, \&quot;size\&quot;, and \&quot;id\&quot;. Default is \&quot;alpha\&quot; (optional)</param>
        /// <param name="order">sort order, either \&quot;asc\&quot; (ascending) or \&quot;desc\&quot; (descending). Default is \&quot;asc\&quot;, ignored if \&quot;sort\&quot; is not specified. (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SearchResults</returns>
        public Org.OpenAPITools.Client.ApiResponse<SearchResults> RepoSearchWithHttpInfo(string? q = default(string?), bool? topic = default(bool?), bool? includeDesc = default(bool?), long? uid = default(long?), long? priorityOwnerId = default(long?), long? teamId = default(long?), long? starredBy = default(long?), bool? varPrivate = default(bool?), bool? isPrivate = default(bool?), bool? template = default(bool?), bool? archived = default(bool?), string? mode = default(string?), bool? exclusive = default(bool?), string? sort = default(string?), string? order = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (q != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "q", q));
            }
            if (topic != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "topic", topic));
            }
            if (includeDesc != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "includeDesc", includeDesc));
            }
            if (uid != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "uid", uid));
            }
            if (priorityOwnerId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "priority_owner_id", priorityOwnerId));
            }
            if (teamId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "team_id", teamId));
            }
            if (starredBy != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "starredBy", starredBy));
            }
            if (varPrivate != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "private", varPrivate));
            }
            if (isPrivate != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "is_private", isPrivate));
            }
            if (template != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "template", template));
            }
            if (archived != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "archived", archived));
            }
            if (mode != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "mode", mode));
            }
            if (exclusive != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "exclusive", exclusive));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (order != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "order", order));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoSearch";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<SearchResults>("/repos/search", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoSearch", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Search for repositories 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">keyword (optional)</param>
        /// <param name="topic">Limit search to repositories with keyword as topic (optional)</param>
        /// <param name="includeDesc">include search of keyword within repository description (optional)</param>
        /// <param name="uid">search only for repos that the user with the given id owns or contributes to (optional)</param>
        /// <param name="priorityOwnerId">repo owner to prioritize in the results (optional)</param>
        /// <param name="teamId">search only for repos that belong to the given team id (optional)</param>
        /// <param name="starredBy">search only for repos that the user with the given id has starred (optional)</param>
        /// <param name="varPrivate">include private repositories this user has access to (defaults to true) (optional)</param>
        /// <param name="isPrivate">show only pubic, private or all repositories (defaults to all) (optional)</param>
        /// <param name="template">include template repositories this user has access to (defaults to true) (optional)</param>
        /// <param name="archived">show only archived, non-archived or all repositories (defaults to all) (optional)</param>
        /// <param name="mode">type of repository to search for. Supported values are \&quot;fork\&quot;, \&quot;source\&quot;, \&quot;mirror\&quot; and \&quot;collaborative\&quot; (optional)</param>
        /// <param name="exclusive">if &#x60;uid&#x60; is given, search only for repos that the user owns (optional)</param>
        /// <param name="sort">sort repos by attribute. Supported values are \&quot;alpha\&quot;, \&quot;created\&quot;, \&quot;updated\&quot;, \&quot;size\&quot;, and \&quot;id\&quot;. Default is \&quot;alpha\&quot; (optional)</param>
        /// <param name="order">sort order, either \&quot;asc\&quot; (ascending) or \&quot;desc\&quot; (descending). Default is \&quot;asc\&quot;, ignored if \&quot;sort\&quot; is not specified. (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SearchResults</returns>
        public async System.Threading.Tasks.Task<SearchResults> RepoSearchAsync(string? q = default(string?), bool? topic = default(bool?), bool? includeDesc = default(bool?), long? uid = default(long?), long? priorityOwnerId = default(long?), long? teamId = default(long?), long? starredBy = default(long?), bool? varPrivate = default(bool?), bool? isPrivate = default(bool?), bool? template = default(bool?), bool? archived = default(bool?), string? mode = default(string?), bool? exclusive = default(bool?), string? sort = default(string?), string? order = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<SearchResults> localVarResponse = await RepoSearchWithHttpInfoAsync(q, topic, includeDesc, uid, priorityOwnerId, teamId, starredBy, varPrivate, isPrivate, template, archived, mode, exclusive, sort, order, page, limit, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Search for repositories 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">keyword (optional)</param>
        /// <param name="topic">Limit search to repositories with keyword as topic (optional)</param>
        /// <param name="includeDesc">include search of keyword within repository description (optional)</param>
        /// <param name="uid">search only for repos that the user with the given id owns or contributes to (optional)</param>
        /// <param name="priorityOwnerId">repo owner to prioritize in the results (optional)</param>
        /// <param name="teamId">search only for repos that belong to the given team id (optional)</param>
        /// <param name="starredBy">search only for repos that the user with the given id has starred (optional)</param>
        /// <param name="varPrivate">include private repositories this user has access to (defaults to true) (optional)</param>
        /// <param name="isPrivate">show only pubic, private or all repositories (defaults to all) (optional)</param>
        /// <param name="template">include template repositories this user has access to (defaults to true) (optional)</param>
        /// <param name="archived">show only archived, non-archived or all repositories (defaults to all) (optional)</param>
        /// <param name="mode">type of repository to search for. Supported values are \&quot;fork\&quot;, \&quot;source\&quot;, \&quot;mirror\&quot; and \&quot;collaborative\&quot; (optional)</param>
        /// <param name="exclusive">if &#x60;uid&#x60; is given, search only for repos that the user owns (optional)</param>
        /// <param name="sort">sort repos by attribute. Supported values are \&quot;alpha\&quot;, \&quot;created\&quot;, \&quot;updated\&quot;, \&quot;size\&quot;, and \&quot;id\&quot;. Default is \&quot;alpha\&quot; (optional)</param>
        /// <param name="order">sort order, either \&quot;asc\&quot; (ascending) or \&quot;desc\&quot; (descending). Default is \&quot;asc\&quot;, ignored if \&quot;sort\&quot; is not specified. (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SearchResults)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<SearchResults>> RepoSearchWithHttpInfoAsync(string? q = default(string?), bool? topic = default(bool?), bool? includeDesc = default(bool?), long? uid = default(long?), long? priorityOwnerId = default(long?), long? teamId = default(long?), long? starredBy = default(long?), bool? varPrivate = default(bool?), bool? isPrivate = default(bool?), bool? template = default(bool?), bool? archived = default(bool?), string? mode = default(string?), bool? exclusive = default(bool?), string? sort = default(string?), string? order = default(string?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (q != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "q", q));
            }
            if (topic != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "topic", topic));
            }
            if (includeDesc != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "includeDesc", includeDesc));
            }
            if (uid != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "uid", uid));
            }
            if (priorityOwnerId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "priority_owner_id", priorityOwnerId));
            }
            if (teamId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "team_id", teamId));
            }
            if (starredBy != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "starredBy", starredBy));
            }
            if (varPrivate != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "private", varPrivate));
            }
            if (isPrivate != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "is_private", isPrivate));
            }
            if (template != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "template", template));
            }
            if (archived != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "archived", archived));
            }
            if (mode != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "mode", mode));
            }
            if (exclusive != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "exclusive", exclusive));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (order != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "order", order));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoSearch";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<SearchResults>("/repos/search", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoSearch", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get signing-key.gpg for given repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>string</returns>
        public string RepoSigningKey(string owner, string repo, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<string> localVarResponse = RepoSigningKeyWithHttpInfo(owner, repo);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get signing-key.gpg for given repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of string</returns>
        public Org.OpenAPITools.Client.ApiResponse<string> RepoSigningKeyWithHttpInfo(string owner, string repo, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoSigningKey");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoSigningKey");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoSigningKey";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<string>("/repos/{owner}/{repo}/signing-key.gpg", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoSigningKey", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get signing-key.gpg for given repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> RepoSigningKeyAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<string> localVarResponse = await RepoSigningKeyWithHttpInfoAsync(owner, repo, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get signing-key.gpg for given repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<string>> RepoSigningKeyWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoSigningKey");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoSigningKey");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "text/plain"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoSigningKey";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<string>("/repos/{owner}/{repo}/signing-key.gpg", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoSigningKey", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Submit a pending review to an pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PullReview</returns>
        public PullReview RepoSubmitPullReview(string owner, string repo, long index, long id, SubmitPullReviewOptions body, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<PullReview> localVarResponse = RepoSubmitPullReviewWithHttpInfo(owner, repo, index, id, body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Submit a pending review to an pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PullReview</returns>
        public Org.OpenAPITools.Client.ApiResponse<PullReview> RepoSubmitPullReviewWithHttpInfo(string owner, string repo, long index, long id, SubmitPullReviewOptions body, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoSubmitPullReview");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoSubmitPullReview");
            }

            // verify the required parameter 'body' is set
            if (body == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'body' when calling RepositoryApi->RepoSubmitPullReview");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json",
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoSubmitPullReview";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<PullReview>("/repos/{owner}/{repo}/pulls/{index}/reviews/{id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoSubmitPullReview", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Submit a pending review to an pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PullReview</returns>
        public async System.Threading.Tasks.Task<PullReview> RepoSubmitPullReviewAsync(string owner, string repo, long index, long id, SubmitPullReviewOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<PullReview> localVarResponse = await RepoSubmitPullReviewWithHttpInfoAsync(owner, repo, index, id, body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Submit a pending review to an pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PullReview)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<PullReview>> RepoSubmitPullReviewWithHttpInfoAsync(string owner, string repo, long index, long id, SubmitPullReviewOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoSubmitPullReview");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoSubmitPullReview");
            }

            // verify the required parameter 'body' is set
            if (body == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'body' when calling RepositoryApi->RepoSubmitPullReview");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json", 
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoSubmitPullReview";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<PullReview>("/repos/{owner}/{repo}/pulls/{index}/reviews/{id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoSubmitPullReview", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Test a push webhook 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to test</param>
        /// <param name="varRef">The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RepoTestHook(string owner, string repo, long id, string? varRef = default(string?), int operationIndex = 0)
        {
            RepoTestHookWithHttpInfo(owner, repo, id, varRef);
        }

        /// <summary>
        /// Test a push webhook 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to test</param>
        /// <param name="varRef">The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> RepoTestHookWithHttpInfo(string owner, string repo, long id, string? varRef = default(string?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoTestHook");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoTestHook");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter
            if (varRef != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "ref", varRef));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoTestHook";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/repos/{owner}/{repo}/hooks/{id}/tests", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoTestHook", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Test a push webhook 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to test</param>
        /// <param name="varRef">The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RepoTestHookAsync(string owner, string repo, long id, string? varRef = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RepoTestHookWithHttpInfoAsync(owner, repo, id, varRef, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Test a push webhook 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="id">id of the hook to test</param>
        /// <param name="varRef">The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> RepoTestHookWithHttpInfoAsync(string owner, string repo, long id, string? varRef = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoTestHook");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoTestHook");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter
            if (varRef != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "ref", varRef));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoTestHook";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/repos/{owner}/{repo}/hooks/{id}/tests", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoTestHook", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List a repo&#39;s tracked times 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="user">optional filter by user (available for issue managers) (optional)</param>
        /// <param name="since">Only show times updated after the given time. This is a timestamp in RFC 3339 format (optional)</param>
        /// <param name="before">Only show times updated before the given time. This is a timestamp in RFC 3339 format (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;TrackedTime&gt;</returns>
        public List<TrackedTime> RepoTrackedTimes(string owner, string repo, string? user = default(string?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<TrackedTime>> localVarResponse = RepoTrackedTimesWithHttpInfo(owner, repo, user, since, before, page, limit);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List a repo&#39;s tracked times 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="user">optional filter by user (available for issue managers) (optional)</param>
        /// <param name="since">Only show times updated after the given time. This is a timestamp in RFC 3339 format (optional)</param>
        /// <param name="before">Only show times updated before the given time. This is a timestamp in RFC 3339 format (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;TrackedTime&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<TrackedTime>> RepoTrackedTimesWithHttpInfo(string owner, string repo, string? user = default(string?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoTrackedTimes");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoTrackedTimes");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (user != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "user", user));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoTrackedTimes";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<TrackedTime>>("/repos/{owner}/{repo}/times", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoTrackedTimes", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List a repo&#39;s tracked times 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="user">optional filter by user (available for issue managers) (optional)</param>
        /// <param name="since">Only show times updated after the given time. This is a timestamp in RFC 3339 format (optional)</param>
        /// <param name="before">Only show times updated before the given time. This is a timestamp in RFC 3339 format (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;TrackedTime&gt;</returns>
        public async System.Threading.Tasks.Task<List<TrackedTime>> RepoTrackedTimesAsync(string owner, string repo, string? user = default(string?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<TrackedTime>> localVarResponse = await RepoTrackedTimesWithHttpInfoAsync(owner, repo, user, since, before, page, limit, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List a repo&#39;s tracked times 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="user">optional filter by user (available for issue managers) (optional)</param>
        /// <param name="since">Only show times updated after the given time. This is a timestamp in RFC 3339 format (optional)</param>
        /// <param name="before">Only show times updated before the given time. This is a timestamp in RFC 3339 format (optional)</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;TrackedTime&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<TrackedTime>>> RepoTrackedTimesWithHttpInfoAsync(string owner, string repo, string? user = default(string?), DateTime? since = default(DateTime?), DateTime? before = default(DateTime?), int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoTrackedTimes");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoTrackedTimes");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            if (user != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "user", user));
            }
            if (since != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "since", since));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoTrackedTimes";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<TrackedTime>>("/repos/{owner}/{repo}/times", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoTrackedTimes", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Transfer a repo ownership 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to transfer</param>
        /// <param name="repo">name of the repo to transfer</param>
        /// <param name="body">Transfer Options</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Repository</returns>
        public Repository RepoTransfer(string owner, string repo, TransferRepoOption body, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<Repository> localVarResponse = RepoTransferWithHttpInfo(owner, repo, body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Transfer a repo ownership 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to transfer</param>
        /// <param name="repo">name of the repo to transfer</param>
        /// <param name="body">Transfer Options</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Repository</returns>
        public Org.OpenAPITools.Client.ApiResponse<Repository> RepoTransferWithHttpInfo(string owner, string repo, TransferRepoOption body, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoTransfer");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoTransfer");
            }

            // verify the required parameter 'body' is set
            if (body == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'body' when calling RepositoryApi->RepoTransfer");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json",
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoTransfer";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Repository>("/repos/{owner}/{repo}/transfer", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoTransfer", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Transfer a repo ownership 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to transfer</param>
        /// <param name="repo">name of the repo to transfer</param>
        /// <param name="body">Transfer Options</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Repository</returns>
        public async System.Threading.Tasks.Task<Repository> RepoTransferAsync(string owner, string repo, TransferRepoOption body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<Repository> localVarResponse = await RepoTransferWithHttpInfoAsync(owner, repo, body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Transfer a repo ownership 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo to transfer</param>
        /// <param name="repo">name of the repo to transfer</param>
        /// <param name="body">Transfer Options</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Repository)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Repository>> RepoTransferWithHttpInfoAsync(string owner, string repo, TransferRepoOption body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoTransfer");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoTransfer");
            }

            // verify the required parameter 'body' is set
            if (body == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'body' when calling RepositoryApi->RepoTransfer");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json", 
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoTransfer";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Repository>("/repos/{owner}/{repo}/transfer", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoTransfer", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Cancel to dismiss a review for a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PullReview</returns>
        public PullReview RepoUnDismissPullReview(string owner, string repo, long index, long id, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<PullReview> localVarResponse = RepoUnDismissPullReviewWithHttpInfo(owner, repo, index, id);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Cancel to dismiss a review for a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PullReview</returns>
        public Org.OpenAPITools.Client.ApiResponse<PullReview> RepoUnDismissPullReviewWithHttpInfo(string owner, string repo, long index, long id, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoUnDismissPullReview");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoUnDismissPullReview");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoUnDismissPullReview";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<PullReview>("/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/undismissals", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoUnDismissPullReview", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Cancel to dismiss a review for a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PullReview</returns>
        public async System.Threading.Tasks.Task<PullReview> RepoUnDismissPullReviewAsync(string owner, string repo, long index, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<PullReview> localVarResponse = await RepoUnDismissPullReviewWithHttpInfoAsync(owner, repo, index, id, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Cancel to dismiss a review for a pull request 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request</param>
        /// <param name="id">id of the review</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PullReview)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<PullReview>> RepoUnDismissPullReviewWithHttpInfoAsync(string owner, string repo, long index, long id, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoUnDismissPullReview");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoUnDismissPullReview");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter
            localVarRequestOptions.PathParameters.Add("id", Org.OpenAPITools.Client.ClientUtils.ParameterToString(id)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoUnDismissPullReview";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<PullReview>("/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/undismissals", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoUnDismissPullReview", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update avatar 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RepoUpdateAvatar(string owner, string repo, UpdateRepoAvatarOption? body = default(UpdateRepoAvatarOption?), int operationIndex = 0)
        {
            RepoUpdateAvatarWithHttpInfo(owner, repo, body);
        }

        /// <summary>
        /// Update avatar 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> RepoUpdateAvatarWithHttpInfo(string owner, string repo, UpdateRepoAvatarOption? body = default(UpdateRepoAvatarOption?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoUpdateAvatar");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoUpdateAvatar");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json",
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoUpdateAvatar";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/repos/{owner}/{repo}/avatar", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoUpdateAvatar", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update avatar 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RepoUpdateAvatarAsync(string owner, string repo, UpdateRepoAvatarOption? body = default(UpdateRepoAvatarOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RepoUpdateAvatarWithHttpInfoAsync(owner, repo, body, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Update avatar 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> RepoUpdateAvatarWithHttpInfoAsync(string owner, string repo, UpdateRepoAvatarOption? body = default(UpdateRepoAvatarOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoUpdateAvatar");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoUpdateAvatar");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json", 
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoUpdateAvatar";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/repos/{owner}/{repo}/avatar", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoUpdateAvatar", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update a file in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">path of the file to update</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>FileResponse</returns>
        public FileResponse RepoUpdateFile(string owner, string repo, string filepath, UpdateFileOptions body, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<FileResponse> localVarResponse = RepoUpdateFileWithHttpInfo(owner, repo, filepath, body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Update a file in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">path of the file to update</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of FileResponse</returns>
        public Org.OpenAPITools.Client.ApiResponse<FileResponse> RepoUpdateFileWithHttpInfo(string owner, string repo, string filepath, UpdateFileOptions body, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoUpdateFile");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoUpdateFile");
            }

            // verify the required parameter 'filepath' is set
            if (filepath == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'filepath' when calling RepositoryApi->RepoUpdateFile");
            }

            // verify the required parameter 'body' is set
            if (body == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'body' when calling RepositoryApi->RepoUpdateFile");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("filepath", Org.OpenAPITools.Client.ClientUtils.ParameterToString(filepath)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoUpdateFile";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<FileResponse>("/repos/{owner}/{repo}/contents/{filepath}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoUpdateFile", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update a file in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">path of the file to update</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of FileResponse</returns>
        public async System.Threading.Tasks.Task<FileResponse> RepoUpdateFileAsync(string owner, string repo, string filepath, UpdateFileOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<FileResponse> localVarResponse = await RepoUpdateFileWithHttpInfoAsync(owner, repo, filepath, body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Update a file in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="filepath">path of the file to update</param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (FileResponse)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<FileResponse>> RepoUpdateFileWithHttpInfoAsync(string owner, string repo, string filepath, UpdateFileOptions body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoUpdateFile");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoUpdateFile");
            }

            // verify the required parameter 'filepath' is set
            if (filepath == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'filepath' when calling RepositoryApi->RepoUpdateFile");
            }

            // verify the required parameter 'body' is set
            if (body == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'body' when calling RepositoryApi->RepoUpdateFile");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("filepath", Org.OpenAPITools.Client.ClientUtils.ParameterToString(filepath)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoUpdateFile";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<FileResponse>("/repos/{owner}/{repo}/contents/{filepath}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoUpdateFile", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Merge PR&#39;s baseBranch into headBranch 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="style">how to update pull request (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RepoUpdatePullRequest(string owner, string repo, long index, string? style = default(string?), int operationIndex = 0)
        {
            RepoUpdatePullRequestWithHttpInfo(owner, repo, index, style);
        }

        /// <summary>
        /// Merge PR&#39;s baseBranch into headBranch 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="style">how to update pull request (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> RepoUpdatePullRequestWithHttpInfo(string owner, string repo, long index, string? style = default(string?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoUpdatePullRequest");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoUpdatePullRequest");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter
            if (style != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "style", style));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoUpdatePullRequest";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/repos/{owner}/{repo}/pulls/{index}/update", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoUpdatePullRequest", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Merge PR&#39;s baseBranch into headBranch 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="style">how to update pull request (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RepoUpdatePullRequestAsync(string owner, string repo, long index, string? style = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RepoUpdatePullRequestWithHttpInfoAsync(owner, repo, index, style, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Merge PR&#39;s baseBranch into headBranch 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="index">index of the pull request to get</param>
        /// <param name="style">how to update pull request (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> RepoUpdatePullRequestWithHttpInfoAsync(string owner, string repo, long index, string? style = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoUpdatePullRequest");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoUpdatePullRequest");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", Org.OpenAPITools.Client.ClientUtils.ParameterToString(index)); // path parameter
            if (style != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "style", style));
            }

            localVarRequestOptions.Operation = "RepositoryApi.RepoUpdatePullRequest";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/repos/{owner}/{repo}/pulls/{index}/update", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoUpdatePullRequest", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Replace list of topics for a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RepoUpdateTopics(string owner, string repo, RepoTopicOptions? body = default(RepoTopicOptions?), int operationIndex = 0)
        {
            RepoUpdateTopicsWithHttpInfo(owner, repo, body);
        }

        /// <summary>
        /// Replace list of topics for a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> RepoUpdateTopicsWithHttpInfo(string owner, string repo, RepoTopicOptions? body = default(RepoTopicOptions?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoUpdateTopics");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoUpdateTopics");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json",
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoUpdateTopics";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<Object>("/repos/{owner}/{repo}/topics", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoUpdateTopics", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Replace list of topics for a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RepoUpdateTopicsAsync(string owner, string repo, RepoTopicOptions? body = default(RepoTopicOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RepoUpdateTopicsWithHttpInfoAsync(owner, repo, body, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Replace list of topics for a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> RepoUpdateTopicsWithHttpInfoAsync(string owner, string repo, RepoTopicOptions? body = default(RepoTopicOptions?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoUpdateTopics");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoUpdateTopics");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json", 
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.RepoUpdateTopics";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<Object>("/repos/{owner}/{repo}/topics", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoUpdateTopics", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Returns the validation information for a issue config 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>IssueConfigValidation</returns>
        public IssueConfigValidation RepoValidateIssueConfig(string owner, string repo, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<IssueConfigValidation> localVarResponse = RepoValidateIssueConfigWithHttpInfo(owner, repo);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Returns the validation information for a issue config 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of IssueConfigValidation</returns>
        public Org.OpenAPITools.Client.ApiResponse<IssueConfigValidation> RepoValidateIssueConfigWithHttpInfo(string owner, string repo, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoValidateIssueConfig");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoValidateIssueConfig");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoValidateIssueConfig";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<IssueConfigValidation>("/repos/{owner}/{repo}/issue_config/validate", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoValidateIssueConfig", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Returns the validation information for a issue config 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of IssueConfigValidation</returns>
        public async System.Threading.Tasks.Task<IssueConfigValidation> RepoValidateIssueConfigAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<IssueConfigValidation> localVarResponse = await RepoValidateIssueConfigWithHttpInfoAsync(owner, repo, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Returns the validation information for a issue config 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (IssueConfigValidation)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<IssueConfigValidation>> RepoValidateIssueConfigWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->RepoValidateIssueConfig");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->RepoValidateIssueConfig");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.RepoValidateIssueConfig";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<IssueConfigValidation>("/repos/{owner}/{repo}/issue_config/validate", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RepoValidateIssueConfig", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// search topics via keyword 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">keywords to search</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;TopicResponse&gt;</returns>
        public List<TopicResponse> TopicSearch(string q, int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<TopicResponse>> localVarResponse = TopicSearchWithHttpInfo(q, page, limit);
            return localVarResponse.Data;
        }

        /// <summary>
        /// search topics via keyword 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">keywords to search</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;TopicResponse&gt;</returns>
        public Org.OpenAPITools.Client.ApiResponse<List<TopicResponse>> TopicSearchWithHttpInfo(string q, int? page = default(int?), int? limit = default(int?), int operationIndex = 0)
        {
            // verify the required parameter 'q' is set
            if (q == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'q' when calling RepositoryApi->TopicSearch");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "q", q));
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.TopicSearch";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<TopicResponse>>("/topics/search", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("TopicSearch", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// search topics via keyword 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">keywords to search</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;TopicResponse&gt;</returns>
        public async System.Threading.Tasks.Task<List<TopicResponse>> TopicSearchAsync(string q, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<TopicResponse>> localVarResponse = await TopicSearchWithHttpInfoAsync(q, page, limit, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// search topics via keyword 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="q">keywords to search</param>
        /// <param name="page">page number of results to return (1-based) (optional)</param>
        /// <param name="limit">page size of results (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;TopicResponse&gt;)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<TopicResponse>>> TopicSearchWithHttpInfoAsync(string q, int? page = default(int?), int? limit = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'q' is set
            if (q == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'q' when calling RepositoryApi->TopicSearch");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "q", q));
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            localVarRequestOptions.Operation = "RepositoryApi.TopicSearch";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<TopicResponse>>("/topics/search", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("TopicSearch", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create or Update a secret value in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repository</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="secretname">name of the secret</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void UpdateRepoSecret(string owner, string repo, string secretname, CreateOrUpdateSecretOption? body = default(CreateOrUpdateSecretOption?), int operationIndex = 0)
        {
            UpdateRepoSecretWithHttpInfo(owner, repo, secretname, body);
        }

        /// <summary>
        /// Create or Update a secret value in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repository</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="secretname">name of the secret</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> UpdateRepoSecretWithHttpInfo(string owner, string repo, string secretname, CreateOrUpdateSecretOption? body = default(CreateOrUpdateSecretOption?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->UpdateRepoSecret");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->UpdateRepoSecret");
            }

            // verify the required parameter 'secretname' is set
            if (secretname == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'secretname' when calling RepositoryApi->UpdateRepoSecret");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("secretname", Org.OpenAPITools.Client.ClientUtils.ParameterToString(secretname)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.UpdateRepoSecret";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<Object>("/repos/{owner}/{repo}/actions/secrets/{secretname}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateRepoSecret", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create or Update a secret value in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repository</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="secretname">name of the secret</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UpdateRepoSecretAsync(string owner, string repo, string secretname, CreateOrUpdateSecretOption? body = default(CreateOrUpdateSecretOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await UpdateRepoSecretWithHttpInfoAsync(owner, repo, secretname, body, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Create or Update a secret value in a repository 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repository</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="secretname">name of the secret</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> UpdateRepoSecretWithHttpInfoAsync(string owner, string repo, string secretname, CreateOrUpdateSecretOption? body = default(CreateOrUpdateSecretOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->UpdateRepoSecret");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->UpdateRepoSecret");
            }

            // verify the required parameter 'secretname' is set
            if (secretname == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'secretname' when calling RepositoryApi->UpdateRepoSecret");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("secretname", Org.OpenAPITools.Client.ClientUtils.ParameterToString(secretname)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.UpdateRepoSecret";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<Object>("/repos/{owner}/{repo}/actions/secrets/{secretname}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateRepoSecret", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update a repo-level variable 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="variablename">name of the variable</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void UpdateRepoVariable(string owner, string repo, string variablename, UpdateVariableOption? body = default(UpdateVariableOption?), int operationIndex = 0)
        {
            UpdateRepoVariableWithHttpInfo(owner, repo, variablename, body);
        }

        /// <summary>
        /// Update a repo-level variable 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="variablename">name of the variable</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> UpdateRepoVariableWithHttpInfo(string owner, string repo, string variablename, UpdateVariableOption? body = default(UpdateVariableOption?), int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->UpdateRepoVariable");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->UpdateRepoVariable");
            }

            // verify the required parameter 'variablename' is set
            if (variablename == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'variablename' when calling RepositoryApi->UpdateRepoVariable");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json",
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("variablename", Org.OpenAPITools.Client.ClientUtils.ParameterToString(variablename)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.UpdateRepoVariable";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<Object>("/repos/{owner}/{repo}/actions/variables/{variablename}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateRepoVariable", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update a repo-level variable 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="variablename">name of the variable</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UpdateRepoVariableAsync(string owner, string repo, string variablename, UpdateVariableOption? body = default(UpdateVariableOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await UpdateRepoVariableWithHttpInfoAsync(owner, repo, variablename, body, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Update a repo-level variable 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">name of the owner</param>
        /// <param name="repo">name of the repository</param>
        /// <param name="variablename">name of the variable</param>
        /// <param name="body"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> UpdateRepoVariableWithHttpInfoAsync(string owner, string repo, string variablename, UpdateVariableOption? body = default(UpdateVariableOption?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->UpdateRepoVariable");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->UpdateRepoVariable");
            }

            // verify the required parameter 'variablename' is set
            if (variablename == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'variablename' when calling RepositoryApi->UpdateRepoVariable");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json", 
                "text/plain"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("variablename", Org.OpenAPITools.Client.ClientUtils.ParameterToString(variablename)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "RepositoryApi.UpdateRepoVariable";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<Object>("/repos/{owner}/{repo}/actions/variables/{variablename}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateRepoVariable", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Check if the current user is watching a repo 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>WatchInfo</returns>
        public WatchInfo UserCurrentCheckSubscription(string owner, string repo, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<WatchInfo> localVarResponse = UserCurrentCheckSubscriptionWithHttpInfo(owner, repo);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Check if the current user is watching a repo 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of WatchInfo</returns>
        public Org.OpenAPITools.Client.ApiResponse<WatchInfo> UserCurrentCheckSubscriptionWithHttpInfo(string owner, string repo, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->UserCurrentCheckSubscription");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->UserCurrentCheckSubscription");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "text/html"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.UserCurrentCheckSubscription";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<WatchInfo>("/repos/{owner}/{repo}/subscription", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UserCurrentCheckSubscription", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Check if the current user is watching a repo 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of WatchInfo</returns>
        public async System.Threading.Tasks.Task<WatchInfo> UserCurrentCheckSubscriptionAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<WatchInfo> localVarResponse = await UserCurrentCheckSubscriptionWithHttpInfoAsync(owner, repo, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Check if the current user is watching a repo 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (WatchInfo)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<WatchInfo>> UserCurrentCheckSubscriptionWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->UserCurrentCheckSubscription");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->UserCurrentCheckSubscription");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "text/html"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.UserCurrentCheckSubscription";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<WatchInfo>("/repos/{owner}/{repo}/subscription", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UserCurrentCheckSubscription", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Unwatch a repo 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void UserCurrentDeleteSubscription(string owner, string repo, int operationIndex = 0)
        {
            UserCurrentDeleteSubscriptionWithHttpInfo(owner, repo);
        }

        /// <summary>
        /// Unwatch a repo 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Org.OpenAPITools.Client.ApiResponse<Object> UserCurrentDeleteSubscriptionWithHttpInfo(string owner, string repo, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->UserCurrentDeleteSubscription");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->UserCurrentDeleteSubscription");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.UserCurrentDeleteSubscription";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/repos/{owner}/{repo}/subscription", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UserCurrentDeleteSubscription", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Unwatch a repo 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UserCurrentDeleteSubscriptionAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await UserCurrentDeleteSubscriptionWithHttpInfoAsync(owner, repo, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Unwatch a repo 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<Object>> UserCurrentDeleteSubscriptionWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->UserCurrentDeleteSubscription");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->UserCurrentDeleteSubscription");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.UserCurrentDeleteSubscription";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/repos/{owner}/{repo}/subscription", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UserCurrentDeleteSubscription", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Watch a repo 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>WatchInfo</returns>
        public WatchInfo UserCurrentPutSubscription(string owner, string repo, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<WatchInfo> localVarResponse = UserCurrentPutSubscriptionWithHttpInfo(owner, repo);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Watch a repo 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of WatchInfo</returns>
        public Org.OpenAPITools.Client.ApiResponse<WatchInfo> UserCurrentPutSubscriptionWithHttpInfo(string owner, string repo, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->UserCurrentPutSubscription");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->UserCurrentPutSubscription");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "text/html"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.UserCurrentPutSubscription";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<WatchInfo>("/repos/{owner}/{repo}/subscription", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UserCurrentPutSubscription", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Watch a repo 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of WatchInfo</returns>
        public async System.Threading.Tasks.Task<WatchInfo> UserCurrentPutSubscriptionAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<WatchInfo> localVarResponse = await UserCurrentPutSubscriptionWithHttpInfoAsync(owner, repo, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Watch a repo 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (WatchInfo)</returns>
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<WatchInfo>> UserCurrentPutSubscriptionWithHttpInfoAsync(string owner, string repo, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->UserCurrentPutSubscription");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->UserCurrentPutSubscription");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "text/html"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.UserCurrentPutSubscription";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<WatchInfo>("/repos/{owner}/{repo}/subscription", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UserCurrentPutSubscription", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List a user&#39;s tracked times in a repo 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="user">username of user</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;TrackedTime&gt;</returns>
        [Obsolete]
        public List<TrackedTime> UserTrackedTimes(string owner, string repo, string user, int operationIndex = 0)
        {
            Org.OpenAPITools.Client.ApiResponse<List<TrackedTime>> localVarResponse = UserTrackedTimesWithHttpInfo(owner, repo, user);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List a user&#39;s tracked times in a repo 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="user">username of user</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;TrackedTime&gt;</returns>
        [Obsolete]
        public Org.OpenAPITools.Client.ApiResponse<List<TrackedTime>> UserTrackedTimesWithHttpInfo(string owner, string repo, string user, int operationIndex = 0)
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->UserTrackedTimes");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->UserTrackedTimes");
            }

            // verify the required parameter 'user' is set
            if (user == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'user' when calling RepositoryApi->UserTrackedTimes");
            }

            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("user", Org.OpenAPITools.Client.ClientUtils.ParameterToString(user)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.UserTrackedTimes";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<TrackedTime>>("/repos/{owner}/{repo}/times/{user}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UserTrackedTimes", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List a user&#39;s tracked times in a repo 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="user">username of user</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;TrackedTime&gt;</returns>
        [Obsolete]
        public async System.Threading.Tasks.Task<List<TrackedTime>> UserTrackedTimesAsync(string owner, string repo, string user, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Org.OpenAPITools.Client.ApiResponse<List<TrackedTime>> localVarResponse = await UserTrackedTimesWithHttpInfoAsync(owner, repo, user, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List a user&#39;s tracked times in a repo 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="owner">owner of the repo</param>
        /// <param name="repo">name of the repo</param>
        /// <param name="user">username of user</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;TrackedTime&gt;)</returns>
        [Obsolete]
        public async System.Threading.Tasks.Task<Org.OpenAPITools.Client.ApiResponse<List<TrackedTime>>> UserTrackedTimesWithHttpInfoAsync(string owner, string repo, string user, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'owner' is set
            if (owner == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'owner' when calling RepositoryApi->UserTrackedTimes");
            }

            // verify the required parameter 'repo' is set
            if (repo == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'repo' when calling RepositoryApi->UserTrackedTimes");
            }

            // verify the required parameter 'user' is set
            if (user == null)
            {
                throw new Org.OpenAPITools.Client.ApiException(400, "Missing required parameter 'user' when calling RepositoryApi->UserTrackedTimes");
            }


            Org.OpenAPITools.Client.RequestOptions localVarRequestOptions = new Org.OpenAPITools.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Org.OpenAPITools.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Org.OpenAPITools.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("owner", Org.OpenAPITools.Client.ClientUtils.ParameterToString(owner)); // path parameter
            localVarRequestOptions.PathParameters.Add("repo", Org.OpenAPITools.Client.ClientUtils.ParameterToString(repo)); // path parameter
            localVarRequestOptions.PathParameters.Add("user", Org.OpenAPITools.Client.ClientUtils.ParameterToString(user)); // path parameter

            localVarRequestOptions.Operation = "RepositoryApi.UserTrackedTimes";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (TOTPHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-GITEA-OTP", this.Configuration.GetApiKeyWithPrefix("X-GITEA-OTP"));
            }
            // authentication (AuthorizationHeaderToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", this.Configuration.GetApiKeyWithPrefix("Authorization"));
            }
            // authentication (SudoHeader) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Sudo")))
            {
                localVarRequestOptions.HeaderParameters.Add("Sudo", this.Configuration.GetApiKeyWithPrefix("Sudo"));
            }
            // authentication (BasicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Org.OpenAPITools.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (AccessToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("access_token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "access_token", this.Configuration.GetApiKeyWithPrefix("access_token")));
            }
            // authentication (SudoParam) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("sudo")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "sudo", this.Configuration.GetApiKeyWithPrefix("sudo")));
            }
            // authentication (Token) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("token")))
            {
                localVarRequestOptions.QueryParameters.Add(Org.OpenAPITools.Client.ClientUtils.ParameterToMultiMap("", "token", this.Configuration.GetApiKeyWithPrefix("token")));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<TrackedTime>>("/repos/{owner}/{repo}/times/{user}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UserTrackedTimes", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}
